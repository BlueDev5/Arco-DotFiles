/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 5623:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 3644:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var concatMap = __webpack_require__(1048);
var balanced = __webpack_require__(5623);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 1048:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 1171:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = __webpack_require__(1017)
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(3644)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 2257:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(2893)
const {re, t} = __webpack_require__(5765)
const cmp = __webpack_require__(7539)
const debug = __webpack_require__(4225)
const SemVer = __webpack_require__(6376)
const Range = __webpack_require__(6902)


/***/ }),

/***/ 6902:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0)
        this.set = [first]
      else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:${memoOpts}:${range}`
    const cached = cache.get(memoKey)
    if (cached)
      return cached

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const l = rangeList.length
    const rangeMap = new Map()
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp]
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has(''))
      rangeMap.delete('')

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const LRU = __webpack_require__(6062)
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(2893)
const Comparator = __webpack_require__(2257)
const debug = __webpack_require__(4225)
const SemVer = __webpack_require__(6376)
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = __webpack_require__(5765)

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<')
        pr = '-0'

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ 6376:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(4225)
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(3295)
const { re, t } = __webpack_require__(5765)

const parseOptions = __webpack_require__(2893)
const { compareIdentifiers } = __webpack_require__(6742)
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ 3507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(3959)
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ 7539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(8718)
const neq = __webpack_require__(1194)
const gt = __webpack_require__(1312)
const gte = __webpack_require__(5903)
const lt = __webpack_require__(1544)
const lte = __webpack_require__(2056)

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ 9038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const parse = __webpack_require__(3959)
const {re, t} = __webpack_require__(5765)

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),

/***/ 8880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ 7880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ 6269:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ 2378:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(3959)
const eq = __webpack_require__(8718)

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),

/***/ 8718:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ 1312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ 5903:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ 253:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ 1544:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ 2056:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ 8679:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ 7789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ 1194:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ 3959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {MAX_LENGTH} = __webpack_require__(3295)
const { re, t } = __webpack_require__(5765)
const SemVer = __webpack_require__(6376)

const parseOptions = __webpack_require__(2893)
const parse = (version, options) => {
  options = parseOptions(options)

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),

/***/ 2358:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ 7559:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(3959)
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ 9795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ 3657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(8880)
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ 5712:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(6902)
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ 1100:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(8880)
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ 6397:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(3959)
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ 1249:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(5765)
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: __webpack_require__(3295).SEMVER_SPEC_VERSION,
  SemVer: __webpack_require__(6376),
  compareIdentifiers: __webpack_require__(6742).compareIdentifiers,
  rcompareIdentifiers: __webpack_require__(6742).rcompareIdentifiers,
  parse: __webpack_require__(3959),
  valid: __webpack_require__(6397),
  clean: __webpack_require__(3507),
  inc: __webpack_require__(253),
  diff: __webpack_require__(2378),
  major: __webpack_require__(8679),
  minor: __webpack_require__(7789),
  patch: __webpack_require__(2358),
  prerelease: __webpack_require__(7559),
  compare: __webpack_require__(6269),
  rcompare: __webpack_require__(9795),
  compareLoose: __webpack_require__(7880),
  compareBuild: __webpack_require__(8880),
  sort: __webpack_require__(1100),
  rsort: __webpack_require__(3657),
  gt: __webpack_require__(1312),
  lt: __webpack_require__(1544),
  eq: __webpack_require__(8718),
  neq: __webpack_require__(1194),
  gte: __webpack_require__(5903),
  lte: __webpack_require__(2056),
  cmp: __webpack_require__(7539),
  coerce: __webpack_require__(9038),
  Comparator: __webpack_require__(2257),
  Range: __webpack_require__(6902),
  satisfies: __webpack_require__(5712),
  toComparators: __webpack_require__(1042),
  maxSatisfying: __webpack_require__(5775),
  minSatisfying: __webpack_require__(1657),
  minVersion: __webpack_require__(5316),
  validRange: __webpack_require__(9042),
  outside: __webpack_require__(6826),
  gtr: __webpack_require__(7606),
  ltr: __webpack_require__(32),
  intersects: __webpack_require__(2937),
  simplifyRange: __webpack_require__(7908),
  subset: __webpack_require__(799),
}


/***/ }),

/***/ 3295:
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
}


/***/ }),

/***/ 4225:
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ 6742:
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
}


/***/ }),

/***/ 2893:
/***/ ((module) => {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl']
const parseOptions = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((options, k) => {
    options[k] = true
    return options
  }, {})
module.exports = parseOptions


/***/ }),

/***/ 5765:
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(3295)
const debug = __webpack_require__(4225)
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$')


/***/ }),

/***/ 6062:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(2221)

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache


/***/ }),

/***/ 9307:
/***/ ((module) => {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),

/***/ 2221:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(9307)(Yallist)
} catch (er) {}


/***/ }),

/***/ 7606:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(6826)
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ 2937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(6902)
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),

/***/ 32:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(6826)
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ 5775:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const Range = __webpack_require__(6902)

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ 1657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const Range = __webpack_require__(6902)
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ 5316:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const Range = __webpack_require__(6902)
const gt = __webpack_require__(1312)

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin)))
      minver = setMin
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ 6826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const Comparator = __webpack_require__(2257)
const {ANY} = Comparator
const Range = __webpack_require__(6902)
const satisfies = __webpack_require__(5712)
const gt = __webpack_require__(1312)
const lt = __webpack_require__(1544)
const lte = __webpack_require__(2056)
const gte = __webpack_require__(5903)

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ 7908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(5712)
const compare = __webpack_require__(6269)
module.exports = (versions, range, options) => {
  const set = []
  let min = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!min)
        min = version
    } else {
      if (prev) {
        set.push([min, prev])
      }
      prev = null
      min = null
    }
  }
  if (min)
    set.push([min, null])

  const ranges = []
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min)
    else if (!max && min === v[0])
      ranges.push('*')
    else if (!max)
      ranges.push(`>=${min}`)
    else if (min === v[0])
      ranges.push(`<=${max}`)
    else
      ranges.push(`${min} - ${max}`)
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ 799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(6902)
const Comparator = __webpack_require__(2257)
const { ANY } = Comparator
const satisfies = __webpack_require__(5712)
const compare = __webpack_require__(6269)

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true
    else if (options.includePrerelease)
      sub = [ new Comparator('>=0.0.0-0') ]
    else
      sub = [ new Comparator('>=0.0.0') ]
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true
    else
      dom = [ new Comparator('>=0.0.0') ]
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ 1042:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(6902)

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ 9042:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(6902)
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ 4256:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAnalyzerArgs = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const extension_utils_1 = __webpack_require__(6143);
const utils_1 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
function getAnalyzerArgs(logger, sdks, dartCapabilities, isLsp) {
    const analyzerPath = config_1.config.analyzerPath || (dartCapabilities.supportsLanguageServerCommand
        ? "language-server"
        : path.join(sdks.dart, constants_1.analyzerSnapshotPath));
    // If the ssh host is set, then we are running the analyzer on a remote machine, that same analyzer
    // might not exist on the local machine.
    if (!config_1.config.analyzerSshHost && analyzerPath !== "language-server" && !fs.existsSync(analyzerPath)) {
        const msg = "Could not find a Dart Analysis Server at " + analyzerPath;
        vs.window.showErrorMessage(msg);
        logger.error(msg);
        throw new Error(msg);
    }
    return buildAnalyzerArgs(analyzerPath, dartCapabilities, isLsp);
}
exports.getAnalyzerArgs = getAnalyzerArgs;
function buildAnalyzerArgs(analyzerPath, dartCapabilities, isLsp) {
    let analyzerArgs = [];
    // Optionally start the VM service for the analyzer.
    if (config_1.config.analyzerVmServicePort) {
        analyzerArgs.push(`--enable-vm-service=${config_1.config.analyzerVmServicePort}`);
        // When using LSP, printing the VM Service URI will break the protocol and
        // stop the client from working, so it needs to be hidden.
        analyzerArgs.push(`-DSILENT_OBSERVATORY=true`);
        analyzerArgs.push(`--disable-service-auth-codes`);
        if (dartCapabilities.supportsNoServeDevTools)
            analyzerArgs.push("--no-serve-devtools");
        vs.window.showInformationMessage("The Dart Analysis server is running with the debugger accessible. Please disable (unset the `dart.analyzerVmServicePort` setting) when no longer required.");
    }
    analyzerArgs.push(analyzerPath);
    if (analyzerPath === "language-server") {
        if (!isLsp)
            analyzerArgs.push("--protocol=analyzer");
    }
    else {
        if (isLsp)
            analyzerArgs.push("--lsp");
    }
    // Optionally start the analyzer's diagnostic web server on the given port.
    if (config_1.config.analyzerDiagnosticsPort)
        analyzerArgs.push(`--port=${config_1.config.analyzerDiagnosticsPort}`);
    // Add info about the extension that will be collected for crash reports etc.
    const clientID = utils_1.isRunningLocally ? "VS-Code" : "VS-Code-Remote";
    analyzerArgs.push(`--client-id=${clientID}`);
    analyzerArgs.push(`--client-version=${extension_utils_1.extensionVersion}`);
    // The analysis server supports a verbose instrumentation log file.
    if (config_1.config.analyzerInstrumentationLogFile)
        analyzerArgs.push(`--instrumentation-log-file=${config_1.config.analyzerInstrumentationLogFile}`);
    // Allow arbitrary args to be passed to the analysis server.
    if (config_1.config.analyzerAdditionalArgs)
        analyzerArgs = analyzerArgs.concat(config_1.config.analyzerAdditionalArgs);
    return analyzerArgs;
}


/***/ }),

/***/ 2061:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSymbolKindForElementKind = exports.DasAnalyzerClient = exports.DasAnalyzer = exports.AnalyzerCapabilities = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const analyzer_1 = __webpack_require__(458);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
const config_1 = __webpack_require__(4165);
const utils_2 = __webpack_require__(8779);
const misc_1 = __webpack_require__(9106);
const processes_1 = __webpack_require__(5430);
const analyzer_2 = __webpack_require__(4256);
const analyzer_gen_1 = __webpack_require__(1271);
const file_tracker_das_1 = __webpack_require__(9016);
class AnalyzerCapabilities {
    constructor(analyzerVersion) {
        this.version = analyzerVersion;
    }
    static get empty() { return new AnalyzerCapabilities("0.0.0"); }
    get hasCompleteStatementFix() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.2"); }
    get supportsPriorityFilesOutsideAnalysisRoots() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.2"); }
    get supportsDiagnostics() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.1"); }
    get supportsClosingLabels() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.4"); }
    get supportsCustomFolding() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.3"); }
    // 1.26.0 is stable Flutter at time of writing. Unclear what version had Outline, but
    // we don't need to support older.
    get supportsFlutterOutline() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0"); }
    get supportsGetDeclerations() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.7"); }
    get supportsGetDeclerationsForFile() { return (0, utils_1.versionIsAtLeast)(this.version, "1.19.0"); }
    get supportsGetSignature() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.5"); }
    get supportsMoveFile() { return (0, utils_1.versionIsAtLeast)(this.version, "1.27.0"); }
    get supportsAvailableSuggestions() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0"); }
    get supportsIncludedImports() { return (0, utils_1.versionIsAtLeast)(this.version, "1.27.1"); }
}
exports.AnalyzerCapabilities = AnalyzerCapabilities;
class DasAnalyzer extends analyzer_1.Analyzer {
    constructor(logger, analytics, sdks, dartCapabilities, wsContext) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.Analyzer));
        this.client = new DasAnalyzerClient(this.logger, sdks, dartCapabilities);
        this.fileTracker = new file_tracker_das_1.DasFileTracker(logger, this.client, wsContext);
        this.disposables.push(this.client);
        this.disposables.push(this.fileTracker);
        const connectedEvent = this.client.registerForServerConnected((sc) => {
            // TODO: Lsp equiv.
            analytics.analysisServerVersion = sc.version;
            this.onReadyCompleter.resolve();
            connectedEvent.dispose();
        });
        this.client.registerForServerStatus((params) => {
            if (params.analysis)
                this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: params.analysis.isAnalyzing });
        });
    }
    getDiagnosticServerPort() {
        return this.client.diagnosticGetServerPort();
    }
    forceReanalyze() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.analysisReanalyze();
        });
    }
}
exports.DasAnalyzer = DasAnalyzer;
class DasAnalyzerClient extends analyzer_gen_1.AnalyzerGen {
    constructor(logger, sdks, dartCapabilities) {
        var _a;
        super(logger, config_1.config.maxLogLineLength);
        this.isAnalyzing = false;
        this.capabilities = AnalyzerCapabilities.empty;
        this.resolvedPromise = Promise.resolve();
        this.serverTerminatedSubscriptions = [];
        this.launchArgs = (0, analyzer_2.getAnalyzerArgs)(logger, sdks, dartCapabilities, false);
        // Hook error subscriptions so we can try and get diagnostic info if this happens.
        this.registerForServerError((e) => this.requestDiagnosticsUpdate());
        this.registerForRequestError((e) => this.requestDiagnosticsUpdate());
        // Register for version.
        this.registerForServerConnected((e) => { this.version = e.version; this.capabilities.version = this.version; });
        const fullDartVmPath = path.join(sdks.dart, constants_1.dartVMPath);
        let binaryPath = fullDartVmPath;
        let processArgs = this.launchArgs.slice();
        // Since we communicate with the analysis server over STDOUT/STDIN, it is trivial for us
        // to support launching it on a remote machine over SSH. This can be useful if the codebase
        // is being modified remotely over SSHFS, and running the analysis server locally would
        // result in excessive file reading over SSHFS.
        if (config_1.config.analyzerSshHost) {
            binaryPath = "ssh";
            processArgs.unshift(fullDartVmPath);
            processArgs = [
                // SSH quiet mode, which prevents SSH from interfering with the STDOUT/STDIN communication
                // with the analysis server.
                "-q",
                config_1.config.analyzerSshHost,
                (0, utils_2.escapeShell)(processArgs),
            ];
        }
        this.createProcess(undefined, binaryPath, processArgs, { toolEnv: (0, processes_1.getToolEnv)() });
        (_a = this.process) === null || _a === void 0 ? void 0 : _a.on("exit", (code, signal) => {
            this.handleAnalyzerTerminated(!!code);
        });
        this.registerForServerStatus((n) => {
            if (n.analysis) {
                if (n.analysis.isAnalyzing) {
                    this.isAnalyzing = true;
                }
                else {
                    this.isAnalyzing = false;
                    if (this.currentAnalysisCompleter) {
                        this.currentAnalysisCompleter.resolve();
                        this.currentAnalysisCompleter = undefined;
                    }
                }
            }
        });
        // tslint:disable-next-line: no-floating-promises
        this.serverSetSubscriptions({
            subscriptions: ["STATUS"],
        });
    }
    get currentAnalysis() {
        if (!this.isAnalyzing)
            return this.resolvedPromise;
        if (!this.currentAnalysisCompleter)
            this.currentAnalysisCompleter = new utils_1.PromiseCompleter();
        return this.currentAnalysisCompleter.promise;
    }
    sendMessage(json) {
        try {
            super.sendMessage(json);
        }
        catch (e) {
            this.handleAnalyzerTerminated(true);
            throw e;
        }
    }
    handleAnalyzerTerminated(withError) {
        const serverHasStarted = !!this.version;
        if (withError)
            (0, misc_1.reportAnalyzerTerminatedWithError)(!serverHasStarted);
        this.notify(this.serverTerminatedSubscriptions, undefined);
    }
    shouldHandleMessage(message) {
        // This will include things like Observatory output and some analyzer logging code.
        return !message.startsWith("--- ")
            && !message.startsWith("+++ ")
            && !message.startsWith("Observatory listening on")
            && !message.startsWith("Observatory server");
    }
    requestDiagnosticsUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            this.lastDiagnostics = undefined;
            if (!this.capabilities.supportsDiagnostics)
                return;
            this.lastDiagnostics = (yield this.diagnosticGetDiagnostics()).contexts;
        });
    }
    getLastDiagnostics() {
        return this.lastDiagnostics;
    }
    getAnalyzerLaunchArgs() {
        return this.launchArgs;
    }
    forceNotificationsFor(file) {
        // Send a dummy edit (https://github.com/dart-lang/sdk/issues/30238)
        const files = {};
        files[file] = {
            edits: [{ offset: 0, length: 0, replacement: "", id: "" }],
            type: "change",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analysisUpdateContent({ files });
    }
    // Wraps completionGetSuggestions to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    completionGetSuggestionsResults(request) {
        return this.requestWithStreamedResults(() => this.completionGetSuggestions(request), this.registerForCompletionResults);
    }
    // Wraps searchFindElementReferences to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindElementReferencesResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindElementReferences(request), this.registerForSearchResults);
    }
    // Wraps searchFindTopLevelDeclarations to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindTopLevelDeclarationsResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindTopLevelDeclarations(request), this.registerForSearchResults);
    }
    // Wraps searchFindMemberDeclarations to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindMemberDeclarationsResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindMemberDeclarations(request), this.registerForSearchResults);
    }
    // We need to subscribe before we send the request to avoid races in registering
    // for results (see https://github.com/Dart-Code/Dart-Code/issues/471).
    // Since we don't have the ID yet, we'll have to buffer them for the duration
    // and check inside the buffer when we get the ID back.
    requestWithStreamedResults(sendRequest, registerForResults) {
        return new Promise((resolve, reject) => {
            const buffer = []; // Buffer to store results that come in before we're ready.
            let searchResultsID; // ID that'll be set once we get it back.
            const disposable = registerForResults.bind(this)((notification) => {
                // If we know our ID and this is it, and it's the last result, then resolve.
                if (searchResultsID && notification.id === searchResultsID && notification.isLast) {
                    disposable.dispose();
                    resolve(notification);
                }
                else if (!searchResultsID && notification.isLast) // Otherwise if we didn't know our ID and this might be what we want, stash it.
                    buffer.push(notification);
            });
            // Now we have the above handler set up, send the actual request.
            sendRequest.bind(this)().then((resp) => {
                if (!resp.id) {
                    disposable.dispose();
                    reject();
                }
                // When the ID comes back, stash it...
                searchResultsID = resp.id;
                // And also check the buffer.
                const result = buffer.find((b) => b.id === searchResultsID);
                if (result) {
                    disposable.dispose();
                    resolve(result);
                }
            }, () => reject());
        });
    }
    registerForServerTerminated(subscriber) {
        return this.subscribe(this.serverTerminatedSubscriptions, subscriber);
    }
}
exports.DasAnalyzerClient = DasAnalyzerClient;
function getSymbolKindForElementKind(logger, kind) {
    switch (kind) {
        case "CLASS":
        case "CLASS_TYPE_ALIAS":
        case "MIXIN":
            return vs.SymbolKind.Class;
        case "COMPILATION_UNIT":
        case "EXTENSION":
            return vs.SymbolKind.Module;
        case "CONSTRUCTOR":
        case "CONSTRUCTOR_INVOCATION":
            return vs.SymbolKind.Constructor;
        case "ENUM":
            return vs.SymbolKind.Enum;
        case "ENUM_CONSTANT":
            return vs.SymbolKind.EnumMember;
        case "FIELD":
            return vs.SymbolKind.Field;
        case "FILE":
            return vs.SymbolKind.File;
        case "FUNCTION":
        case "FUNCTION_INVOCATION":
        case "FUNCTION_TYPE_ALIAS":
            return vs.SymbolKind.Function;
        case "GETTER":
            return vs.SymbolKind.Property;
        case "LABEL":
            return vs.SymbolKind.Module;
        case "LIBRARY":
            return vs.SymbolKind.Namespace;
        case "LOCAL_VARIABLE":
            return vs.SymbolKind.Variable;
        case "METHOD":
            return vs.SymbolKind.Method;
        case "PARAMETER":
        case "PREFIX":
            return vs.SymbolKind.Variable;
        case "SETTER":
            return vs.SymbolKind.Property;
        case "TOP_LEVEL_VARIABLE":
        case "TYPE_PARAMETER":
            return vs.SymbolKind.Variable;
        case "UNIT_TEST_GROUP":
            return vs.SymbolKind.Module;
        case "UNIT_TEST_TEST":
            return vs.SymbolKind.Method;
        case "UNKNOWN":
            return vs.SymbolKind.Object;
        default:
            logger.error(`Unknown kind: ${kind}`, enums_1.LogCategory.Analyzer);
            return vs.SymbolKind.Object;
    }
}
exports.getSymbolKindForElementKind = getSymbolKindForElementKind;


/***/ }),

/***/ 1271:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable */
// This file was generated by Dart-Code-Class-Builder
// and should not be hand-edited!
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyzerGen = void 0;
const stdio_service_1 = __webpack_require__(3058);
class AnalyzerGen extends stdio_service_1.StdIOService {
    constructor(logger, maxLogLineLength) {
        super(logger, maxLogLineLength);
        this.serverConnectedSubscriptions = [];
        this.serverErrorSubscriptions = [];
        this.serverStatusSubscriptions = [];
        this.analysisAnalyzedFilesSubscriptions = [];
        this.analysisClosingLabelsSubscriptions = [];
        this.analysisErrorsSubscriptions = [];
        this.analysisFlushResultsSubscriptions = [];
        this.analysisFoldingSubscriptions = [];
        this.analysisHighlightsSubscriptions = [];
        this.analysisImplementedSubscriptions = [];
        this.analysisInvalidateSubscriptions = [];
        this.analysisNavigationSubscriptions = [];
        this.analysisOccurrencesSubscriptions = [];
        this.analysisOutlineSubscriptions = [];
        this.analysisOverridesSubscriptions = [];
        this.completionResultsSubscriptions = [];
        this.completionAvailableSuggestionsSubscriptions = [];
        this.completionExistingImportsSubscriptions = [];
        this.searchResultsSubscriptions = [];
        this.executionLaunchDataSubscriptions = [];
        this.flutterOutlineSubscriptions = [];
    }
    buildRequest(id, method, params) {
        return Object.assign(super.buildRequest(id, method, params), { clientRequestTime: Date.now() });
    }
    handleNotification(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.event) {
                case "server.connected":
                    yield this.notify(this.serverConnectedSubscriptions, evt.params);
                    break;
                case "server.error":
                    yield this.notify(this.serverErrorSubscriptions, evt.params);
                    break;
                case "server.status":
                    yield this.notify(this.serverStatusSubscriptions, evt.params);
                    break;
                case "analysis.analyzedFiles":
                    yield this.notify(this.analysisAnalyzedFilesSubscriptions, evt.params);
                    break;
                case "analysis.closingLabels":
                    yield this.notify(this.analysisClosingLabelsSubscriptions, evt.params);
                    break;
                case "analysis.errors":
                    yield this.notify(this.analysisErrorsSubscriptions, evt.params);
                    break;
                case "analysis.flushResults":
                    yield this.notify(this.analysisFlushResultsSubscriptions, evt.params);
                    break;
                case "analysis.folding":
                    yield this.notify(this.analysisFoldingSubscriptions, evt.params);
                    break;
                case "analysis.highlights":
                    yield this.notify(this.analysisHighlightsSubscriptions, evt.params);
                    break;
                case "analysis.implemented":
                    yield this.notify(this.analysisImplementedSubscriptions, evt.params);
                    break;
                case "analysis.invalidate":
                    yield this.notify(this.analysisInvalidateSubscriptions, evt.params);
                    break;
                case "analysis.navigation":
                    yield this.notify(this.analysisNavigationSubscriptions, evt.params);
                    break;
                case "analysis.occurrences":
                    yield this.notify(this.analysisOccurrencesSubscriptions, evt.params);
                    break;
                case "analysis.outline":
                    yield this.notify(this.analysisOutlineSubscriptions, evt.params);
                    break;
                case "analysis.overrides":
                    yield this.notify(this.analysisOverridesSubscriptions, evt.params);
                    break;
                case "completion.results":
                    yield this.notify(this.completionResultsSubscriptions, evt.params);
                    break;
                case "completion.availableSuggestions":
                    yield this.notify(this.completionAvailableSuggestionsSubscriptions, evt.params);
                    break;
                case "completion.existingImports":
                    yield this.notify(this.completionExistingImportsSubscriptions, evt.params);
                    break;
                case "search.results":
                    yield this.notify(this.searchResultsSubscriptions, evt.params);
                    break;
                case "execution.launchData":
                    yield this.notify(this.executionLaunchDataSubscriptions, evt.params);
                    break;
                case "flutter.outline":
                    yield this.notify(this.flutterOutlineSubscriptions, evt.params);
                    break;
            }
        });
    }
    /**
    Reports that the server is running. This notification is
    issued once after the server has started running but before
    any requests are processed to let the client know that it
    started correctly.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForServerConnected(subscriber) {
        return this.subscribe(this.serverConnectedSubscriptions, subscriber);
    }
    /**
    Reports that an unexpected error has occurred while
    executing the server. This notification is not used for
    problems with specific requests (which are returned as part
    of the response) but is used for exceptions that occur while
    performing other tasks, such as analysis or preparing
    notifications.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForServerError(subscriber) {
        return this.subscribe(this.serverErrorSubscriptions, subscriber);
    }
    /**
    Reports the current status of the server. Parameters are
    omitted if there has been no change in the status
    represented by that parameter.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "STATUS" in
    the list of services passed in a server.setSubscriptions
    request.
    */
    registerForServerStatus(subscriber) {
        return this.subscribe(this.serverStatusSubscriptions, subscriber);
    }
    /**
    Reports the paths of the files that are being analyzed.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "ANALYZED_FILES" in the list
    of services passed in an analysis.setGeneralSubscriptions request.
    */
    registerForAnalysisAnalyzedFiles(subscriber) {
        return this.subscribe(this.analysisAnalyzedFilesSubscriptions, subscriber);
    }
    /**
    Reports closing labels relevant to a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "CLOSING_LABELS"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisClosingLabels(subscriber) {
        return this.subscribe(this.analysisClosingLabelsSubscriptions, subscriber);
    }
    /**
    Reports the errors associated with a given file. The set of
    errors included in the notification is always a complete
    list that supersedes any previously reported errors.
    */
    registerForAnalysisErrors(subscriber) {
        return this.subscribe(this.analysisErrorsSubscriptions, subscriber);
    }
    /**
    Reports that any analysis results that were previously
    associated with the given files should be considered to be
    invalid because those files are no longer being analyzed,
    either because the analysis root that contained it is no
    longer being analyzed or because the file no longer exists.
    If a file is included in this notification and at some later
    time a notification with results for the file is received,
    clients should assume that the file is once again being
    analyzed and the information should be processed.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForAnalysisFlushResults(subscriber) {
        return this.subscribe(this.analysisFlushResultsSubscriptions, subscriber);
    }
    /**
    Reports the folding regions associated with a given
    file. Folding regions can be nested, but will not be
    overlapping. Nesting occurs when a foldable element, such as
    a method, is nested inside another foldable element such as
    a class.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "FOLDING" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisFolding(subscriber) {
        return this.subscribe(this.analysisFoldingSubscriptions, subscriber);
    }
    /**
    Reports the highlight regions associated with a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "HIGHLIGHTS"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisHighlights(subscriber) {
        return this.subscribe(this.analysisHighlightsSubscriptions, subscriber);
    }
    /**
    Reports the classes that are implemented or extended and
    class members that are implemented or overridden in a file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "IMPLEMENTED" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisImplemented(subscriber) {
        return this.subscribe(this.analysisImplementedSubscriptions, subscriber);
    }
    /**
    Reports that the navigation information associated with a region of a
    single file has become invalid and should be re-requested.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "INVALIDATE" in the list of
    services passed in an analysis.setSubscriptions request.
    */
    registerForAnalysisInvalidate(subscriber) {
        return this.subscribe(this.analysisInvalidateSubscriptions, subscriber);
    }
    /**
    Reports the navigation targets associated with a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "NAVIGATION"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisNavigation(subscriber) {
        return this.subscribe(this.analysisNavigationSubscriptions, subscriber);
    }
    /**
    Reports the occurrences of references to elements within a
    single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OCCURRENCES"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisOccurrences(subscriber) {
        return this.subscribe(this.analysisOccurrencesSubscriptions, subscriber);
    }
    /**
    Reports the outline associated with a single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OUTLINE" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisOutline(subscriber) {
        return this.subscribe(this.analysisOutlineSubscriptions, subscriber);
    }
    /**
    Reports the overriding members in a file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OVERRIDES" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisOverrides(subscriber) {
        return this.subscribe(this.analysisOverridesSubscriptions, subscriber);
    }
    /**
    Reports the completion suggestions that should be presented
    to the user. The set of suggestions included in the
    notification is always a complete list that supersedes any
    previously reported suggestions.
    */
    registerForCompletionResults(subscriber) {
        return this.subscribe(this.completionResultsSubscriptions, subscriber);
    }
    /**
    Reports the pre-computed, candidate completions from symbols defined
    in a corresponding library. This notification may be sent multiple times.
    When a notification is processed, clients should replace any previous
    information about the libraries in the list of changedLibraries, discard
    any information about the libraries in the list of removedLibraries, and
    preserve any previously received information about any libraries that are
    not included in either list.
    */
    registerForCompletionAvailableSuggestions(subscriber) {
        return this.subscribe(this.completionAvailableSuggestionsSubscriptions, subscriber);
    }
    /**
    Reports existing imports in a library. This notification may be sent
    multiple times for a library. When a notification is processed, clients
    should replace any previous information for the library.
    */
    registerForCompletionExistingImports(subscriber) {
        return this.subscribe(this.completionExistingImportsSubscriptions, subscriber);
    }
    /**
    Reports some or all of the results of performing a requested
    search. Unlike other notifications, this notification
    contains search results that should be added to any
    previously received search results associated with the same
    search id.
    */
    registerForSearchResults(subscriber) {
        return this.subscribe(this.searchResultsSubscriptions, subscriber);
    }
    /**
    Reports information needed to allow a single file to be launched.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "LAUNCH_DATA" in the list of services
    passed in an execution.setSubscriptions request.
    */
    registerForExecutionLaunchData(subscriber) {
        return this.subscribe(this.executionLaunchDataSubscriptions, subscriber);
    }
    /**
    Reports the Flutter outline associated with a single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OUTLINE" in
    the list of services passed in an flutter.setSubscriptions
    request.
    */
    registerForFlutterOutline(subscriber) {
        return this.subscribe(this.flutterOutlineSubscriptions, subscriber);
    }
    /**
    Return the version number of the analysis server.
    */
    serverGetVersion() {
        return this.sendRequest("server.getVersion");
    }
    /**
    Cleanly shutdown the analysis server. Requests that are
    received after this request will not be processed. Requests
    that were received before this request, but for which a
    response has not yet been sent, will not be responded to. No
    further responses or notifications will be sent after the
    response to this request has been sent.
    */
    serverShutdown() {
        return this.sendRequest("server.shutdown");
    }
    /**
    Subscribe for services. All previous subscriptions are
    replaced by the given set of services.
    It is an error if any of the elements in the list are not
    valid services. If there is an error, then the current
    subscriptions will remain unchanged.
    */
    serverSetSubscriptions(request) {
        return this.sendRequest("server.setSubscriptions", request);
    }
    /**
    Return the errors associated with the given file. If the
    errors for the given file have not yet been computed, or the
    most recently computed errors for the given file are out of
    date, then the response for this request will be delayed
    until they have been computed. If some or all of the errors
    for the file cannot be computed, then the subset of the
    errors that can be computed will be returned and the
    response will contain an error to indicate why the errors
    could not be computed. If the content of the file changes after this
    request was received but before a response could be sent, then an
    error of type CONTENT_MODIFIED will be generated.
    This request is intended to be used by clients that cannot
    asynchronously apply updated error information. Clients that
    can apply error information as it becomes available
    should use the information provided by the 'analysis.errors'
    notification.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_ERRORS_INVALID_FILE will be generated.
    */
    analysisGetErrors(request) {
        return this.sendRequest("analysis.getErrors", request);
    }
    /**
    Return the hover information associate with the given
    location. If some or all of the hover information is not
    available at the time this request is processed the
    information will be omitted from the response.
    */
    analysisGetHover(request) {
        return this.sendRequest("analysis.getHover", request);
    }
    /**
    Return a description of all of the elements referenced in a given region
    of a given file that come from imported libraries.
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified via analysis.setAnalysisRoots), an error of type
    GET_IMPORTED_ELEMENTS_INVALID_FILE will be generated.
    */
    analysisGetImportedElements(request) {
        return this.sendRequest("analysis.getImportedElements", request);
    }
    /**
    Return library dependency information for use in client-side indexing
    and package URI resolution.
    Clients that are only using the libraries field should consider using the
    analyzedFiles notification instead.
    */
    analysisGetLibraryDependencies() {
        return this.sendRequest("analysis.getLibraryDependencies");
    }
    /**
    Return the navigation information associated with the given region of
    the given file. If the navigation information for the given file has
    not yet been computed, or the most recently computed navigation
    information for the given file is out of date, then the response for
    this request will be delayed until it has been computed. If the
    content of the file changes after this request was received but before
    a response could be sent, then an error of type
    CONTENT_MODIFIED will be generated.
    If a navigation region overlaps (but extends either before or after)
    the given region of the file it will be included in the result. This
    means that it is theoretically possible to get the same navigation
    region in response to multiple requests. Clients can avoid this by
    always choosing a region that starts at the beginning of a line and
    ends at the end of a (possibly different) line in the file.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_NAVIGATION_INVALID_FILE will be generated.
    */
    analysisGetNavigation(request) {
        return this.sendRequest("analysis.getNavigation", request);
    }
    /**
    Return the transitive closure of reachable sources for a given file.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_REACHABLE_SOURCES_INVALID_FILE will be generated.
    */
    analysisGetReachableSources(request) {
        return this.sendRequest("analysis.getReachableSources", request);
    }
    /**
    Return the signature information associated with the given
    location in the given file. If the signature information
    for the given file has not yet been computed, or the most
    recently computed signature information for the given file
    is out of date, then the response for this request will be
    delayed until it has been computed.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_SIGNATURE_INVALID_FILE will be generated.
    If the location given is not inside the argument list for a
    function (including method and constructor) invocation, then
    an error of type GET_SIGNATURE_INVALID_OFFSET will
    be generated. If the location is inside an argument list but
    the function is not defined or cannot be determined (such as
    a method invocation where the target has type 'dynamic')
    then an error of type GET_SIGNATURE_UNKNOWN_FUNCTION
    will be generated.
    */
    analysisGetSignature(request) {
        return this.sendRequest("analysis.getSignature", request);
    }
    /**
    Force re-reading of all potentially changed files, re-resolving of all
    referenced URIs, and corresponding re-analysis of everything affected in
    the current analysis roots.
    */
    analysisReanalyze() {
        return this.sendRequest("analysis.reanalyze");
    }
    /**
    Sets the root paths used to determine which files to analyze. The set
    of files to be analyzed are all of the files in one of the root paths
    that are not either explicitly or implicitly excluded. A file is
    explicitly excluded if it is in one of the excluded paths. A file is
    implicitly excluded if it is in a subdirectory of one of the root
    paths where the name of the subdirectory starts with a period (that
    is, a hidden directory).
    Note that this request determines the set of requested
    analysis roots. The actual set of analysis roots at any
    given time is the intersection of this set with the set of
    files and directories actually present on the
    filesystem. When the filesystem changes, the actual set of
    analysis roots is automatically updated, but the set of
    requested analysis roots is unchanged. This means that if
    the client sets an analysis root before the root becomes
    visible to server in the filesystem, there is no error; once
    the server sees the root in the filesystem it will start
    analyzing it. Similarly, server will stop analyzing files
    that are removed from the file system but they will remain
    in the set of requested roots.
    If an included path represents a file, then server will look
    in the directory containing the file for a pubspec.yaml
    file. If none is found, then the parents of the directory
    will be searched until such a file is found or the root of
    the file system is reached. If such a file is found, it will
    be used to resolve package: URIs within the file.
    */
    analysisSetAnalysisRoots(request) {
        return this.sendRequest("analysis.setAnalysisRoots", request);
    }
    /**
    Subscribe for general services (that is, services that are not
    specific to individual files). All previous subscriptions are replaced
    by the given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    analysisSetGeneralSubscriptions(request) {
        return this.sendRequest("analysis.setGeneralSubscriptions", request);
    }
    /**
    Set the priority files to the files in the given list. A
    priority file is a file that is given priority when
    scheduling which analysis work to do first. The list
    typically contains those files that are visible to the user
    and those for which analysis results will have the biggest
    impact on the user experience. The order of the files within
    the list is significant: the first file will be given higher
    priority than the second, the second higher priority than
    the third, and so on.
    Note that this request determines the set of requested
    priority files. The actual set of priority files is the
    intersection of the requested set of priority files with the
    set of files currently subject to analysis. (See
    analysis.setSubscriptions for a description of files that
    are subject to analysis.)
    If a requested priority file is a directory it is ignored,
    but remains in the set of requested priority files so that
    if it later becomes a file it can be included in the set of
    actual priority files.
    */
    analysisSetPriorityFiles(request) {
        return this.sendRequest("analysis.setPriorityFiles", request);
    }
    /**
    Subscribe for services that are specific to individual files.
    All previous subscriptions are replaced by the current set of
    subscriptions. If a given service is not included as a key in the map
    then no files will be subscribed to the service, exactly as if the
    service had been included in the map with an explicit empty list of
    files.
    Note that this request determines the set of requested
    subscriptions. The actual set of subscriptions at any given
    time is the intersection of this set with the set of files
    currently subject to analysis. The files currently subject
    to analysis are the set of files contained within an actual
    analysis root but not excluded, plus all of the files
    transitively reachable from those files via import, export
    and part directives. (See analysis.setAnalysisRoots for an
    explanation of how the actual analysis roots are
    determined.) When the actual analysis roots change, the
    actual set of subscriptions is automatically updated, but
    the set of requested subscriptions is unchanged.
    If a requested subscription is a directory it is ignored,
    but remains in the set of requested subscriptions so that if
    it later becomes a file it can be included in the set of
    actual subscriptions.
    It is an error if any of the keys in the map are not valid
    services. If there is an error, then the existing
    subscriptions will remain unchanged.
    */
    analysisSetSubscriptions(request) {
        return this.sendRequest("analysis.setSubscriptions", request);
    }
    /**
    Update the content of one or more files. Files that were
    previously updated but not included in this update remain
    unchanged. This effectively represents an overlay of the
    filesystem. The files whose content is overridden are
    therefore seen by server as being files with the given
    content, even if the files do not exist on the filesystem or
    if the file path represents the path to a directory on the
    filesystem.
    */
    analysisUpdateContent(request) {
        return this.sendRequest("analysis.updateContent", request);
    }
    /**
    Deprecated: all of the options can be set by users in
    an analysis options file.
    Update the options controlling analysis based on the given
    set of options. Any options that are not included in the
    analysis options will not be changed. If there are options
    in the analysis options that are not valid, they will be
    silently ignored.
    */
    analysisUpdateOptions(request) {
        return this.sendRequest("analysis.updateOptions", request);
    }
    /**
    Request that completion suggestions for the given offset in
    the given file be returned.
    */
    completionGetSuggestions(request) {
        return this.sendRequest("completion.getSuggestions", request);
    }
    /**
    Subscribe for completion services. All previous subscriptions are
    replaced by the given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    completionSetSubscriptions(request) {
        return this.sendRequest("completion.setSubscriptions", request);
    }
    /**
    The client can make this request to express interest in certain
    libraries to receive completion suggestions from based on the client path.
    If this request is received before the client has used
    'completion.setSubscriptions' to subscribe to the AVAILABLE_SUGGESTION_SETS
    service, then an error of type NOT_SUBSCRIBED_TO_AVAILABLE_SUGGESTION_SETS
    will be generated. All previous paths are replaced by the given set of paths.
    */
    completionRegisterLibraryPaths(request) {
        return this.sendRequest("completion.registerLibraryPaths", request);
    }
    /**
    Clients must make this request when the user has selected a completion
    suggestion from an AvailableSuggestionSet. Analysis server will respond with
    the text to insert as well as any SourceChange that needs to be applied
    in case the completion requires an additional import to be added. It is an error
    if the id is no longer valid, for instance if the library has been removed after
    the completion suggestion is accepted.
    */
    completionGetSuggestionDetails(request) {
        return this.sendRequest("completion.getSuggestionDetails", request);
    }
    /**
    Inspect analysis server's knowledge about all of a file's tokens including
    their lexeme, type, and what element kinds would have been appropriate for
    the token's program location.
    */
    completionListTokenDetails(request) {
        return this.sendRequest("completion.listTokenDetails", request);
    }
    /**
    Perform a search for references to the element defined or
    referenced at the given offset in the given file.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindElementReferences(request) {
        return this.sendRequest("search.findElementReferences", request);
    }
    /**
    Perform a search for declarations of members whose name is
    equal to the given name.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindMemberDeclarations(request) {
        return this.sendRequest("search.findMemberDeclarations", request);
    }
    /**
    Perform a search for references to members whose name is
    equal to the given name. This search does not check to see
    that there is a member defined with the given name, so it is
    able to find references to undefined members as well.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindMemberReferences(request) {
        return this.sendRequest("search.findMemberReferences", request);
    }
    /**
    Perform a search for declarations of top-level elements
    (classes, typedefs, getters, setters, functions and fields)
    whose name matches the given pattern.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindTopLevelDeclarations(request) {
        return this.sendRequest("search.findTopLevelDeclarations", request);
    }
    /**
    Return top-level and class member declarations.
    */
    searchGetElementDeclarations(request) {
        return this.sendRequest("search.getElementDeclarations", request);
    }
    /**
    Return the type hierarchy of the class declared or
    referenced at the given location.
    */
    searchGetTypeHierarchy(request) {
        return this.sendRequest("search.getTypeHierarchy", request);
    }
    /**
    Format the contents of a single file. The currently selected region of
    text is passed in so that the selection can be preserved across the
    formatting operation. The updated selection will be as close to
    matching the original as possible, but whitespace at the beginning or
    end of the selected region will be ignored. If preserving selection
    information is not required, zero (0) can be specified for both the
    selection offset and selection length.
    If a request is made for a file which does not exist, or which is not
    currently subject to analysis (e.g. because it is not associated with
    any analysis root specified to analysis.setAnalysisRoots), an error of
    type FORMAT_INVALID_FILE will be generated. If the source
    contains syntax errors, an error of type FORMAT_WITH_ERRORS
    will be generated.
    */
    editFormat(request) {
        return this.sendRequest("edit.format", request);
    }
    /**
    Return the set of assists that are available at the given
    location. An assist is distinguished from a refactoring
    primarily by the fact that it affects a single file and does
    not require user input in order to be performed.
    */
    editGetAssists(request) {
        return this.sendRequest("edit.getAssists", request);
    }
    /**
    Get a list of the kinds of refactorings that are valid for
    the given selection in the given file.
    */
    editGetAvailableRefactorings(request) {
        return this.sendRequest("edit.getAvailableRefactorings", request);
    }
    /**
    Request information about edit.dartfix
    such as the list of known fixes that can be specified
    in an edit.dartfix request.
    */
    editGetDartfixInfo() {
        return this.sendRequest("edit.getDartfixInfo");
    }
    /**
    Analyze the specified sources for recommended changes
    and return a set of suggested edits for those sources.
    These edits may include changes to sources outside the set
    of specified sources if a change in a specified source requires it.
    If includedFixes is specified, then those fixes will be applied.
    If includeRequiredFixes is specified, then "required" fixes will be applied
    in addition to whatever fixes are specified in includedFixes if any.
    If neither includedFixes nor includeRequiredFixes is specified,
    then all fixes will be applied.
    If excludedFixes is specified, then those fixes will not be applied
    regardless of whether they are "required" or specified in includedFixes.
    */
    editDartfix(request) {
        return this.sendRequest("edit.dartfix", request);
    }
    /**
    Return the set of fixes that are available for the errors at
    a given offset in a given file.
    */
    editGetFixes(request) {
        return this.sendRequest("edit.getFixes", request);
    }
    /**
    Get the changes required to convert the postfix template at the given
    location into the template's expanded form.
    */
    editGetPostfixCompletion(request) {
        return this.sendRequest("edit.getPostfixCompletion", request);
    }
    /**
    Get the changes required to perform a refactoring.
    If another refactoring request is received during the processing
    of this one, an error of type REFACTORING_REQUEST_CANCELLED
    will be generated.
    */
    editGetRefactoring(request) {
        return this.sendRequest("edit.getRefactoring", request);
    }
    /**
    Get the changes required to convert the partial statement at the given
    location into a syntactically valid statement. If the current statement
    is already valid the change will insert a newline plus appropriate
    indentation at the end of the line containing the offset.
    If a change that makes the statement valid cannot be determined (perhaps
    because it has not yet been implemented) the statement will be considered
    already valid and the appropriate change returned.
    */
    editGetStatementCompletion(request) {
        return this.sendRequest("edit.getStatementCompletion", request);
    }
    /**
    Determine if the request postfix completion template is applicable at
    the given location in the given file.
    */
    editIsPostfixCompletionApplicable(request) {
        return this.sendRequest("edit.isPostfixCompletionApplicable", request);
    }
    /**
    Return a list of all postfix templates currently available.
    */
    editListPostfixCompletionTemplates() {
        return this.sendRequest("edit.listPostfixCompletionTemplates");
    }
    /**
    Return a list of edits that would need to be applied in order to ensure
    that all of the elements in the specified list of imported elements are
    accessible within the library.
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified via analysis.setAnalysisRoots), an error of type
    IMPORT_ELEMENTS_INVALID_FILE will be generated.
    */
    editImportElements(request) {
        return this.sendRequest("edit.importElements", request);
    }
    /**
    Sort all of the directives, unit and class members
    of the given Dart file.
    If a request is made for a file that does not exist, does not belong
    to an analysis root or is not a Dart file,
    SORT_MEMBERS_INVALID_FILE will be generated.
    If the Dart file has scan or parse errors,
    SORT_MEMBERS_PARSE_ERRORS will be generated.
    */
    editSortMembers(request) {
        return this.sendRequest("edit.sortMembers", request);
    }
    /**
    Organizes all of the directives - removes unused imports and sorts
    directives of the given Dart file according to the
    Dart Style
    Guide.
    If a request is made for a file that does not exist, does not belong
    to an analysis root or is not a Dart file,
    FILE_NOT_ANALYZED will be generated.
    If directives of the Dart file cannot be organized, for example
    because it has scan or parse errors, or by other reasons,
    ORGANIZE_DIRECTIVES_ERROR will be generated. The message
    will provide details about the reason.
    */
    editOrganizeDirectives(request) {
        return this.sendRequest("edit.organizeDirectives", request);
    }
    /**
    Create an execution context for the executable file with the given
    path. The context that is created will persist until
    execution.deleteContext is used to delete it. Clients, therefore, are
    responsible for managing the lifetime of execution contexts.
    */
    executionCreateContext(request) {
        return this.sendRequest("execution.createContext", request);
    }
    /**
    Delete the execution context with the given identifier. The context id
    is no longer valid after this command. The server is allowed to re-use
    ids when they are no longer valid.
    */
    executionDeleteContext(request) {
        return this.sendRequest("execution.deleteContext", request);
    }
    /**
    Request completion suggestions for the given runtime context.
    It might take one or two requests of this type to get completion
    suggestions. The first request should have only "code", "offset",
    and "variables", but not "expressions". If there are sub-expressions that
    can have different runtime types, and are considered to be safe to
    evaluate at runtime (e.g. getters), so using their actual runtime types
    can improve completion results, the server will not include the
    "suggestions" field in the response, and instead will return the
    "expressions" field. The client will use debug API to get current runtime
    types for these sub-expressions and send another request, this time with
    "expressions". If there are no interesting sub-expressions to get
    runtime types for, or when the "expressions" field is provided by the
    client, the server will return "suggestions" in the response.
    */
    executionGetSuggestions(request) {
        return this.sendRequest("execution.getSuggestions", request);
    }
    /**
    Map a URI from the execution context to the file that it corresponds
    to, or map a file to the URI that it corresponds to in the execution
    context.
    Exactly one of the file and uri fields must be provided. If both
    fields are provided, then an error of type INVALID_PARAMETER
    will be generated. Similarly, if neither field is provided, then an
    error of type INVALID_PARAMETER will be generated.
    If the file field is provided and the value is not the path of a file
    (either the file does not exist or the path references something other
    than a file), then an error of type INVALID_PARAMETER will
    be generated.
    If the uri field is provided and the value is not a valid URI or if
    the URI references something that is not a file (either a file that
    does not exist or something other than a file), then an error of type
    INVALID_PARAMETER will be generated.
    If the contextRoot used to create the execution context does not
    exist, then an error of type INVALID_EXECUTION_CONTEXT will
    be generated.
    */
    executionMapUri(request) {
        return this.sendRequest("execution.mapUri", request);
    }
    /**
    Deprecated: the analysis server no longer fires
    LAUNCH_DATA events.
    Subscribe for services. All previous subscriptions are replaced by the
    given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    executionSetSubscriptions(request) {
        return this.sendRequest("execution.setSubscriptions", request);
    }
    /**
    Return server diagnostics.
    */
    diagnosticGetDiagnostics() {
        return this.sendRequest("diagnostic.getDiagnostics");
    }
    /**
    Return the port of the diagnostic web server. If the server is not running
    this call will start the server. If unable to start the diagnostic web
    server,
    this call will return an error of DEBUG_PORT_COULD_NOT_BE_OPENED.
    */
    diagnosticGetServerPort() {
        return this.sendRequest("diagnostic.getServerPort");
    }
    /**
    Query whether analytics is enabled.
    This flag controls whether the analysis server sends any analytics data to
    the cloud. If disabled, the analysis server does not send any analytics
    data, and any data sent to it by clients (from sendEvent and
    sendTiming) will be ignored.
    The value of this flag can be changed by other tools outside of the
    analysis server's process. When you query the flag, you get the value of
    the flag at a given moment. Clients should not use the value returned to
    decide whether or not to send the sendEvent and
    sendTiming requests. Those requests should be used
    unconditionally and server will determine whether or not it is appropriate
    to forward the information to the cloud at the time each request is
    received.
    */
    analyticsIsEnabled() {
        return this.sendRequest("analytics.isEnabled");
    }
    /**
    Enable or disable the sending of analytics data. Note that there are other
    ways for users to change this setting, so clients cannot assume that they
    have complete control over this setting. In particular, there is no
    guarantee that the result returned by the isEnabled request will
    match the last value set via this request.
    */
    analyticsEnable(request) {
        return this.sendRequest("analytics.enable", request);
    }
    /**
    Send information about client events.
    Ask the analysis server to include the fact that an action was performed
    in the client as part of the analytics data being sent. The data will only
    be included if the sending of analytics data is enabled at the time the
    request is processed. The action that was performed is indicated by the
    value of the action field.
    The value of the action field should not include the identity of the
    client. The analytics data sent by server will include the client id
    passed in using the --client-id command-line argument. The
    request will be ignored if the client id was not provided when server was
    started.
    */
    analyticsSendEvent(request) {
        return this.sendRequest("analytics.sendEvent", request);
    }
    /**
    Send timing information for client events (e.g. code completions).
    Ask the analysis server to include the fact that a timed event occurred as
    part of the analytics data being sent. The data will only be included if
    the sending of analytics data is enabled at the time the request is
    processed.
    The value of the event field should not include the identity of the
    client. The analytics data sent by server will include the client id
    passed in using the --client-id command-line argument. The
    request will be ignored if the client id was not provided when server was
    started.
    */
    analyticsSendTiming(request) {
        return this.sendRequest("analytics.sendTiming", request);
    }
    /**
    Return the list of KytheEntry objects for some file, given the
    current state of the file system populated by "analysis.updateContent".
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified to analysis.setAnalysisRoots), an error of type
    GET_KYTHE_ENTRIES_INVALID_FILE will be generated.
    */
    kytheGetKytheEntries(request) {
        return this.sendRequest("kythe.getKytheEntries", request);
    }
    /**
    Subscribe for services that are specific to individual files.
    All previous subscriptions are replaced by the current set of
    subscriptions. If a given service is not included as a key in the map
    then no files will be subscribed to the service, exactly as if the
    service had been included in the map with an explicit empty list of
    files.
    Note that this request determines the set of requested
    subscriptions. The actual set of subscriptions at any given
    time is the intersection of this set with the set of files
    currently subject to analysis. The files currently subject
    to analysis are the set of files contained within an actual
    analysis root but not excluded, plus all of the files
    transitively reachable from those files via import, export
    and part directives. (See analysis.setAnalysisRoots for an
    explanation of how the actual analysis roots are
    determined.) When the actual analysis roots change, the
    actual set of subscriptions is automatically updated, but
    the set of requested subscriptions is unchanged.
    If a requested subscription is a directory it is ignored,
    but remains in the set of requested subscriptions so that if
    it later becomes a file it can be included in the set of
    actual subscriptions.
    It is an error if any of the keys in the map are not valid
    services. If there is an error, then the existing
    subscriptions will remain unchanged.
    */
    flutterSetSubscriptions(request) {
        return this.sendRequest("flutter.setSubscriptions", request);
    }
}
exports.AnalyzerGen = AnalyzerGen;


/***/ }),

/***/ 9165:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspAnalyzer = void 0;
const path = __webpack_require__(1017);
const stream = __webpack_require__(2781);
const vscode_1 = __webpack_require__(9496);
const node_1 = __webpack_require__(2847);
const custom_protocol_1 = __webpack_require__(556);
const analyzer_1 = __webpack_require__(458);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const extension_utils_1 = __webpack_require__(6143);
const config_1 = __webpack_require__(4165);
const extension_1 = __webpack_require__(1892);
const ignore_lint_code_action_provider_1 = __webpack_require__(2862);
const misc_1 = __webpack_require__(9106);
const processes_1 = __webpack_require__(5430);
const analyzer_2 = __webpack_require__(4256);
const analyzer_lsp_snippet_text_edits_1 = __webpack_require__(9925);
const file_tracker_lsp_1 = __webpack_require__(4002);
class LspAnalyzer extends analyzer_1.Analyzer {
    constructor(logger, sdks, dartCapabilities, wsContext) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.Analyzer));
        this.onDocumentColorsRequestedCompleter = new utils_1.PromiseCompleter();
        this.onDocumentColorsRequested = this.onDocumentColorsRequestedCompleter.promise;
        this.snippetTextEdits = new analyzer_lsp_snippet_text_edits_1.SnippetTextEditFeature(dartCapabilities);
        this.client = createClient(this.logger, sdks, dartCapabilities, wsContext, this.buildMiddleware());
        this.fileTracker = new file_tracker_lsp_1.LspFileTracker(logger, this.client, wsContext);
        this.client.registerFeature(this.snippetTextEdits.feature);
        this.disposables.push(this.client.start());
        this.disposables.push(this.fileTracker);
        this.disposables.push(this.snippetTextEdits);
        // tslint:disable-next-line: no-floating-promises
        this.client.onReady().then(() => {
            // Reminder: These onNotification calls only hold ONE handler!
            // https://github.com/microsoft/vscode-languageserver-node/issues/174
            // TODO: Remove this once Dart/Flutter stable LSP servers are using $/progress.
            this.client.onNotification(custom_protocol_1.AnalyzerStatusNotification.type, (params) => {
                this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: params.isAnalyzing });
            });
            this.onReadyCompleter.resolve();
        });
    }
    buildMiddleware() {
        // Why need this ?
        function isLanguageValuePair(input) {
            return "language" in input && typeof input.language === "string" && "value" in input && typeof input.value === "string";
        }
        function cleanDocString(input) {
            if (input instanceof vscode_1.MarkdownString)
                return new vscode_1.MarkdownString((0, extension_utils_1.cleanDartdoc)(input.value));
            else if (typeof input === "string")
                return (0, extension_utils_1.cleanDartdoc)(input);
            else if (isLanguageValuePair(input))
                return { language: input.language, value: (0, extension_utils_1.cleanDartdoc)(input.value) };
            else
                return input;
        }
        /// Whether or not to trigger completion again when completing on this item. This is used
        /// for convenience, eg. when completing the "import '';" snippet people expect completion
        /// to immediately reopen.
        function shouldTriggerCompletionAgain(item) {
            const label = typeof item.label === "string" ? item.label : item.label.label;
            if (label === "import '';")
                return true;
            // When completing on named args, re-trigger for the value.
            if (label.trimRight().endsWith(":"))
                return true;
            if (item.kind === vscode_1.CompletionItemKind.Folder) {
                const label = typeof item.label === "string" ? item.label : item.label.label;
                return label.endsWith("/");
            }
            return false;
        }
        /// Whether or not to trigger signature help on this item. This is used because if a user doesn't
        /// type the ( manually (but it's inserted as part of the completion) then the parameter hints do
        /// not show up.
        function shouldTriggerSignatureHelp(item) {
            let insertText;
            if (item.insertText) {
                if (typeof item.insertText === "string")
                    insertText = item.insertText;
                else
                    insertText = item.insertText.value;
            }
            else {
                const label = typeof item.label === "string" ? item.label : item.label.label;
                insertText = label;
            }
            if (insertText === null || insertText === void 0 ? void 0 : insertText.includes("(${0"))
                return true;
            return false;
        }
        const snippetTextEdits = this.snippetTextEdits;
        const ignoreActionProvider = new ignore_lint_code_action_provider_1.IgnoreLintCodeActionProvider(extension_1.DART_MODE);
        return {
            handleWorkDoneProgress: (token, params, next) => {
                if (params.kind === "begin")
                    this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: true, suppressProgress: true });
                else if (params.kind === "end")
                    this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: false, suppressProgress: true });
                next(token, params);
            },
            provideCompletionItem: (document, position, context, token, next) => __awaiter(this, void 0, void 0, function* () {
                const results = yield next(document, position, context, token);
                let items;
                if (!results)
                    return results;
                // Handle either a CompletionItem[] or CompletionList.
                if ("isIncomplete" in results) {
                    items = results.items;
                }
                else {
                    items = results;
                }
                const parameterHintsEnabled = !!vscode_1.workspace.getConfiguration("editor").get("parameterHints.enabled");
                for (const item of items) {
                    if (shouldTriggerCompletionAgain(item)) {
                        item.command = {
                            command: "editor.action.triggerSuggest",
                            title: "Suggest",
                        };
                    }
                    else if (parameterHintsEnabled && shouldTriggerSignatureHelp(item)) {
                        item.command = {
                            command: "editor.action.triggerParameterHints",
                            title: "Suggest",
                        };
                    }
                }
                return results;
            }),
            resolveCompletionItem: (item, token, next) => {
                if (item.documentation)
                    item.documentation = cleanDocString(item.documentation);
                return next(item, token);
            },
            provideHover: (document, position, token, next) => __awaiter(this, void 0, void 0, function* () {
                const item = yield next(document, position, token);
                if (item === null || item === void 0 ? void 0 : item.contents)
                    item.contents = item.contents.map((s) => cleanDocString(s));
                return item;
            }),
            provideDocumentColors: (document, token, next) => {
                this.onDocumentColorsRequestedCompleter.resolve();
                return next(document, token);
            },
            provideCodeActions(document, range, context, token, next) {
                return __awaiter(this, void 0, void 0, function* () {
                    const documentVersion = document.version;
                    let res = (yield next(document, range, context, token)) || [];
                    snippetTextEdits.rewriteSnippetTextEditsToCommands(documentVersion, res);
                    const hasExistingIgnoreActions = res.find((r) => r.title.startsWith("Ignore "));
                    if (!hasExistingIgnoreActions) {
                        const ignoreActions = ignoreActionProvider.provideCodeActions(document, range, context, token);
                        if (ignoreActions)
                            res = res.concat(ignoreActions);
                    }
                    return res;
                });
            },
            executeCommand: (command, args, next) => __awaiter(this, void 0, void 0, function* () {
                if (command === "refactor.perform") {
                    const expectedCount = 6;
                    if (args && args.length === expectedCount) {
                        const refactorFailedErrorCode = -32011;
                        const refactorKind = args[0];
                        const optionsIndex = 5;
                        // Intercept EXTRACT_METHOD and EXTRACT_WIDGET to prompt the user for a name, since
                        // LSP doesn't currently allow us to prompt during a code-action invocation.
                        let name;
                        switch (refactorKind) {
                            case "EXTRACT_METHOD":
                                name = yield vscode_1.window.showInputBox({
                                    prompt: "Enter a name for the method",
                                    validateInput: (s) => constants_1.validMethodNameRegex.test(s) ? undefined : "Enter a valid method name",
                                    value: "newMethod",
                                });
                                if (!name)
                                    return;
                                args[optionsIndex] = Object.assign({}, args[optionsIndex], { name });
                                break;
                            case "EXTRACT_WIDGET":
                                name = yield vscode_1.window.showInputBox({
                                    prompt: "Enter a name for the widget",
                                    validateInput: (s) => constants_1.validClassNameRegex.test(s) ? undefined : "Enter a valid widget name",
                                    value: "NewWidget",
                                });
                                if (!name)
                                    return;
                                args[optionsIndex] = Object.assign({}, args[optionsIndex], { name });
                                break;
                        }
                        // The server may return errors for things like invalid names, so
                        // capture the errors and present the error better if it's a refactor
                        // error.
                        try {
                            return yield next(command, args);
                        }
                        catch (e) {
                            if ((e === null || e === void 0 ? void 0 : e.code) === refactorFailedErrorCode) {
                                vscode_1.window.showErrorMessage(e.message);
                                return;
                            }
                            else {
                                throw e;
                            }
                        }
                    }
                }
                return next(command, args);
            }),
        };
    }
    getDiagnosticServerPort() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.sendRequest(custom_protocol_1.DiagnosticServerRequest.type);
        });
    }
    forceReanalyze() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.sendRequest(custom_protocol_1.ReanalyzeRequest.type);
            }
            catch (e) {
                vscode_1.window.showErrorMessage("Reanalyze is not supported by this version of the Dart SDK's LSP server.");
            }
        });
    }
    getSuper(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.sendRequest(custom_protocol_1.SuperRequest.type, params);
        });
    }
    completeStatement(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.sendRequest(custom_protocol_1.CompleteStatementRequest.type, params);
        });
    }
}
exports.LspAnalyzer = LspAnalyzer;
function createClient(logger, sdks, dartCapabilities, wsContext, middleware) {
    const clientOptions = {
        initializationOptions: {
            closingLabels: config_1.config.closingLabels,
            flutterOutline: wsContext.hasAnyFlutterProjects,
            onlyAnalyzeProjectsWithOpenFiles: config_1.config.onlyAnalyzeProjectsWithOpenFiles,
            outline: true,
            suggestFromUnimportedLibraries: config_1.config.autoImportCompletions,
        },
        middleware,
        outputChannelName: "LSP",
        uriConverters: {
            code2Protocol: (uri) => vscode_1.Uri.file((0, fs_1.fsPath)(uri, { useRealCasing: !!config_1.config.normalizeFileCasing })).toString(),
            protocol2Code: (file) => vscode_1.Uri.parse(file),
        },
    };
    const client = new node_1.LanguageClient("dartAnalysisLSP", "Dart Analysis Server", () => spawnServer(logger, sdks, dartCapabilities), clientOptions);
    return client;
}
function spawnServer(logger, sdks, dartCapabilities) {
    // TODO: Replace with constructing an Analyzer that passes LSP flag (but still reads config
    // from paths etc) and provide it's process.
    const vmPath = path.join(sdks.dart, constants_1.dartVMPath);
    const args = (0, analyzer_2.getAnalyzerArgs)(logger, sdks, dartCapabilities, true);
    logger.info(`Spawning ${vmPath} with args ${JSON.stringify(args)}`);
    const process = (0, processes_1.safeToolSpawn)(undefined, vmPath, args);
    logger.info(`    PID: ${process.pid}`);
    const reader = process.stdout.pipe(new LoggingTransform(logger, "<=="));
    const writer = new LoggingTransform(logger, "==>");
    writer.pipe(process.stdin);
    process.stderr.on("data", (data) => logger.error(data.toString()));
    process.on("exit", (code, signal) => {
        if (code)
            (0, misc_1.reportAnalyzerTerminatedWithError)();
    });
    return Promise.resolve({ reader, writer });
}
class LoggingTransform extends stream.Transform {
    constructor(logger, prefix, opts) {
        super(opts);
        this.logger = logger;
        this.prefix = prefix;
    }
    _transform(chunk, encoding, callback) {
        this.logger.info(`${this.prefix} ${chunk}`);
        this.push(chunk, encoding);
        callback();
    }
}


/***/ }),

/***/ 9925:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnippetTextEditFeature = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const config_1 = __webpack_require__(4165);
class SnippetTextEditFeature {
    constructor(dartCapabilities) {
        this.dartCapabilities = dartCapabilities;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("_dart.applySnippetTextEdit", this.applySnippetTextEdit, this));
    }
    get feature() {
        const supportsSnippetTextEdits = this.dartCapabilities.supportsSnippetTextEdits;
        const snippetTextEditsEnabled = config_1.config.lspSnippetTextEdits;
        return {
            dispose() { },
            fillClientCapabilities(capabilities) {
                var _a;
                capabilities.experimental = (_a = capabilities.experimental) !== null && _a !== void 0 ? _a : {};
                if (supportsSnippetTextEdits && snippetTextEditsEnabled) {
                    capabilities.experimental.snippetTextEdit = true;
                }
            },
            initialize() { },
        };
    }
    rewriteSnippetTextEditsToCommands(documentVersion, res) {
        if (!res)
            return;
        for (const action of res) {
            if ("edit" in action) {
                const edit = action.edit;
                if (edit) {
                    const entries = edit.entries();
                    if (entries.length === 1 && entries[0][1].length === 1) {
                        const uri = entries[0][0];
                        const textEdit = entries[0][1][0];
                        // HACK: This should be checking InsertTextFormat:
                        // https://github.com/microsoft/language-server-protocol/issues/724#issuecomment-800334721
                        const hasSnippet = /\$(0|\{0:([^}]*)\})/.test(textEdit.newText);
                        // if ((textEdit as any).insertTextFormat === InsertTextFormat.Snippet) {
                        if (hasSnippet) {
                            action.edit = undefined;
                            action.command = {
                                arguments: [documentVersion, uri, textEdit],
                                command: "_dart.applySnippetTextEdit",
                                title: "Apply edit",
                            };
                        }
                    }
                }
            }
        }
    }
    applySnippetTextEdit(documentVersion, uri, edit) {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield vs.workspace.openTextDocument(uri);
            const editor = yield vs.window.showTextDocument(doc);
            if (doc.version !== documentVersion)
                vs.window.showErrorMessage(`Unable to apply snippet, document was modified`);
            const leadingIndentCharacters = doc.lineAt(edit.range.start.line).firstNonWhitespaceCharacterIndex;
            const newText = this.compensateForVsCodeIndenting(edit.newText, leadingIndentCharacters);
            const snippet = new vs.SnippetString(newText);
            yield editor.insertSnippet(snippet, edit.range);
        });
    }
    compensateForVsCodeIndenting(newText, leadingIndentCharacters) {
        const indent = " ".repeat(leadingIndentCharacters);
        const indentPattern = new RegExp(`\n${indent}`, "g");
        return newText.replace(indentPattern, "\n");
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.SnippetTextEditFeature = SnippetTextEditFeature;


/***/ }),

/***/ 2975:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyzerStatusReporter = void 0;
const vscode_1 = __webpack_require__(9496);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(4586);
const extension_utils_1 = __webpack_require__(6143);
const config_1 = __webpack_require__(4165);
const utils_2 = __webpack_require__(8779);
const maxErrorReportCount = 3;
const sendFakeErrorAtStartup = false;
let errorCount = 0;
class AnalyzerStatusReporter {
    constructor(logger, analyzer, workspaceContext, analytics) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.workspaceContext = workspaceContext;
        this.analytics = analytics;
        this.analysisInProgress = false;
        // TODO: Should these go in disposables?
        // If so, do we need to worry about server cleaning them up if it disposes first?
        analyzer.registerForServerStatus((n) => this.handleServerStatus(n));
        analyzer.registerForServerError((e) => this.handleServerError(e));
        analyzer.registerForRequestError((e) => this.handleRequestError(e));
        analyzer.registerForServerTerminated(() => this.handleServerTerminated());
        if (sendFakeErrorAtStartup) {
            setTimeout(() => {
                this.handleServerError({
                    isFatal: false,
                    message: "This is a fake error for testing the error reporting!",
                    stackTrace: new Error().stack || "",
                }, "testError");
            }, 5000);
        }
    }
    handleServerStatus(status) {
        if (!status.analysis)
            return;
        this.analysisInProgress = status.analysis.isAnalyzing;
        if (this.analysisInProgress) {
            // Debounce short analysis times.
            setTimeout(() => {
                // When the timeout fires, we need to check analysisInProgress again in case
                // analysis has already finished.
                if (this.analysisInProgress && !this.analyzingPromise) {
                    vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, title: "Analyzing" }, () => {
                        if (!this.analyzingPromise) // Re-check, since we don't know how long before this callback is called.
                            this.analyzingPromise = new utils_1.PromiseCompleter();
                        return this.analyzingPromise.promise;
                    });
                }
            }, 500);
        }
        else {
            if (this.analyzingPromise) {
                this.analyzingPromise.resolve();
                this.analyzingPromise = undefined;
            }
        }
    }
    handleServerTerminated() {
        this.analysisInProgress = false;
        if (this.analyzingPromise) {
            this.analyzingPromise.resolve();
            this.analyzingPromise = undefined;
        }
    }
    handleRequestError(error) {
        // Map this request error to a server error to reuse the shared code.
        this.handleServerError({
            isFatal: false,
            message: error.message,
            stackTrace: error.stackTrace || "",
        }, error.method);
    }
    handleServerError(error, method) {
        // Always log to the console.
        this.logger.error(error.message, enums_1.LogCategory.Analyzer);
        if (error.stackTrace)
            this.logger.error(error.stackTrace, enums_1.LogCategory.Analyzer);
        this.analytics.logError(`Analyzer server error${method ? ` (${method})` : ""}`, error.isFatal);
        errorCount++;
        // Offer to report the error.
        if (config_1.config.notifyAnalyzerErrors && errorCount <= maxErrorReportCount) {
            const showLog = "Show log";
            vscode_1.window.showErrorMessage(`Exception from the Dart analysis server: ${error.message}`, showLog).then((res) => {
                if (res === showLog)
                    this.showErrorLog(error, method);
            });
        }
    }
    showErrorLog(error, method) {
        const sdkVersion = this.workspaceContext.sdks.dartVersion;
        const flutterSdkVersion = this.workspaceContext.sdks.flutterVersion;
        const analyzerArgs = this.analyzer.getAnalyzerLaunchArgs();
        const data = `
${method ? "### Request\n\nServer was responding to request: `" + method + "`\n" : ""}
### Versions

- ${vscode_1.env.appName} v${vscode_1.version}
- Dart Code v${extension_utils_1.extensionVersion}
- ${flutterSdkVersion ? `Flutter SDK v${flutterSdkVersion}` : `Dart SDK v${sdkVersion}`}

### Analyzer Info

The analyzer was launched using the arguments:

${analyzerArgs.map((a) => `- ${a}`).join("\n")}

### Exception${error.isFatal ? " (fatal)" : ""}

${error.message}

${error.stackTrace.trim()}
`;
        (0, utils_2.openLogContents)("md", data);
    }
}
exports.AnalyzerStatusReporter = AnalyzerStatusReporter;


/***/ }),

/***/ 7246:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileChangeHandler = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const util = __webpack_require__(8779);
class FileChangeHandler {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables = [];
        this.filesWarnedAbout = new Set();
        this.disposables.push(vs.workspace.onDidOpenTextDocument((td) => this.onDidOpenTextDocument(td)), vs.workspace.onDidChangeTextDocument((e) => this.onDidChangeTextDocument(e)), vs.workspace.onDidCloseTextDocument((td) => this.onDidCloseTextDocument(td)));
        // Handle already-open files.
        vs.workspace.textDocuments.forEach((td) => this.onDidOpenTextDocument(td));
    }
    onDidOpenTextDocument(document) {
        if (!util.isAnalyzable(document))
            return;
        const files = {};
        files[(0, fs_1.fsPath)(document.uri)] = {
            content: document.getText(),
            type: "add",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analyzer.analysisUpdateContent({ files });
    }
    onDidChangeTextDocument(e) {
        if (!util.isAnalyzable(e.document))
            return;
        if (e.contentChanges.length === 0) // This event fires for metadata changes (dirty?) so don't need to notify AS then.
            return;
        const files = {};
        files[(0, fs_1.fsPath)(e.document.uri)] = {
            edits: e.contentChanges.map((c) => this.convertChange(e.document, c)),
            type: "change",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analyzer.analysisUpdateContent({ files });
    }
    onDidCloseTextDocument(document) {
        if (!util.isAnalyzable(document))
            return;
        const files = {};
        files[(0, fs_1.fsPath)(document.uri)] = {
            type: "remove",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analyzer.analysisUpdateContent({ files });
    }
    convertChange(document, change) {
        return {
            id: "",
            length: change.rangeLength,
            offset: change.rangeOffset,
            replacement: change.text,
        };
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FileChangeHandler = FileChangeHandler;


/***/ }),

/***/ 4775:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileChangeWarnings = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const util = __webpack_require__(8779);
class FileChangeWarnings {
    constructor() {
        this.disposables = [];
        this.filesWarnedAbout = new Set();
        this.disposables.push(vs.workspace.onDidChangeTextDocument((e) => this.onDidChangeTextDocument(e)));
    }
    onDidChangeTextDocument(e) {
        if (!util.isAnalyzable(e.document))
            return;
        if (e.contentChanges.length === 0) // This event fires for metadata changes (dirty?) so don't need to notify AS then.
            return;
        const filePath = (0, fs_1.fsPath)(e.document.uri);
        if (vs.workspace.workspaceFolders
            && vs.workspace.workspaceFolders.length // Only prompt if we actually have workspace folders open
            && !util.isWithinWorkspace(filePath)
            && !this.filesWarnedAbout.has(filePath)) {
            const isInPubCache = filePath.indexOf(`${path.sep}hosted${path.sep}pub.dartlang.org${path.sep}`) !== -1;
            const shouldWarn = isInPubCache
                ? config_1.config.warnWhenEditingFilesInPubCache
                : config_1.config.warnWhenEditingFilesOutsideWorkspace;
            const promptText = isInPubCache
                ? "You are modifying a file in the Pub cache!"
                : "You are modifying a file outside of your open folders";
            const dontShowAgainSetter = isInPubCache
                ? () => config_1.config.setWarnWhenEditingFilesInPubCache(false)
                : () => config_1.config.setWarnWhenEditingFilesOutsideWorkspace(false);
            const dontShowAgainAction = "Don't Warn Me";
            if (shouldWarn) {
                vs.window.showWarningMessage(promptText, constants_1.moreInfoAction, dontShowAgainAction)
                    .then((action) => __awaiter(this, void 0, void 0, function* () {
                    if (action === constants_1.moreInfoAction) {
                        yield utils_2.envUtils.openInBrowser(constants_1.modifyingFilesOutsideWorkspaceInfoUrl);
                    }
                    else if (action === dontShowAgainAction)
                        dontShowAgainSetter();
                }));
                this.filesWarnedAbout.add(filePath);
            }
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FileChangeWarnings = FileChangeWarnings;


/***/ }),

/***/ 9016:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DasFileTracker = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(4411);
const project_1 = __webpack_require__(3886);
const util = __webpack_require__(8779);
class DasFileTracker {
    constructor(logger, analyzer, wsContext) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.wsContext = wsContext;
        this.disposables = [];
        this.navigations = {};
        this.outlines = {};
        this.flutterOutlines = {};
        this.occurrences = {};
        this.folding = {};
        this.pubRunTestSupport = {};
        this.lastPriorityFiles = [];
        this.lastSubscribedFiles = [];
        // Reset these, since they're state from the last analysis server
        // (when we change SDK and thus change this).
        this.lastPriorityFiles = [];
        this.lastSubscribedFiles = [];
        this.disposables.push(vscode_1.workspace.onDidOpenTextDocument((td) => __awaiter(this, void 0, void 0, function* () {
            yield this.updateSubscriptions();
        })));
        this.disposables.push(vscode_1.workspace.onDidCloseTextDocument((td) => __awaiter(this, void 0, void 0, function* () {
            const path = (0, fs_1.fsPath)(td.uri);
            delete this.navigations[path];
            delete this.outlines[path];
            delete this.flutterOutlines[path];
            delete this.occurrences[path];
            delete this.folding[path];
            delete this.pubRunTestSupport[path];
            yield this.updateSubscriptions();
        })));
        this.disposables.push(vscode_1.window.onDidChangeVisibleTextEditors((e) => this.updatePriorityFiles()));
        this.disposables.push(this.analyzer.registerForAnalysisNavigation((n) => this.navigations[n.file] = n));
        this.disposables.push(this.analyzer.registerForAnalysisOutline((o) => this.outlines[o.file] = o.outline));
        this.disposables.push(this.analyzer.registerForFlutterOutline((o) => this.flutterOutlines[o.file] = o.outline));
        this.disposables.push(this.analyzer.registerForAnalysisOccurrences((o) => this.occurrences[o.file] = o.occurrences));
        this.disposables.push(this.analyzer.registerForAnalysisFolding((f) => this.folding[f.file] = f.regions));
        // It's possible that after the server gives us the version, we may send different subscriptions (eg.
        // based on capabilities, like supporting priority files outside of the workspace root) so we may need
        // to send again.
        this.disposables.push(this.analyzer.registerForServerConnected((s) => this.updateSubscriptions(true)));
        // Handle already-open files.
        // tslint:disable-next-line: no-floating-promises
        this.updatePriorityFiles();
        // tslint:disable-next-line: no-floating-promises
        this.updateSubscriptions();
        this.watchPubspec();
    }
    updatePriorityFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            const visibleFiles = this.validPathsFor(vscode_1.window.visibleTextEditors.map((editor) => editor.document));
            if (!this.pathsHaveChanged(this.lastPriorityFiles, visibleFiles))
                return;
            // Keep track of files to compare next time.
            this.lastPriorityFiles = visibleFiles;
            // Set priority files.
            try {
                yield this.analyzer.analysisSetPriorityFiles({ files: visibleFiles });
            }
            catch (e) {
                this.logger.error(e);
            }
        });
    }
    updateSubscriptions(force = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const openFiles = this.validPathsFor(vscode_1.workspace.textDocuments);
            if (!force && !this.pathsHaveChanged(this.lastSubscribedFiles, openFiles))
                return;
            // Keep track of files to compare next time.
            this.lastSubscribedFiles = openFiles;
            // Set subscriptions.
            try {
                yield this.analyzer.analysisSetSubscriptions({
                    subscriptions: {
                        CLOSING_LABELS: this.analyzer.capabilities.supportsClosingLabels ? openFiles : undefined,
                        FOLDING: this.wsContext.config.useLsp ? undefined : openFiles,
                        NAVIGATION: this.wsContext.config.useLsp ? undefined : openFiles,
                        OCCURRENCES: this.wsContext.config.useLsp ? undefined : openFiles,
                        OUTLINE: openFiles,
                    },
                });
            }
            catch (e) {
                this.logger.error(e);
            }
            // Set subscriptions.
            if (this.wsContext.hasAnyFlutterProjects && this.analyzer.capabilities.supportsFlutterOutline) {
                try {
                    yield this.analyzer.flutterSetSubscriptions({
                        subscriptions: {
                            OUTLINE: openFiles,
                        },
                    });
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
        });
    }
    pathsHaveChanged(last, current) {
        return last.length !== current.length
            || last.some((f, i) => f !== current[i]);
    }
    validPathsFor(paths) {
        const isAnalyzeable = this.analyzer.capabilities.supportsPriorityFilesOutsideAnalysisRoots
            ? util.isAnalyzable
            : util.isAnalyzableAndInWorkspace;
        return paths
            .filter((doc) => !doc.isClosed && isAnalyzeable(doc))
            .map((doc) => (0, fs_1.fsPath)(doc.uri))
            .sort((path1, path2) => path1.localeCompare(path2));
    }
    getNavigationTargets(file, offset) {
        var _a;
        // Synthesize an AnalysisGetNavigationResponse based on our existing knowledge about navigation links in the file.
        const notification = this.navigations[file];
        const region = (_a = notification === null || notification === void 0 ? void 0 : notification.regions) === null || _a === void 0 ? void 0 : _a.find((region) => this.offsetWithinNavigationRegion(region, offset));
        if (!region)
            return undefined;
        return {
            files: notification.files,
            regions: [region],
            targets: notification.targets,
        };
    }
    offsetWithinNavigationRegion(region, offset) {
        return offset >= region.offset && offset < region.offset + region.length;
    }
    getOutlineFor(file) {
        return this.outlines[(0, fs_1.fsPath)(file)];
    }
    waitForOutlineWithLength(file, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, promises_1.waitFor)(() => {
                const outline = this.outlines[(0, fs_1.fsPath)(file)];
                return (outline === null || outline === void 0 ? void 0 : outline.length) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    getFlutterOutlineFor(file) {
        return this.flutterOutlines[(0, fs_1.fsPath)(file)];
    }
    waitForFlutterOutlineWithLength(file, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, promises_1.waitFor)(() => {
                const outline = this.flutterOutlines[(0, fs_1.fsPath)(file)];
                return (outline === null || outline === void 0 ? void 0 : outline.length) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    getOccurrencesFor(file) {
        return this.occurrences[(0, fs_1.fsPath)(file)];
    }
    supportsPubRunTest(file) {
        // TODO: Both FileTrackers have a copy of this!
        const path = (0, fs_1.fsPath)(file);
        if (!util.isPubRunnableTestFile(path))
            return false;
        if (this.pubRunTestSupport[path] === undefined) {
            const projectRoot = (0, project_1.locateBestProjectRoot)(path);
            this.pubRunTestSupport[path] = !!(projectRoot && util.projectShouldUsePubForTests(projectRoot, this.wsContext.config));
        }
        return this.pubRunTestSupport[(0, fs_1.fsPath)(file)];
    }
    watchPubspec() {
        const clearCachedPubRunTestData = () => Object.keys(this.pubRunTestSupport).forEach((f) => delete this.pubRunTestSupport[f]);
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/pubspec.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(clearCachedPubRunTestData, this);
        watcher.onDidCreate(clearCachedPubRunTestData, this);
    }
    getFoldingRegionsFor(file) {
        return this.folding[(0, fs_1.fsPath)(file)];
    }
    getLastPriorityFiles() {
        return this.lastPriorityFiles.slice();
    }
    getLastSubscribedFiles() {
        return this.lastSubscribedFiles.slice();
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DasFileTracker = DasFileTracker;


/***/ }),

/***/ 4002:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspFileTracker = void 0;
const vscode_1 = __webpack_require__(9496);
const custom_protocol_1 = __webpack_require__(556);
const events_1 = __webpack_require__(3254);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(4411);
const utils_2 = __webpack_require__(7220);
const project_1 = __webpack_require__(3886);
const util = __webpack_require__(8779);
class LspFileTracker {
    constructor(logger, analyzer, wsContext) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.wsContext = wsContext;
        this.disposables = [];
        this.outlines = {};
        this.flutterOutlines = {};
        this.pubRunTestSupport = {};
        this.onOutlineEmitter = new events_1.EventEmitter();
        this.onOutline = this.onOutlineEmitter.event;
        this.onFlutterOutlineEmitter = new events_1.EventEmitter();
        this.onFlutterOutline = this.onFlutterOutlineEmitter.event;
        // tslint:disable-next-line: no-floating-promises
        analyzer.onReady().then(() => {
            this.analyzer.onNotification(custom_protocol_1.PublishOutlineNotification.type, (n) => {
                const filePath = (0, fs_1.fsPath)(vscode_1.Uri.parse(n.uri));
                this.outlines[filePath] = n.outline;
                this.onOutlineEmitter.fire(n);
            });
            this.analyzer.onNotification(custom_protocol_1.PublishFlutterOutlineNotification.type, (n) => {
                const filePath = (0, fs_1.fsPath)(vscode_1.Uri.parse(n.uri));
                this.flutterOutlines[filePath] = n.outline;
                this.onFlutterOutlineEmitter.fire(n);
            });
        });
        this.watchPubspec();
    }
    getOutlineFor(file) {
        return this.outlines[(0, fs_1.fsPath)(file)];
    }
    waitForOutline(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, promises_1.waitFor)(() => this.outlines[(0, fs_1.fsPath)(document.uri)], 50, 5000, token);
        });
    }
    // TODO: Change this to withVersion when server sends versions.
    waitForOutlineWithLength(document, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, promises_1.waitFor)(() => {
                const outline = this.outlines[(0, fs_1.fsPath)(document.uri)];
                return outline && document.offsetAt((0, utils_2.lspToPosition)(outline.range.end)) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    getFlutterOutlineFor(file) {
        return this.flutterOutlines[(0, fs_1.fsPath)(file)];
    }
    // TODO: Change this to withVersion when server sends versions.
    waitForFlutterOutlineWithLength(document, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, promises_1.waitFor)(() => {
                const outline = this.flutterOutlines[(0, fs_1.fsPath)(document.uri)];
                return outline && document.offsetAt((0, utils_2.lspToPosition)(outline.range.end)) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    supportsPubRunTest(file) {
        // TODO: Both FileTrackers have a copy of this!
        const path = (0, fs_1.fsPath)(file);
        if (!util.isPubRunnableTestFile(path))
            return false;
        if (this.pubRunTestSupport[path] === undefined) {
            const projectRoot = (0, project_1.locateBestProjectRoot)(path);
            this.pubRunTestSupport[path] = !!(projectRoot && util.projectShouldUsePubForTests(projectRoot, this.wsContext.config));
        }
        return this.pubRunTestSupport[(0, fs_1.fsPath)(file)];
    }
    watchPubspec() {
        const clearCachedPubRunTestData = () => Object.keys(this.pubRunTestSupport).forEach((f) => delete this.pubRunTestSupport[f]);
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/pubspec.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(clearCachedPubRunTestData, this);
        watcher.onDidCreate(clearCachedPubRunTestData, this);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspFileTracker = LspFileTracker;


/***/ }),

/***/ 3189:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Analytics = void 0;
const https = __webpack_require__(5687);
const querystring = __webpack_require__(3477);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const extension_utils_1 = __webpack_require__(6143);
const config_1 = __webpack_require__(4165);
// Set to true for analytics to be sent to the debug endpoint (non-logging) for validation.
// This is only required for debugging analytics and needn't be sent for standard Dart Code development (dev hits are already filtered with isDevelopment).
const debug = false;
/// Analytics require that we send a value for uid or cid, but when running in the VS Code
// dev host we don't have either.
const sendAnalyticsFromExtensionDevHost = false;
// Machine ID is not set for extension dev host unless the boolean above is set to true (which
// is usually done for testing purposes).
const machineId = vscode_1.env.machineId !== "someValue.machineId"
    ? vscode_1.env.machineId
    : (sendAnalyticsFromExtensionDevHost ? "35009a79-1a05-49d7-dede-dededededede" : undefined);
var Category;
(function (Category) {
    Category[Category["Extension"] = 0] = "Extension";
    Category[Category["Analyzer"] = 1] = "Analyzer";
    Category[Category["Debugger"] = 2] = "Debugger";
})(Category || (Category = {}));
var EventAction;
(function (EventAction) {
    EventAction[EventAction["Activated"] = 0] = "Activated";
    EventAction[EventAction["SdkDetectionFailure"] = 1] = "SdkDetectionFailure";
    EventAction[EventAction["Deactivated"] = 2] = "Deactivated";
    EventAction[EventAction["Restart"] = 3] = "Restart";
    EventAction[EventAction["HotReload"] = 4] = "HotReload";
    EventAction[EventAction["OpenObservatory"] = 5] = "OpenObservatory";
    EventAction[EventAction["OpenTimeline"] = 6] = "OpenTimeline";
    EventAction[EventAction["OpenDevTools"] = 7] = "OpenDevTools";
})(EventAction || (EventAction = {}));
var TimingVariable;
(function (TimingVariable) {
    TimingVariable[TimingVariable["Startup"] = 0] = "Startup";
    TimingVariable[TimingVariable["FirstAnalysis"] = 1] = "FirstAnalysis";
    TimingVariable[TimingVariable["SessionDuration"] = 2] = "SessionDuration";
})(TimingVariable || (TimingVariable = {}));
class Analytics {
    constructor(logger, workspaceContext) {
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.dummyDartFile = vscode_1.Uri.parse("untitled:foo.dart");
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        this.dartConfig = vscode_1.workspace.getConfiguration("", this.dummyDartFile).get("[dart]");
        // If analytics fail, they will be disabled for the rest of the session.
        this.disableAnalyticsForSession = false;
        this.formatter = this.getFormatterSetting();
    }
    getFormatterSetting() {
        try {
            // If there are multiple formatters for Dart, the user can select one, so check
            // that first so we don't record their formatter being enabled as ours.
            const otherDefaultFormatter = this.getAppliedConfig("editor", "defaultFormatter", false);
            if (otherDefaultFormatter && otherDefaultFormatter !== constants_1.dartCodeExtensionIdentifier)
                return otherDefaultFormatter;
            // If the user has explicitly disabled ours (without having another selected
            // then record that).
            if (!config_1.config.enableSdkFormatter)
                return "Disabled";
            // Otherwise record as enabled (and whether on-save).
            return this.getAppliedConfig("editor", "formatOnSave")
                ? "Enabled on Save"
                : "Enabled";
        }
        catch (_a) {
            return "Unknown";
        }
    }
    getAppliedConfig(section, key, isResourceScoped = true) {
        const dartValue = this.dartConfig ? this.dartConfig[`${section}.${key}`] : undefined;
        return dartValue !== undefined && dartValue !== null
            ? dartValue
            : vscode_1.workspace.getConfiguration(section, isResourceScoped ? this.dummyDartFile : undefined).get(key);
    }
    logExtensionStartup(timeInMS) {
        this.event(Category.Extension, EventAction.Activated).catch((e) => this.logger.info(e));
        this.time(Category.Extension, TimingVariable.Startup, timeInMS).catch((e) => this.logger.info(e));
    }
    logExtensionRestart(timeInMS) {
        this.event(Category.Extension, EventAction.Restart).catch((e) => this.logger.info(e));
        this.time(Category.Extension, TimingVariable.Startup, timeInMS).catch((e) => this.logger.info(e));
    }
    logAnalyzerRestart() {
        this.event(Category.Analyzer, EventAction.Restart).catch((e) => this.logger.info(e));
    }
    logExtensionShutdown() { return this.event(Category.Extension, EventAction.Deactivated); }
    logSdkDetectionFailure() { this.event(Category.Extension, EventAction.SdkDetectionFailure).catch((e) => this.logger.info(e)); }
    logError(description, fatal) { this.error(description, fatal).catch((e) => this.logger.info(e)); }
    logAnalyzerStartupTime(timeInMS) { this.time(Category.Analyzer, TimingVariable.Startup, timeInMS).catch((e) => this.logger.info(e)); }
    logDebugSessionDuration(debuggerType, timeInMS) { this.time(Category.Debugger, TimingVariable.SessionDuration, timeInMS, debuggerType).catch((e) => this.logger.info(e)); }
    logAnalyzerFirstAnalysisTime(timeInMS) { this.time(Category.Analyzer, TimingVariable.FirstAnalysis, timeInMS).catch((e) => this.logger.info(e)); }
    logDebuggerStart(resourceUri, debuggerType, runType) {
        const customData = {
            cd15: debuggerType,
            cd16: runType,
        };
        this.event(Category.Debugger, EventAction.Activated, resourceUri, customData).catch((e) => this.logger.info(e));
    }
    logDebuggerRestart() { this.event(Category.Debugger, EventAction.Restart).catch((e) => this.logger.info(e)); }
    logDebuggerHotReload() { this.event(Category.Debugger, EventAction.HotReload).catch((e) => this.logger.info(e)); }
    logDebuggerOpenObservatory() { this.event(Category.Debugger, EventAction.OpenObservatory).catch((e) => this.logger.info(e)); }
    logDebuggerOpenTimeline() { this.event(Category.Debugger, EventAction.OpenTimeline).catch((e) => this.logger.info(e)); }
    logDebuggerOpenDevTools() { this.event(Category.Debugger, EventAction.OpenDevTools).catch((e) => this.logger.info(e)); }
    event(category, action, resourceUri, customData) {
        const data = {
            ea: EventAction[action],
            ec: Category[category],
            t: "event",
        };
        // Copy custom data over.
        Object.assign(data, customData);
        // Force a session start if this is extension activation.
        if (category === Category.Extension && action === EventAction.Activated)
            data.sc = "start";
        // Force a session end if this is extension deactivation.
        if (category === Category.Extension && action === EventAction.Deactivated)
            data.sc = "end";
        return this.send(data, resourceUri);
    }
    time(category, timingVariable, timeInMS, label) {
        const data = {
            t: "timing",
            utc: Category[category],
            utl: label,
            utt: Math.round(timeInMS),
            utv: TimingVariable[timingVariable],
        };
        this.logger.info(`${data.utc}:${data.utv} timing: ${Math.round(timeInMS)}ms ${label ? `(${label})` : ""}`);
        // if (isDevExtension)
        // 	console.log(`${data.utc}:${data.utv} timing: ${Math.round(timeInMS)}ms ${label ? `(${label})` : ""}`);
        return this.send(data);
    }
    error(description, fatal) {
        const data = {
            exd: description.trim(),
            exf: fatal ? 1 : 0,
            t: "exception",
        };
        return this.send(data);
    }
    send(customData, resourceUri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disableAnalyticsForSession || !machineId || !config_1.config.allowAnalytics || process.env.DART_CODE_IS_TEST_RUN)
                return;
            const data = {
                aip: 1,
                an: "Dart Code",
                av: extension_utils_1.extensionVersion,
                cd1: extension_utils_1.isDevExtension,
                cd10: config_1.config.showTodos ? "On" : "Off",
                cd11: this.workspaceContext.config.useLsp ? "LSP" : "DAS",
                cd12: this.formatter,
                cd13: this.flutterSdkVersion,
                cd14: extension_utils_1.hasFlutterExtension ? "Installed" : "Not Installed",
                cd17: this.workspaceContext.hasAnyFlutterProjects
                    ? (config_1.config.previewFlutterUiGuides ? (config_1.config.previewFlutterUiGuidesCustomTracking ? "On + Custom Tracking" : "On") : "Off")
                    : null,
                cd18: this.workspaceContext.hasAnyFlutterProjects && resourceUri
                    ? config_1.config.for(resourceUri).flutterStructuredErrors ? "On" : "Off"
                    : null,
                cd19: vscode_1.env.remoteName || "None",
                cd2: constants_1.isChromeOS ? `${process.platform} (ChromeOS)` : process.platform,
                cd20: vscode_1.env.appName || "Unknown",
                cd3: this.sdkVersion,
                cd4: this.analysisServerVersion,
                cd5: vscode_1.version,
                cd6: resourceUri ? this.getDebuggerPreference() : null,
                cd7: this.workspaceContext.workspaceTypeDescription,
                cd8: config_1.config.closingLabels ? "On" : "Off",
                cd9: this.workspaceContext.hasAnyFlutterProjects ? config_1.config.flutterHotReloadOnSave : null,
                // TODO: Auto-save
                // TODO: Hot-restart-on-save
                cid: machineId,
                tid: "UA-2201586-19",
                ul: vscode_1.env.language,
                v: "1", // API Version.
            };
            // Copy custom data over.
            Object.assign(data, customData);
            if (debug)
                this.logger.info("Sending analytic: " + JSON.stringify(data));
            const options = {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                },
                hostname: "www.google-analytics.com",
                method: "POST",
                path: debug ? "/debug/collect" : "/collect",
                port: 443,
            };
            yield new Promise((resolve) => {
                try {
                    const req = https.request(options, (resp) => {
                        if (debug)
                            resp.on("data", (c) => {
                                try {
                                    const gaDebugResp = JSON.parse(c.toString());
                                    if (gaDebugResp && gaDebugResp.hitParsingResult && gaDebugResp.hitParsingResult[0].valid === true)
                                        this.logger.info("Sent OK!");
                                    else if (gaDebugResp && gaDebugResp.hitParsingResult && gaDebugResp.hitParsingResult[0].valid === false)
                                        this.logger.warn(c.toString());
                                    else
                                        this.logger.warn(`Unexpected GA debug response: ${c === null || c === void 0 ? void 0 : c.toString()}`);
                                }
                                catch (e) {
                                    this.logger.warn(`Error in GA debug response: ${c === null || c === void 0 ? void 0 : c.toString()}`);
                                }
                            });
                        if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                            this.logger.info(`Failed to send analytics ${resp && resp.statusCode}: ${resp && resp.statusMessage}`);
                        }
                        resolve();
                    });
                    req.write(querystring.stringify(data));
                    req.on("error", (e) => {
                        this.handleError(e);
                        resolve();
                    });
                    req.end();
                }
                catch (e) {
                    this.handleError(e);
                    resolve();
                }
            });
        });
    }
    handleError(e) {
        this.logger.error(`Failed to send analytics: ${e}`);
        this.disableAnalyticsForSession = true;
    }
    getDebuggerPreference() {
        if (config_1.config.debugSdkLibraries && config_1.config.debugExternalPackageLibraries)
            return "All code";
        else if (config_1.config.debugSdkLibraries)
            return "My code + SDK";
        else if (config_1.config.debugExternalPackageLibraries)
            return "My code + Libraries";
        else
            return "My code";
    }
}
exports.Analytics = Analytics;


/***/ }),

/***/ 8237:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartExtensionApi = void 0;
const vs = __webpack_require__(9496);
class DartExtensionApi {
    constructor() {
        this.version = 1;
        this.flutterCreateSampleProject = () => vs.commands.executeCommand("_dart.flutter.createSampleProject");
    }
}
exports.DartExtensionApi = DartExtensionApi;


/***/ }),

/***/ 7525:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterDartPadSamplesCodeLensProvider = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const outline_das_1 = __webpack_require__(6074);
const utils_2 = __webpack_require__(7220);
const dartPadSamplePattern = new RegExp("\\{@tool\\s+dartpad");
class FlutterDartPadSamplesCodeLensProvider {
    constructor(logger, analyzer, sdks) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.sdks = sdks;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
        this.disposables.push(vscode_1.commands.registerCommand("_dart.openDartPadSample", (sample) => __awaiter(this, void 0, void 0, function* () {
            // Link down to first code snippet.
            const fragment = `#${sample.libraryName}.${sample.className}.1`;
            const url = `https://api.flutter.dev/flutter/${sample.libraryName}/${sample.className}-class.html${fragment}`;
            yield utils_2.envUtils.openInBrowser(url);
        })));
        this.flutterPackagesFolder = path.join(sdks.flutter, "packages/flutter/lib/src/").toLowerCase();
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure this file is a Flutter package file.
            const filePath = (0, fs_1.fsPath)(document.uri);
            if (!filePath.toLowerCase().startsWith(this.flutterPackagesFolder))
                return;
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const libraryName = filePath.substr(this.flutterPackagesFolder.length).replace("\\", "/").split("/")[0];
            const visitor = new outline_das_1.ClassOutlineVisitor(this.logger);
            visitor.visit(outline);
            // Filter classes to those with DartPad samples.
            const samples = visitor.classes.filter((cl) => {
                // HACK: DartDocs are between the main offset and codeOffset.
                const docs = document.getText((0, utils_2.toRange)(document, cl.offset, cl.codeOffset - cl.offset));
                return dartPadSamplePattern.test(docs);
            }).map((cl) => (Object.assign(Object.assign({}, cl), { libraryName })));
            return samples
                .filter((sample) => sample.codeOffset && sample.codeLength)
                .map((sample) => new vscode_1.CodeLens((0, utils_2.toRange)(document, sample.codeOffset, sample.codeLength), {
                arguments: [sample],
                command: "_dart.openDartPadSample",
                title: `Open online interactive samples for ${sample.className}`,
            }));
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FlutterDartPadSamplesCodeLensProvider = FlutterDartPadSamplesCodeLensProvider;


/***/ }),

/***/ 6212:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspFlutterDartPadSamplesCodeLensProvider = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const outline_lsp_1 = __webpack_require__(4215);
const utils_2 = __webpack_require__(7220);
const dartPadSamplePattern = new RegExp("\\{@tool\\s+dartpad");
class LspFlutterDartPadSamplesCodeLensProvider {
    constructor(logger, analyzer, sdks) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.sdks = sdks;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.fileTracker.onOutline.listen(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
        this.disposables.push(vscode_1.commands.registerCommand("_dart.openDartPadSample", (sample) => __awaiter(this, void 0, void 0, function* () {
            // Link down to first code snippet.
            const fragment = `#${sample.libraryName}.${sample.className}.1`;
            const url = `https://api.flutter.dev/flutter/${sample.libraryName}/${sample.className}-class.html${fragment}`;
            yield utils_2.envUtils.openInBrowser(url);
        })));
        this.flutterPackagesFolder = path.join(sdks.flutter, "packages/flutter/lib/src/").toLowerCase();
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure this file is a Flutter package file.
            const filePath = (0, fs_1.fsPath)(document.uri);
            if (!filePath.toLowerCase().startsWith(this.flutterPackagesFolder))
                return;
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const libraryName = filePath.substr(this.flutterPackagesFolder.length).replace("\\", "/").split("/")[0];
            const visitor = new outline_lsp_1.LspClassOutlineVisitor(this.logger);
            visitor.visit(outline);
            // Filter classes to those with DartPad samples.
            const samples = visitor.classes.filter((cl) => {
                // HACK: DartDocs are between the main offset and codeOffset.
                const docs = document.getText(new vscode_1.Range((0, utils_2.lspToPosition)(cl.range.start), (0, utils_2.lspToPosition)(cl.codeRange.start)));
                return dartPadSamplePattern.test(docs);
            }).map((cl) => (Object.assign(Object.assign({}, cl), { libraryName })));
            return samples
                .filter((sample) => sample.codeRange)
                .map((sample) => new vscode_1.CodeLens((0, utils_2.lspToRange)(sample.codeRange), {
                arguments: [sample],
                command: "_dart.openDartPadSample",
                title: `Open online interactive samples for ${sample.className}`,
            }));
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspFlutterDartPadSamplesCodeLensProvider = LspFlutterDartPadSamplesCodeLensProvider;


/***/ }),

/***/ 7927:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MainCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const debugger_1 = __webpack_require__(2074);
const utils_2 = __webpack_require__(7220);
const utils_3 = __webpack_require__(8779);
class MainCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const fileType = (0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)) ? "test-file" : "file";
            const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document, fileType);
            const templatesHaveRun = !!templates.find((t) => t.name === "Run");
            const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
            const templatesHaveProfile = !!templates.find((t) => t.name === "Profile");
            const mainFunction = (_a = outline.children) === null || _a === void 0 ? void 0 : _a.find((o) => o.element.name === "main");
            if (!mainFunction)
                return;
            const results = [];
            if (!templatesHaveRun)
                results.push(this.createCodeLens(document, mainFunction, "Run", false));
            if (!templatesHaveDebug)
                results.push(this.createCodeLens(document, mainFunction, "Debug", true));
            if (fileType === "file" && !templatesHaveProfile && (0, utils_3.isInsideFlutterProject)(document.uri))
                results.push(this.createCodeLens(document, mainFunction, "Profile", false, { "flutterMode": "profile" }));
            return results.concat(templates.map((t) => this.createCodeLens(document, mainFunction, t.name, t.template.startsWith("debug"), t)));
        });
    }
    createCodeLens(document, mainFunction, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.toRange)(document, mainFunction.offset, mainFunction.length), {
            arguments: template ? [document.uri, template] : [document.uri],
            command: debug ? "dart.startDebugging" : "dart.startWithoutDebugging",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.MainCodeLensProvider = MainCodeLensProvider;


/***/ }),

/***/ 5543:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspMainCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const debugger_1 = __webpack_require__(2074);
const utils_2 = __webpack_require__(7220);
const utils_3 = __webpack_require__(8779);
class LspMainCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.fileTracker.onOutline.listen(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const fileType = (0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)) ? "test-file" : "file";
            const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document, fileType);
            const templatesHaveRun = !!templates.find((t) => t.name === "Run");
            const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
            const templatesHaveProfile = !!templates.find((t) => t.name === "Profile");
            const mainFunction = (_a = outline.children) === null || _a === void 0 ? void 0 : _a.find((o) => o.element.name === "main");
            if (!mainFunction)
                return;
            const results = [];
            if (!templatesHaveRun)
                results.push(this.createCodeLens(document, mainFunction, "Run", false));
            if (!templatesHaveDebug)
                results.push(this.createCodeLens(document, mainFunction, "Debug", true));
            if (fileType === "file" && !templatesHaveProfile && (0, utils_3.isInsideFlutterProject)(document.uri))
                results.push(this.createCodeLens(document, mainFunction, "Profile", false, { "flutterMode": "profile", "openDevTools": "performance" }));
            return results.concat(templates.map((t) => this.createCodeLens(document, mainFunction, t.name, t.template.startsWith("debug"), t)));
        });
    }
    createCodeLens(document, mainFunction, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.lspToRange)(mainFunction.range), {
            arguments: template ? [document.uri, template] : [document.uri],
            command: debug ? "dart.startDebugging" : "dart.startWithoutDebugging",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspMainCodeLensProvider = LspMainCodeLensProvider;


/***/ }),

/***/ 6993:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const outline_das_1 = __webpack_require__(6074);
const debugger_1 = __webpack_require__(2074);
const utils_2 = __webpack_require__(7220);
const utils_3 = __webpack_require__(8779);
class TestCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            // We should only show the CodeLens for projects we know can actually handle `pub run` (for ex. the
            // SDK codebase cannot, and will therefore run all tests when you click them).
            if (!this.analyzer.fileTracker.supportsPubRunTest(document.uri))
                return;
            // If we don't consider this a test file, we should also not show links (since we may try to run the
            // app with 'flutter run' instead of 'flutter test' which will fail due to no `-name` argument).
            if (!(0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)))
                return;
            const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document, "test");
            const templatesHaveRun = !!templates.find((t) => t.name === "Run");
            const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
            const visitor = new outline_das_1.TestOutlineVisitor(this.logger);
            visitor.visit(outline);
            return (0, utils_1.flatMap)(visitor.tests
                .filter((test) => test.offset && test.length)
                .map((test) => {
                const results = [];
                if (!templatesHaveRun)
                    results.push(this.createCodeLens(document, test, "Run", false));
                if (!templatesHaveDebug)
                    results.push(this.createCodeLens(document, test, "Debug", true));
                return results.concat(templates.map((t) => this.createCodeLens(document, test, t.name, t.template.startsWith("debug"), t)));
            }), (x) => x);
        });
    }
    createCodeLens(document, test, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.toRange)(document, test.offset, test.length), {
            arguments: template ? [test, template] : [test],
            command: debug ? "_dart.startDebuggingTestFromOutline" : "_dart.startWithoutDebuggingTestFromOutline",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestCodeLensProvider = TestCodeLensProvider;


/***/ }),

/***/ 3005:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspTestCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const outline_lsp_1 = __webpack_require__(4215);
const debugger_1 = __webpack_require__(2074);
const utils_2 = __webpack_require__(7220);
const utils_3 = __webpack_require__(8779);
class LspTestCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.fileTracker.onOutline.listen(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            // We should only show the CodeLens for projects we know can actually handle `pub run` (for ex. the
            // SDK codebase cannot, and will therefore run all tests when you click them).
            if (!this.analyzer.fileTracker.supportsPubRunTest(document.uri))
                return;
            // If we don't consider this a test file, we should also not show links (since we may try to run the
            // app with 'flutter run' instead of 'flutter test' which will fail due to no `-name` argument).
            if (!(0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)))
                return;
            const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document, "test");
            const templatesHaveRun = !!templates.find((t) => t.name === "Run");
            const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
            const visitor = new outline_lsp_1.LspTestOutlineVisitor(this.logger, (0, fs_1.fsPath)(document.uri));
            visitor.visit(outline);
            return (0, utils_1.flatMap)(visitor.tests
                .filter((test) => test.range)
                .map((test) => {
                const results = [];
                if (!templatesHaveRun)
                    results.push(this.createCodeLens(document, test, "Run", false));
                if (!templatesHaveDebug)
                    results.push(this.createCodeLens(document, test, "Debug", true));
                return results.concat(templates.map((t) => this.createCodeLens(document, test, t.name, t.template.startsWith("debug"), t)));
            }), (x) => x);
        });
    }
    createCodeLens(document, test, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.lspToRange)(test.range), {
            arguments: template ? [test, template] : [test],
            command: debug ? "_dart.startDebuggingTestFromOutline" : "_dart.startWithoutDebuggingTestFromOutline",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspTestCodeLensProvider = LspTestCodeLensProvider;


/***/ }),

/***/ 4954:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddDependencyCommand = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const pub_add_1 = __webpack_require__(1119);
const fs_1 = __webpack_require__(300);
const util = __webpack_require__(8779);
const projects_1 = __webpack_require__(6417);
const sdk_1 = __webpack_require__(997);
const cacheFilename = "package_cache.json";
const knownFlutterSdkPackages = [
    "flutter",
    "flutter_test",
    "flutter_driver",
    "flutter_localizations",
    "integration_test",
];
class AddDependencyCommand extends sdk_1.BaseSdkCommands {
    constructor(logger, context, workspace, dartCapabilities, pubApi) {
        super(logger, context, workspace, dartCapabilities);
        this.pubApi = pubApi;
        this.disposables.push(vs.commands.registerCommand("dart.addDependency", (uri) => this.promptAndAddDependency(uri, false)));
        this.disposables.push(vs.commands.registerCommand("dart.addDevDependency", (uri) => this.promptAndAddDependency(uri, true)));
        this.disposables.push(vs.commands.registerCommand("_dart.addDependency", this.addDependency, this));
        this.disposables.push(vs.commands.registerCommand("_dart.removeDependency", this.removeDependency, this));
        this.extensionStoragePath = context.extensionStoragePath;
        // Kick off async work to fetch then queue a new check.
        this.loadAndFetch().catch((e) => this.logger.error(e));
    }
    loadAndFetch() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.loadPackageCache();
            }
            finally {
                this.queueNextPackageNameFetch((_b = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.cacheTimeRemainingMs) !== null && _b !== void 0 ? _b : 0);
            }
        });
    }
    loadPackageCache() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.extensionStoragePath)
                return;
            const cacheFile = path.join(this.extensionStoragePath, cacheFilename);
            if (!fs.existsSync(cacheFile))
                return;
            try {
                const contents = yield fs.promises.readFile(cacheFile);
                this.cache = pub_add_1.PackageCacheData.fromJson(contents.toString());
            }
            catch (e) {
                this.logger.error(`Failed to read package cache file: ${e}`);
            }
        });
    }
    savePackageCache() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.extensionStoragePath)
                return;
            const cacheFile = path.join(this.extensionStoragePath, cacheFilename);
            try {
                const json = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.toJson();
                if (json)
                    yield fs.promises.writeFile(cacheFile, json);
            }
            catch (e) {
                this.logger.error(`Failed to read package cache file: ${e}`);
            }
        });
    }
    queueNextPackageNameFetch(ms) {
        if (this.nextPackageNameFetchTimeout)
            clearTimeout(this.nextPackageNameFetchTimeout);
        this.nextPackageNameFetchTimeout = setTimeout(() => this.fetchPackageNames(), ms);
    }
    fetchPackageNames() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Caching Pub package names from pub.dev...`);
            try {
                const results = yield this.pubApi.getPackageNames();
                this.cache = pub_add_1.PackageCacheData.fromPackageNames(results.packages);
                yield this.savePackageCache();
            }
            catch (e) {
                this.logger.error(`Failed to fetch package cache: $e`);
            }
            this.queueNextPackageNameFetch(pub_add_1.PackageCacheData.maxCacheAgeMs);
        });
    }
    promptAndAddDependency(uri, isDevDependency) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || !(uri instanceof vs.Uri)) {
                uri = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to add the dependency to");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            const selectedOption = yield this.promptForPackageInfo();
            if (!selectedOption)
                return;
            let packageInfo;
            if (typeof selectedOption === "string") {
                // For convenience, we handle string URLs/paths too.
                if (selectedOption.startsWith("http://") || selectedOption.startsWith("https://"))
                    packageInfo = yield this.promptForGitPackageInfo(selectedOption);
                else if (selectedOption.includes("/") || selectedOption.includes("\\"))
                    packageInfo = yield this.promptForPathPackageInfo(selectedOption);
                else
                    packageInfo = { packageName: selectedOption, marker: undefined };
            }
            else {
                switch (selectedOption.marker) {
                    case "PATH":
                        packageInfo = yield this.promptForPathPackageInfo();
                        break;
                    case "GIT":
                        packageInfo = yield this.promptForGitPackageInfo();
                        break;
                    default:
                        packageInfo = selectedOption;
                        break;
                }
            }
            if (!packageInfo)
                return;
            return this.addDependency(uri, packageInfo, isDevDependency);
        });
    }
    addDependency(uri, selectedPackage, isDevDependency) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            const args = ["add"];
            let packageName;
            if (selectedPackage.marker === "GIT") {
                packageName = selectedPackage.packageName;
                args.push(packageName);
                args.push(`--git-url=${selectedPackage.url}`);
                if (selectedPackage.ref) {
                    args.push(`--git-ref=${selectedPackage.ref}`);
                }
                if (selectedPackage.path) {
                    args.push(`--git-path=${selectedPackage.path}`);
                }
            }
            else if (selectedPackage.marker === "PATH") {
                packageName = selectedPackage.packageName;
                args.push(packageName);
                args.push(`--path=${selectedPackage.path}`);
            }
            else {
                packageName = selectedPackage.packageName;
                args.push(packageName);
            }
            if (isDevDependency)
                args.push("--dev");
            // Handle some known Flutter dependencies.
            const isFlutterSdkPackage = knownFlutterSdkPackages.includes(packageName);
            if (isFlutterSdkPackage) {
                args.push("--sdk");
                args.push("flutter");
            }
            if (this.sdks.flutter && (isFlutterSdkPackage || util.isInsideFlutterProject(uri))) {
                return this.runFlutter(["pub", ...args], uri);
            }
            else {
                return this.runPub(args, uri);
            }
        });
    }
    removeDependency(uri, packageName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            const args = ["remove", packageName];
            if (this.sdks.flutter && util.isInsideFlutterProject(uri)) {
                return this.runFlutter(["pub", ...args], uri);
            }
            else {
                return this.runPub(args, uri);
            }
        });
    }
    /// Prompts the user to select a package name, or the option to select a path or Git package (in
    /// which case they must also provide package name etc).
    promptForPackageInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const quickPick = vs.window.createQuickPick();
            quickPick.placeholder = "package name, URL or path";
            quickPick.title = "Enter a package name, URL or local path";
            quickPick.items = this.getPackageEntries();
            quickPick.onDidChangeValue((prefix) => {
                quickPick.items = this.getPackageEntries(prefix);
            });
            const selectedOption = yield new Promise((resolve) => {
                quickPick.onDidAccept(() => resolve(quickPick.selectedItems && quickPick.selectedItems[0] ? quickPick.selectedItems[0] : quickPick.value));
                quickPick.onDidHide(() => resolve(undefined));
                quickPick.show();
            });
            quickPick.dispose();
            return selectedOption;
        });
    }
    promptForPathPackageInfo(packagePath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!packagePath) {
                const packagePaths = yield vs.window.showOpenDialog({
                    canSelectFiles: false,
                    canSelectFolders: true,
                    canSelectMany: false,
                    openLabel: "Select package folder",
                });
                if (!packagePaths || packagePaths.length !== 1)
                    return;
                packagePath = (0, fs_1.fsPath)(packagePaths[0]);
            }
            if (!packagePath)
                return;
            try {
                const pubspecPackageNameRegex = /^name: (\w+)$/gm;
                const pubspecContent = fs.readFileSync(path.join(packagePath, "pubspec.yaml"), "utf8");
                const packageNameResult = pubspecPackageNameRegex.exec(pubspecContent);
                if (packageNameResult)
                    return { path: packagePath, packageName: packageNameResult[1], marker: "PATH" };
            }
            catch (e) {
                this.logger.error(e);
                vs.window.showErrorMessage("The selected folder does not appear to be a valid Pub package");
                return;
            }
        });
    }
    promptForGitPackageInfo(repoUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!repoUrl)
                repoUrl = yield this.promptForGitUrl();
            if (!repoUrl)
                return;
            const urlSegments = repoUrl.split("/");
            const packageName = yield this.promptForPackageName(urlSegments[urlSegments.length - 1]);
            if (!packageName)
                return;
            const repoRef = yield this.promptForGitRef();
            const repoPath = yield this.promptForGitPath();
            return {
                marker: "GIT",
                packageName,
                path: repoPath,
                ref: repoRef,
                url: repoUrl,
            };
        });
    }
    promptForGitUrl() {
        return vs.window.showInputBox({
            ignoreFocusOut: true,
            placeHolder: "git repo url",
            title: "Enter a Git repository url",
        });
    }
    promptForGitPath() {
        return vs.window.showInputBox({
            ignoreFocusOut: true,
            placeHolder: "path to package",
            title: "Enter the path to the package in the repository (press <enter> for default)",
        });
    }
    promptForGitRef() {
        return __awaiter(this, void 0, void 0, function* () {
            return vs.window.showInputBox({
                ignoreFocusOut: true,
                placeHolder: "commit/branch",
                title: "Enter the commit/branch to use (press <enter> for default)",
            });
        });
    }
    promptForPackageName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield vs.window.showInputBox({
                ignoreFocusOut: true,
                placeHolder: "package name",
                title: "Enter the Packages name",
                value: name,
            });
        });
    }
    getPackageEntries(prefix) {
        var _a, _b;
        const max = 50;
        const packageNames = (_b = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.packageNames) !== null && _b !== void 0 ? _b : [];
        let matches = new Set();
        // This list can be quite large, so avoid using .filter() if we can bail out early.
        if (prefix) {
            for (let i = 0; i < packageNames.length && matches.size < max; i++) {
                const packageName = packageNames[i];
                if (packageName.startsWith(prefix))
                    matches.add(packageName);
            }
            // Also add on any Flutter-SDK packages that match.
            for (const packageName of knownFlutterSdkPackages) {
                if (packageName.startsWith(prefix))
                    matches.add(packageName);
            }
        }
        else {
            matches = new Set(packageNames.slice(0, Math.min(max, packageNames.length)));
        }
        const pickablePackageNames = Array.from(matches).map((packageName) => ({
            label: packageName,
            packageName,
        }));
        if (prefix) {
            return pickablePackageNames;
        }
        else {
            return [
                {
                    description: "add a package from a local path",
                    label: "Local Path Package",
                    marker: "PATH",
                },
                {
                    description: "add a package from a Git repository",
                    label: "Git Repository URL",
                    marker: "GIT",
                },
                ...pickablePackageNames,
            ];
        }
    }
}
exports.AddDependencyCommand = AddDependencyCommand;


/***/ }),

/***/ 8932:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyzerCommands = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(7220);
// Must be global, as all classes are created during an extension restart.
let forcedReanalyzeCount = 0;
class AnalyzerCommands {
    constructor(context, logger, analyzer, analytics) {
        this.logger = logger;
        context.subscriptions.push(vs.commands.registerCommand("dart.openAnalyzerDiagnostics", () => __awaiter(this, void 0, void 0, function* () {
            const res = yield analyzer.getDiagnosticServerPort();
            yield utils_1.envUtils.openInBrowser(`http://127.0.0.1:${res.port}/`);
        })));
        context.subscriptions.push(vs.commands.registerCommand("dart.restartAnalysisServer", () => __awaiter(this, void 0, void 0, function* () {
            forcedReanalyzeCount++;
            if (forcedReanalyzeCount === 10)
                this.showServerRestartPrompt().catch((e) => logger.error(e));
            analytics.logAnalyzerRestart();
            vs.commands.executeCommand("_dart.reloadExtension");
        })));
        context.subscriptions.push(vs.commands.registerCommand("dart.forceReanalyze", () => __awaiter(this, void 0, void 0, function* () {
            forcedReanalyzeCount++;
            if (forcedReanalyzeCount === 10)
                this.showServerRestartPrompt().catch((e) => logger.error(e));
            analytics.logAnalyzerRestart();
            yield analyzer.forceReanalyze();
        })));
    }
    showServerRestartPrompt() {
        return __awaiter(this, void 0, void 0, function* () {
            const choice = yield vs.window.showInformationMessage("Needing to reanalyze a lot? Please consider filing a bug with a server instrumentation log", constants_1.issueTrackerAction);
            if (choice === constants_1.issueTrackerAction)
                yield utils_1.envUtils.openInBrowser(constants_1.issueTrackerUri, this.logger);
        });
    }
}
exports.AnalyzerCommands = AnalyzerCommands;


/***/ }),

/***/ 1026:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runProcessInOutputChannel = exports.getOutputChannel = void 0;
const vs = __webpack_require__(9496);
const channels = {};
function getOutputChannel(name, insertDivider = false) {
    if (!channels[name]) {
        channels[name] = vs.window.createOutputChannel(name);
    }
    else if (insertDivider) {
        const ch = channels[name];
        ch.appendLine("");
        ch.appendLine("--");
        ch.appendLine("");
    }
    return channels[name];
}
exports.getOutputChannel = getOutputChannel;
function runProcessInOutputChannel(process, channel) {
    process.stdout.on("data", (data) => channel.append(data.toString()));
    process.stderr.on("data", (data) => channel.append(data.toString()));
    process.on("close", (code) => channel.appendLine(`exit code ${code}`));
}
exports.runProcessInOutputChannel = runProcessInOutputChannel;


/***/ }),

/***/ 5836:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCommands = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const projects_1 = __webpack_require__(3953);
const config_1 = __webpack_require__(4165);
const stagehand_1 = __webpack_require__(5958);
const dart_create_1 = __webpack_require__(3285);
const sdk_1 = __webpack_require__(997);
class DartCommands extends sdk_1.BaseSdkCommands {
    constructor(logger, context, workspace, sdkUtils, pubGlobal, dartCapabilities) {
        super(logger, context, workspace, dartCapabilities);
        this.sdkUtils = sdkUtils;
        this.pubGlobal = pubGlobal;
        this.disposables.push(vs.commands.registerCommand("dart.createProject", this.createDartProject, this));
        this.disposables.push(vs.commands.registerCommand("_dart.create", this.dartCreate, this));
    }
    dartCreate(projectPath, templateName) {
        // TODO: This should move inside DartCreate/Stagehand, but it requires extracting
        // all the command executing also into a better base class ("run pub in folder" etc.)
        // instead of being directly in here.
        if (this.dartCapabilities.supportsDartCreate) {
            const binPath = path.join(this.sdks.dart, constants_1.dartVMPath);
            const projectContainer = path.dirname(projectPath);
            const projectName = path.basename(projectPath);
            const args = ["create", "-t", templateName, projectName, "--force"];
            return this.runCommandInFolder(templateName, projectContainer, binPath, args, false);
        }
        else {
            const args = ["global", "run", "stagehand", templateName];
            return this.runPubInFolder(projectPath, args, templateName);
        }
    }
    createDartProject() {
        return __awaiter(this, void 0, void 0, function* () {
            const command = "dart.createProject";
            const triggerFilename = constants_1.DART_CREATE_PROJECT_TRIGGER_FILE;
            const autoPickIfSingleItem = false;
            if (!this.sdks || !this.sdks.dart) {
                this.sdkUtils.showDartActivationFailure(command);
                return;
            }
            // Get the JSON for the available templates by calling stagehand or 'dart create'.
            const creator = this.dartCapabilities.supportsDartCreate
                ? new dart_create_1.DartCreate(this.logger, this.sdks)
                : new stagehand_1.Stagehand(this.logger, this.dartCapabilities, this.sdks, this.pubGlobal);
            const isAvailable = yield creator.installIfRequired();
            if (!isAvailable) {
                return;
            }
            let templates;
            try {
                templates = yield creator.getTemplates();
            }
            catch (e) {
                vs.window.showErrorMessage(`Unable to fetch project templates. ${e}`);
                return;
            }
            const sortedTemplates = (0, array_1.sortBy)(templates, (s) => s.label);
            const pickItems = sortedTemplates.map((t) => ({
                description: t.name,
                detail: t.description,
                label: t.label,
                template: t,
            }));
            // Get the user to pick a template (but pick for them if there's only one
            // and autoPickIfSingleItem).
            const selectedTemplate = autoPickIfSingleItem && pickItems.length === 1
                ? pickItems[0]
                : yield vs.window.showQuickPick(pickItems, {
                    matchOnDescription: true,
                    placeHolder: "Which Dart template?",
                });
            if (!selectedTemplate)
                return;
            // If already in a workspace, set the default folder to something nearby.
            const folders = yield vs.window.showOpenDialog({
                canSelectFolders: true,
                defaultUri: this.context.lastUsedNewProjectPath ? vs.Uri.file(this.context.lastUsedNewProjectPath) : undefined,
                openLabel: "Select a folder to create the project in",
            });
            if (!folders || folders.length !== 1)
                return;
            const folderPath = (0, fs_1.fsPath)(folders[0]);
            this.context.lastUsedNewProjectPath = folderPath;
            const defaultName = (0, fs_1.nextAvailableFilename)(folderPath, "dart_application_");
            const name = yield vs.window.showInputBox({ prompt: "Enter a name for your new project", placeHolder: defaultName, value: defaultName, validateInput: (s) => this.validateDartProjectName(s, folderPath) });
            if (!name)
                return;
            const projectFolderUri = vs.Uri.file(path.join(folderPath, name));
            const projectFolderPath = (0, fs_1.fsPath)(projectFolderUri);
            if (fs.existsSync(projectFolderPath)) {
                vs.window.showErrorMessage(`A folder named ${name} already exists in ${folderPath}`);
                return;
            }
            // Create the empty folder so we can open it.
            fs.mkdirSync(projectFolderPath);
            // Create a temp dart file to force extension to load when we open this folder.
            fs.writeFileSync(path.join(projectFolderPath, triggerFilename), JSON.stringify(selectedTemplate.template));
            // If we're using a custom SDK, we need to apply it to the new project too.
            if (config_1.config.workspaceSdkPath)
                (0, projects_1.writeDartSdkSettingIntoProject)(config_1.config.workspaceSdkPath, projectFolderPath);
            vs.commands.executeCommand("vscode.openFolder", projectFolderUri);
        });
    }
    validateDartProjectName(input, folderDir) {
        if (!sdk_1.packageNameRegex.test(input))
            return "Dart project names should be all lowercase, with underscores to separate words";
        const bannedNames = ["dart", "test"];
        if (bannedNames.includes(input))
            return `You may not use ${input} as the name for a dart project`;
        if (fs.existsSync(path.join(folderDir, input)))
            return `A project with this name already exists within the selected directory`;
    }
}
exports.DartCommands = DartCommands;


/***/ }),

/***/ 4635:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugCommands = exports.LastTestDebugSession = exports.LastDebugSession = exports.debugSessions = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const user_prompts_1 = __webpack_require__(7622);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const vm_service_extensions_1 = __webpack_require__(7253);
const project_1 = __webpack_require__(3886);
const manager_1 = __webpack_require__(34);
const utils_3 = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
const debug_1 = __webpack_require__(9564);
exports.debugSessions = [];
const CURRENT_FILE_RUNNABLE = "dart-code:currentFileIsRunnable";
// Workaround for https://github.com/microsoft/vscode/issues/100115
const dynamicDebugSessionName = "Dart ";
// As a workaround for https://github.com/Microsoft/vscode/issues/71651 we
// will keep any events that arrive before their session "started" and then
// replace them when the start event comes through.
let pendingCustomEvents = [];
let hasPromptedAboutDebugSettings = false;
class LastDebugSession {
}
exports.LastDebugSession = LastDebugSession;
class LastTestDebugSession {
}
exports.LastTestDebugSession = LastTestDebugSession;
class DebugCommands {
    constructor(logger, context, workspaceContext, dartCapabilities, flutterCapabilities, analytics, pubGlobal, flutterDaemon) {
        this.logger = logger;
        this.context = context;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.analytics = analytics;
        this.disposables = [];
        this.debugOptions = vs.window.createStatusBarItem("dartStatusDebugOptions", vs.StatusBarAlignment.Left, 0);
        this.currentDebugOption = enums_1.DebugOption.MyCode;
        this.debugMetrics = vs.window.createStatusBarItem("dartStatusDebugMetrics", vs.StatusBarAlignment.Right, 0);
        this.onWillHotReloadEmitter = new vs.EventEmitter();
        this.onWillHotReload = this.onWillHotReloadEmitter.event;
        this.onWillHotRestartEmitter = new vs.EventEmitter();
        this.onWillHotRestart = this.onWillHotRestartEmitter.event;
        this.onDebugSessionVmServiceAvailableEmitter = new vs.EventEmitter();
        this.onDebugSessionVmServiceAvailable = this.onDebugSessionVmServiceAvailableEmitter.event;
        this.suppressFlutterWidgetErrors = false;
        this.vmServices = new vm_service_extensions_1.VmServiceExtensions(logger, this);
        this.devTools = new manager_1.DevToolsManager(logger, workspaceContext, this, analytics, pubGlobal, dartCapabilities, flutterCapabilities, flutterDaemon);
        this.disposables.push(this.devTools);
        this.debugOptions.name = "Dart Debug Options";
        this.disposables.push(this.debugOptions);
        this.debugMetrics.name = "Dart Debug Metrics";
        this.disposables.push(this.debugMetrics);
        this.disposables.push(vs.debug.onDidChangeBreakpoints((e) => this.handleBreakpointChange(e)));
        this.disposables.push(vs.debug.onDidStartDebugSession((s) => this.handleDebugSessionStart(s)));
        this.disposables.push(vs.debug.onDidReceiveDebugSessionCustomEvent((e) => this.handleDebugSessionCustomEvent(e)));
        this.disposables.push(vs.debug.onDidTerminateDebugSession((s) => this.handleDebugSessionEnd(s)));
        this.disposables.push(vs.window.onDidChangeActiveTextEditor((e) => this.updateEditorContexts(e)));
        // Run for current open editor.
        this.updateEditorContexts(vs.window.activeTextEditor);
        this.disposables.push(vs.commands.registerCommand("flutter.overridePlatform", () => this.vmServices.overridePlatform()));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleDebugPainting", () => this.vmServices.toggle(enums_1.VmServiceExtension.DebugPaint)));
        this.disposables.push(vs.commands.registerCommand("flutter.togglePerformanceOverlay", () => this.vmServices.toggle(enums_1.VmServiceExtension.PerformanceOverlay)));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleBrightness", () => this.vmServices.toggle(enums_1.VmServiceExtension.BrightnessOverride, "Brightness.dark", "Brightness.light")));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleRepaintRainbow", () => this.vmServices.toggle(enums_1.VmServiceExtension.RepaintRainbow)));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleDebugModeBanner", () => this.vmServices.toggle(enums_1.VmServiceExtension.DebugBanner)));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleCheckElevations", () => this.vmServices.toggle(enums_1.VmServiceExtension.CheckElevations)));
        this.disposables.push(vs.commands.registerCommand("flutter.togglePaintBaselines", () => this.vmServices.toggle(enums_1.VmServiceExtension.PaintBaselines)));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleSlowAnimations", () => this.vmServices.toggle(enums_1.VmServiceExtension.SlowAnimations, vm_service_extensions_1.timeDilationNormal, vm_service_extensions_1.timeDilationSlow)));
        this.disposables.push(vs.commands.registerCommand("flutter.inspectWidget", () => this.vmServices.toggle(enums_1.VmServiceExtension.InspectorSelectMode, true, true)));
        this.disposables.push(vs.commands.registerCommand("flutter.cancelInspectWidget", () => this.vmServices.toggle(enums_1.VmServiceExtension.InspectorSelectMode, false, false)));
        this.disposables.push(vs.commands.registerCommand("dart.openObservatory", () => __awaiter(this, void 0, void 0, function* () {
            const session = yield this.getDebugSession();
            if (session && !session.session.configuration.noDebug && session.observatoryUri) {
                yield utils_2.envUtils.openInBrowser(session.observatoryUri);
                analytics.logDebuggerOpenObservatory();
            }
            else if (session) {
                logger.warn("Cannot start Observatory for session without debug/observatoryUri");
            }
        })));
        this.disposables.push(vs.commands.registerCommand("flutter.openTimeline", () => __awaiter(this, void 0, void 0, function* () {
            const session = yield this.getDebugSession();
            if (session && !session.session.configuration.noDebug && session.observatoryUri) {
                yield utils_2.envUtils.openInBrowser(session.observatoryUri + "/#/timeline-dashboard");
                analytics.logDebuggerOpenTimeline();
            }
            else if (session) {
                logger.warn("Cannot start Observatory for session without debug/observatoryUri");
            }
        })));
        this.disposables.push(vs.commands.registerCommand("_dart.openDevTools.touchBar", () => vs.commands.executeCommand("dart.openDevTools")));
        constants_1.devToolsPages.forEach((page) => {
            this.disposables.push(vs.commands.registerCommand(page.commandId, (options) => __awaiter(this, void 0, void 0, function* () {
                options = Object.assign({}, options, { page });
                return vs.commands.executeCommand("dart.openDevTools", options);
            })));
        });
        this.disposables.push(vs.commands.registerCommand("flutter.openDevTools", (options) => __awaiter(this, void 0, void 0, function* () { return vs.commands.executeCommand("dart.openDevTools", options); })));
        this.disposables.push(vs.commands.registerCommand("dart.openDevTools", (options) => __awaiter(this, void 0, void 0, function* () {
            if (!exports.debugSessions.length)
                return this.devTools.spawnForNoSession();
            const session = options && options.debugSessionId
                ? exports.debugSessions.find((s) => s.session.id === options.debugSessionId)
                : yield this.getDebugSession();
            if (!session)
                return; // User cancelled or specified session was gone
            // Only show a notification if we were not triggered automatically.
            const notify = !options || options.triggeredAutomatically !== true;
            const page = options === null || options === void 0 ? void 0 : options.page;
            if (session.vmServiceUri) {
                return this.devTools.spawnForSession(session, { notify, page });
            }
            else if (session.session.configuration.noDebug) {
                vs.window.showInformationMessage("You must start your app with debugging in order to use DevTools.");
            }
            else {
                vs.window.showInformationMessage("This debug session is not ready yet or does not support DevTools.");
            }
        })));
        // Misc custom debug commands.
        this.disposables.push(vs.commands.registerCommand("_flutter.hotReload.touchBar", (args) => vs.commands.executeCommand("dart.hotReload", args)));
        this.disposables.push(vs.commands.registerCommand("flutter.hotReload", (args) => vs.commands.executeCommand("dart.hotReload", args)));
        this.disposables.push(vs.commands.registerCommand("dart.hotReload", (args) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!exports.debugSessions.length)
                return;
            const onlyDart = !!(args === null || args === void 0 ? void 0 : args.onlyDart);
            const onlyFlutter = !!(args === null || args === void 0 ? void 0 : args.onlyFlutter);
            if (!!((_a = workspaceContext.config) === null || _a === void 0 ? void 0 : _a.flutterSyncScript) && !onlyDart) {
                yield (0, processes_1.runToolProcess)(logger, workspaceContext.sdks.flutter, workspaceContext.config.flutterSyncScript, []);
            }
            this.onWillHotReloadEmitter.fire();
            yield Promise.all(exports.debugSessions.map((s) => __awaiter(this, void 0, void 0, function* () {
                const shouldReload = onlyDart
                    ? (s.debuggerType === enums_1.DebuggerType.Dart || s.debuggerType === enums_1.DebuggerType.Web)
                    : onlyFlutter
                        ? (s.debuggerType === enums_1.DebuggerType.Flutter)
                        : true;
                if (shouldReload)
                    yield s.session.customRequest("hotReload", args);
            })));
            analytics.logDebuggerHotReload();
        })));
        this.disposables.push(vs.commands.registerCommand("flutter.hotRestart", (args) => __awaiter(this, void 0, void 0, function* () {
            var _b;
            if (!exports.debugSessions.length)
                return;
            if (!!((_b = workspaceContext.config) === null || _b === void 0 ? void 0 : _b.flutterSyncScript)) {
                yield (0, processes_1.runToolProcess)(logger, workspaceContext.sdks.flutter, workspaceContext.config.flutterSyncScript, []);
            }
            this.onWillHotRestartEmitter.fire();
            yield Promise.all(exports.debugSessions.map((s) => s.session.customRequest("hotRestart", args)));
            analytics.logDebuggerRestart();
        })));
        this.disposables.push(vs.commands.registerCommand("dart.startDebugging", (resource, launchTemplate) => {
            const launchConfig = Object.assign({
                name: dynamicDebugSessionName,
                noDebug: false,
                request: "launch",
                type: "dart",
            }, launchTemplate, {
                program: (0, fs_1.fsPath)(resource),
            });
            vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(resource), launchConfig);
        }));
        this.disposables.push(vs.commands.registerCommand("dart.startWithoutDebugging", (resource, launchTemplate) => {
            const launchConfig = Object.assign({
                name: dynamicDebugSessionName,
                noDebug: true,
                request: "launch",
                type: "dart",
            }, launchTemplate, {
                program: (0, fs_1.fsPath)(resource),
            });
            vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(resource), launchConfig);
        }));
        this.disposables.push(vs.commands.registerCommand("dart.createLaunchConfiguration", this.createLaunchConfiguration, this));
        this.disposables.push(vs.commands.registerCommand("dart.rerunLastDebugSession", () => {
            if (LastDebugSession.debugConfig) {
                vs.debug.startDebugging(LastDebugSession.workspaceFolder, LastDebugSession.debugConfig);
            }
            else {
                vs.window.showErrorMessage("There is no previous debug session to run.");
            }
        }));
        this.disposables.push(vs.commands.registerCommand("dart.rerunLastTestDebugSession", () => {
            if (LastTestDebugSession.debugConfig) {
                vs.debug.startDebugging(LastTestDebugSession.workspaceFolder, LastTestDebugSession.debugConfig);
            }
            else {
                vs.window.showErrorMessage("There is no previous test session to run.");
            }
        }));
        // Attach commands.
        this.disposables.push(vs.commands.registerCommand("dart.attach", () => {
            vs.debug.startDebugging(undefined, {
                name: "Dart: Attach to Process",
                request: "attach",
                type: "dart",
            });
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.attachProcess", () => {
            vs.debug.startDebugging(undefined, {
                name: "Flutter: Attach to Process",
                request: "attach",
                type: "dart",
                vmServiceUri: "${command:dart.promptForVmService}",
            });
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.profileApp", () => __awaiter(this, void 0, void 0, function* () {
            yield vs.debug.startDebugging(undefined, {
                flutterMode: "profile",
                name: "Flutter: Run in Profile Mode",
                openDevTools: "performance",
                request: "launch",
                type: "dart",
            });
            if (!this.context.hasNotifiedAboutProfileModeDefaultConfiguration) {
                this.context.hasNotifiedAboutProfileModeDefaultConfiguration = true;
                vs.window.showInformationMessage("Profiling Flutter app with default configuration. To customize this, create a launch configuration (and include 'flutterMode': 'profile').");
            }
        })));
        this.disposables.push(vs.commands.registerCommand("flutter.attach", () => {
            vs.debug.startDebugging(undefined, {
                name: "Flutter: Attach to Device",
                request: "attach",
                type: "dart",
            });
        }));
        this.disposables.push(vs.commands.registerCommand("dart.promptForVmService", (defaultValueOrConfig) => __awaiter(this, void 0, void 0, function* () {
            const defaultValue = typeof defaultValueOrConfig === "string" ? defaultValueOrConfig : undefined;
            return vs.window.showInputBox({
                ignoreFocusOut: true,
                placeHolder: "Paste an VM Service URI",
                prompt: "Enter VM Service URI",
                validateInput: (input) => {
                    if (!input)
                        return;
                    input = input.trim();
                    // eslint-disable-next-line id-blacklist
                    if (Number.isInteger(parseFloat(input)))
                        return;
                    // Uri.parse doesn't seem to work as expected, so do our own basic validation
                    // https://github.com/Microsoft/vscode/issues/49818
                    if (!input.startsWith("http://") && !input.startsWith("https://")
                        && !input.startsWith("ws://") && !input.startsWith("wss://"))
                        return "Please enter a valid VM Service URI";
                },
                value: defaultValue,
            });
        })));
        // Debug options.
        if (config_1.config.debugSdkLibraries && config_1.config.debugExternalPackageLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodePackagesSdk;
        else if (config_1.config.debugSdkLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodeSdk;
        else if (config_1.config.debugExternalPackageLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodePackages;
        this.disposables.push(vs.commands.registerCommand("_dart.toggleDebugOptions", this.toggleDebugOptions, this));
        this.debugOptions.text = `Debug ${enums_1.debugOptionNames[this.currentDebugOption]}`;
        this.debugOptions.tooltip = `Controls whether to step into or stop at breakpoints in only files in this workspace or also those in SDK and/or external Pub packages`;
        this.debugOptions.command = "_dart.toggleDebugOptions";
    }
    createLaunchConfiguration(resourceUri) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (!resourceUri || resourceUri.scheme !== "file")
                return;
            const entryScriptPath = (0, fs_1.fsPath)(resourceUri);
            if (!(0, utils_3.isDartFile)(entryScriptPath))
                return;
            const workspaceFolder = vs.workspace.getWorkspaceFolder(resourceUri);
            if (!workspaceFolder)
                return;
            const workspaceFolderPath = (0, fs_1.fsPath)(workspaceFolder.uri);
            const projectFolderPath = (_a = (0, project_1.locateBestProjectRoot)(entryScriptPath)) !== null && _a !== void 0 ? _a : workspaceFolderPath;
            const relativeCwdPath = path.relative(workspaceFolderPath, projectFolderPath);
            const relativeEntryScriptPath = path.relative(projectFolderPath, entryScriptPath);
            const projectType = (0, utils_3.isFlutterProjectFolder)(projectFolderPath) ? "Flutter" : "Dart";
            const name = `${projectType} (${relativeEntryScriptPath})`;
            const newLaunchConfig = {
                name,
                type: "dart",
                // eslint-disable-next-line @typescript-eslint/tslint/config
                request: "launch",
                cwd: relativeCwdPath ? relativeCwdPath : undefined,
                program: relativeEntryScriptPath,
            };
            // Add to the launch.json config.
            const launchFile = vs.workspace.getConfiguration("launch", workspaceFolder);
            // If we're in a code-workspace that already has workspace-level launch configs,
            // we should add to that. Otherwise add directly to the workspace folder.
            const configInspect = launchFile.inspect("configurations");
            const workspaceConfigs = (_b = configInspect === null || configInspect === void 0 ? void 0 : configInspect.workspaceValue) !== null && _b !== void 0 ? _b : [];
            const workspaceFolderConfigs = (_c = configInspect === null || configInspect === void 0 ? void 0 : configInspect.workspaceFolderValue) !== null && _c !== void 0 ? _c : [];
            const hasWorkspaceConfigs = !!vs.workspace.workspaceFile && !!workspaceConfigs.length;
            const configs = hasWorkspaceConfigs ? workspaceConfigs : workspaceFolderConfigs;
            const target = hasWorkspaceConfigs ? vs.ConfigurationTarget.Workspace : vs.ConfigurationTarget.WorkspaceFolder;
            configs.push(newLaunchConfig);
            yield launchFile.update("configurations", configs, target);
            // Open the correct file based on workspace or workspace folder.
            if (hasWorkspaceConfigs) {
                vs.commands.executeCommand("workbench.action.openWorkspaceConfigFile");
            }
            else {
                const launchConfig = path.join(workspaceFolderPath, ".vscode", "launch.json");
                vs.workspace.openTextDocument(launchConfig).then((doc) => vs.window.showTextDocument(doc));
            }
        });
    }
    getDebugSession() {
        return __awaiter(this, void 0, void 0, function* () {
            if (exports.debugSessions.length === 0) {
                this.logger.info("No debug session to use!");
                return undefined;
            }
            else if (exports.debugSessions.length === 1) {
                this.logger.info("Using only available debug session");
                return exports.debugSessions[0];
            }
            else {
                this.logger.info("Multiple debug sessions available, will prompt user:");
                const sessions = exports.debugSessions.map((s) => ({
                    description: s.session.workspaceFolder ? s.session.workspaceFolder.name : undefined,
                    detail: s.session.configuration.deviceName || `Started ${s.sessionStart.toLocaleTimeString()}`,
                    label: s.session.name,
                    session: s,
                }));
                for (const session of sessions)
                    this.logger.info(`${session.label} ${session.description} (${session.detail})`);
                const selectedItem = yield vs.window.showQuickPick(sessions, { placeHolder: "Which debug session?" });
                return selectedItem && selectedItem.session;
            }
        });
    }
    handleBreakpointChange(e) {
        if (hasPromptedAboutDebugSettings)
            return;
        for (const bp of e.added)
            this.promptAboutDebuggerSettingsIfBreakpointOutsideWorkspace(bp);
    }
    promptAboutDebuggerSettingsIfBreakpointOutsideWorkspace(e) {
        // If the user has enabled any of these, assume they understand the setting.
        if (config_1.config.debugSdkLibraries || config_1.config.debugExternalPackageLibraries)
            return;
        if (hasPromptedAboutDebugSettings || this.context.breakpointOutsideWorkspaceDoNotShow || !(e instanceof vs.SourceBreakpoint) || !e.enabled)
            return;
        // Don't consider non-Dart files.
        if (!(0, fs_1.fsPath)(e.location.uri).toLocaleLowerCase().endsWith(".dart"))
            return;
        // If it's inside the workspace we don't want to prompt.
        if (vs.workspace.getWorkspaceFolder(e.location.uri))
            return;
        hasPromptedAboutDebugSettings = true;
        const message = `You have a breakpoint outside of your workspace but debug settings are set to 'my code'. Would you like to change settings? You can also change this from the status bar while debugging.`;
        const debugJustMyCodeAction = "Debug just my code";
        const debugEverything = "Debug my code + packages + SDK";
        vs.window.showWarningMessage(message, debugJustMyCodeAction, debugEverything, constants_1.doNotAskAgainAction).then((choice) => {
            if (choice === constants_1.doNotAskAgainAction)
                this.context.breakpointOutsideWorkspaceDoNotShow = true;
            if (choice !== debugEverything)
                return;
            this.currentDebugOption = enums_1.DebugOption.MyCodePackagesSdk;
            this.applyNewDebugOption();
        });
    }
    handleDebugSessionStart(s) {
        var _a, _b;
        if (s.type !== "dart")
            return;
        const session = new debug_1.DartDebugSessionInformation(s, s.configuration.debuggerType);
        // If we're the first fresh debug session, reset all settings to default.
        // Subsequent launches will inherit the "current" values.
        if (exports.debugSessions.length === 0)
            this.vmServices.resetToDefaults();
        exports.debugSessions.push(session);
        if (s.configuration.debuggerType === enums_1.DebuggerType.Flutter || s.configuration.debuggerType === enums_1.DebuggerType.Web) {
            const isProfileMode = (_a = s.configuration.toolArgs) === null || _a === void 0 ? void 0 : _a.includes("--profile");
            const isReleaseMode = (_b = s.configuration.toolArgs) === null || _b === void 0 ? void 0 : _b.includes("--release");
            if (isReleaseMode)
                vs.commands.executeCommand("setContext", constants_1.isInFlutterReleaseModeDebugSessionContext, true);
            else if (isProfileMode)
                vs.commands.executeCommand("setContext", constants_1.isInFlutterProfileModeDebugSessionContext, true);
            else
                vs.commands.executeCommand("setContext", constants_1.isInFlutterDebugModeDebugSessionContext, true);
        }
        // Process any queued events that came in before the session start
        // event.
        const eventsToProcess = pendingCustomEvents.filter((e) => e.session.id === s.id);
        pendingCustomEvents = pendingCustomEvents.filter((e) => e.session.id !== s.id);
        eventsToProcess.forEach((e) => {
            this.logger.info(`Processing delayed event ${e.event} for session ${e.session.id}`);
            // tslint:disable-next-line: no-floating-promises
            this.handleCustomEventWithSession(session, e);
        });
        this.debugOptions.show();
    }
    handleDebugSessionCustomEvent(e) {
        if (this.handleCustomEvent(e))
            return;
        const session = exports.debugSessions.find((ds) => ds.session.id === e.session.id);
        if (!session) {
            this.logger.warn(`Did not find session ${e.session.id} to handle ${e.event}. There were ${exports.debugSessions.length} sessions:\n${exports.debugSessions.map((ds) => `  ${ds.session.id}`).join("\n")}`);
            this.logger.warn(`Event will be queued and processed when the session start event fires`);
            pendingCustomEvents.push(e);
            return;
        }
        // tslint:disable-next-line: no-floating-promises
        this.handleCustomEventWithSession(session, e);
    }
    handleDebugSessionEnd(s) {
        var _a;
        const sessionIndex = exports.debugSessions.findIndex((ds) => ds.session.id === s.id);
        if (sessionIndex === -1)
            return;
        // Grab the session and remove it from the list so we don't try to interact with it anymore.
        const session = exports.debugSessions[sessionIndex];
        session.hasEnded = true;
        exports.debugSessions.splice(sessionIndex, 1);
        // Close any in-progress progress notifications.
        for (const progressID of Object.keys(session.progress))
            (_a = session.progress[progressID]) === null || _a === void 0 ? void 0 : _a.complete();
        const debugSessionEnd = new Date();
        this.analytics.logDebugSessionDuration(enums_1.DebuggerType[session.debuggerType], debugSessionEnd.getTime() - session.sessionStart.getTime());
        // If this was the last session terminating, then remove all the flags for which service extensions are supported.
        // Really we should track these per-session, but the changes of them being different given we only support one
        // SDK at a time are practically zero.
        if (exports.debugSessions.length === 0) {
            this.vmServices.markAllServicesUnloaded();
            this.vmServices.markAllServiceExtensionsUnloaded();
            this.debugOptions.hide();
            this.debugMetrics.hide();
            for (const debugContext of [
                constants_1.isInFlutterDebugModeDebugSessionContext,
                constants_1.isInFlutterProfileModeDebugSessionContext,
            ])
                vs.commands.executeCommand("setContext", debugContext, false);
        }
    }
    handleCustomEvent(e) {
        if (e.event === "dart.log") {
            const message = e.body;
            const logMessage = `[${e.session.name}] ${message.message}`;
            switch (message.severity) {
                case enums_1.LogSeverity.Warn:
                    this.logger.warn(logMessage, message.category);
                    break;
                case enums_1.LogSeverity.Error:
                    this.logger.error(logMessage, message.category);
                    break;
                default:
                    this.logger.info(logMessage, message.category);
            }
        }
        else if (e.event === "dart.hotRestartRequest") {
            // This event comes back when the user restarts with the Restart button
            // (eg. it wasn't intiated from our extension, so we don't get to log it
            // in the command).
            this.analytics.logDebuggerRestart();
            this.onWillHotRestartEmitter.fire();
        }
        else if (e.event === "dart.hotReloadRequest") {
            // This event comes back when the user restarts with the Restart button
            // (eg. it wasn't intiated from our extension, so we don't get to log it
            // in the command).
            this.analytics.logDebuggerHotReload();
            this.onWillHotReloadEmitter.fire();
        }
        else if (e.event === "dart.debugMetrics") {
            const memory = e.body.memory;
            const message = `${Math.ceil(memory.current / 1024 / 1024)}MB of ${Math.ceil(memory.total / 1024 / 1024)}MB`;
            this.debugMetrics.text = message;
            this.debugMetrics.tooltip = "This is the amount of memory being consumed by your applications heaps (out of what has been allocated).\n\nNote: memory usage shown in debug builds may not be indicative of usage in release builds. Use profile builds for more accurate figures when testing memory usage.";
            this.debugMetrics.show();
        }
        else if (e.event === "dart.navigate") {
            if (e.body.file && e.body.line && e.body.column)
                vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.parse(e.body.file), e.body.line, e.body.column, e.body.inOtherEditorColumn);
        }
        else {
            // Not handled, will fall through in the caller.
            return false;
        }
        return true;
    }
    handleCustomEventWithSession(session, e) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            this.vmServices.handleDebugEvent(session, e)
                .catch((e) => this.logger.error(e));
            if (e.event === "dart.webLaunchUrl") {
                const launched = !!e.body.launched;
                if (!launched) {
                    try {
                        yield utils_2.envUtils.openInBrowser(e.body.url, this.logger);
                    }
                    catch (e) {
                        this.logger.error(`Failed to launch URL from Flutter app.webLaunchUrl event: ${e.body.url}`);
                    }
                }
            }
            else if (e.event === "dart.exposeUrl") {
                const originalUrl = e.body.url;
                try {
                    const exposedUrl = yield utils_2.envUtils.exposeUrl(vs.Uri.parse(originalUrl, true), this.logger);
                    session.session.customRequest("exposeUrlResponse", { originalUrl, exposedUrl });
                }
                catch (e) {
                    this.logger.error(`Failed to expose URL ${originalUrl}: ${e}`);
                    session.session.customRequest("exposeUrlResponse", { originalUrl, exposedUrl: originalUrl });
                }
            }
            else if (e.event === "dart.debuggerUris") {
                session.observatoryUri = e.body.observatoryUri;
                session.vmServiceUri = e.body.vmServiceUri;
                this.onDebugSessionVmServiceAvailableEmitter.fire(session);
                // Open or prompt for DevTools when appropriate.
                const debuggerType = session.session.configuration.debuggerType;
                if (debuggerType === enums_1.DebuggerType.Dart || debuggerType === enums_1.DebuggerType.Flutter || debuggerType === enums_1.DebuggerType.Web) {
                    if (session.session.configuration.openDevTools) {
                        const pageId = session.session.configuration.openDevTools;
                        const page = constants_1.devToolsPages.find((p) => p.id === pageId);
                        if (pageId) {
                            vs.commands.executeCommand("dart.openDevTools", { debugSessionId: session.session.id, triggeredAutomatically: true, page });
                        }
                        else {
                            vs.window.showWarningMessage(`Debug configuration contain an invalid DevTools page '${pageId}' in 'openDevTools'`);
                        }
                    }
                    else if (config_1.config.openDevTools !== "never") {
                        const shouldLaunch = debuggerType !== enums_1.DebuggerType.Dart || config_1.config.openDevTools === "always";
                        if (shouldLaunch) {
                            // If embedded DevTools is enabled and it's a Flutter app, assume the user wants the Widget inspector.
                            // Otherwise, DevTools will be launched externally (since it's not clear which page they may want).
                            const page = debuggerType === enums_1.DebuggerType.Flutter ? constants_1.widgetInspectorPage : null;
                            vs.commands.executeCommand("dart.openDevTools", { debugSessionId: session.session.id, triggeredAutomatically: true, page });
                        }
                    }
                    else if (debuggerType === enums_1.DebuggerType.Flutter) {
                        // tslint:disable-next-line: no-floating-promises
                        (0, user_prompts_1.showDevToolsNotificationIfAppropriate)(this.context).then((res) => {
                            if (res.shouldAlwaysOpen)
                                config_1.config.setOpenDevTools("flutter");
                        });
                    }
                }
            }
            else if (e.event === "dart.progressStart") {
                // When a debug session is restarted by VS Code (eg. not handled by the DA), the session-end event
                // will not fire so we need to clean up the "Terminating debug session" message manually. Doing it here
                // means it will vanish at the same time as the new one appears, so there are no gaps in progress indicators.
                if (e.body.progressID === constants_1.debugLaunchProgressId) {
                    (_a = session.progress[constants_1.debugTerminatingProgressId]) === null || _a === void 0 ? void 0 : _a.complete();
                    delete session.progress[constants_1.debugTerminatingProgressId];
                }
                const isHotEvent = e.body.progressID.endsWith("-hot.reload") || e.body.progressID.endsWith("-hot.restart");
                const progressLocation = isHotEvent && config_1.config.hotReloadProgress === "statusBar" ? vs.ProgressLocation.Window : vs.ProgressLocation.Notification;
                vs.window.withProgress(
                // TODO: This was previously Window to match what we'd get using DAP progress
                // notifications but users prefer larger notifications as they're easier to
                // see (especially when it comes to things like waiting for debug extension).
                // https://github.com/Dart-Code/Dart-Code/issues/2597
                // If this is changed back, ensure the waiting-for-debug-extension notification
                // is still displayed with additional description.
                { location: progressLocation }, (progress) => {
                    var _a, _b;
                    // Complete any existing one with this ID.
                    (_a = session.progress[e.body.progressID]) === null || _a === void 0 ? void 0 : _a.complete();
                    // Build a new progress and store it in the session.
                    const completer = new utils_1.PromiseCompleter();
                    session.progress[e.body.progressID] = new debug_1.ProgressMessage(progress, completer);
                    (_b = session.progress[e.body.progressID]) === null || _b === void 0 ? void 0 : _b.report(e.body.message);
                    return completer.promise;
                });
            }
            else if (e.event === "dart.progressUpdate") {
                (_b = session.progress[e.body.progressID]) === null || _b === void 0 ? void 0 : _b.report(e.body.message);
            }
            else if (e.event === "dart.progressEnd") {
                if (e.body.message) {
                    (_c = session.progress[e.body.progressID]) === null || _c === void 0 ? void 0 : _c.report(e.body.message);
                    yield new Promise((resolve) => setTimeout(resolve, 400));
                }
                (_d = session.progress[e.body.progressID]) === null || _d === void 0 ? void 0 : _d.complete();
            }
            else if (e.event === "dart.flutter.widgetErrorInspectData") {
                if (this.suppressFlutterWidgetErrors || !config_1.config.showInspectorNotificationsForWidgetErrors)
                    return;
                const data = e.body;
                if (data.devToolsUrl !== (yield this.devTools.devtoolsUrl))
                    return;
                // To avoid spam, when we show this dialog we will set a flag that prevents any more
                // of these types of dialogs until it is dismissed or 5 seconds have passed.
                this.suppressFlutterWidgetErrors = true;
                const timer = setTimeout(() => this.suppressFlutterWidgetErrors = false, 5000);
                const inspectAction = `Inspect Widget`;
                const choice = yield vs.window.showWarningMessage(data.errorDescription, inspectAction, constants_1.doNotAskAgainAction);
                if (choice === inspectAction && session.vmServiceUri) {
                    this.devTools.spawnForSession(session, {
                        inspectorRef: data.inspectorReference,
                        page: constants_1.widgetInspectorPage,
                    });
                }
                else if (choice === constants_1.doNotAskAgainAction) {
                    config_1.config.setShowInspectorNotificationsForWidgetErrors(false);
                }
                clearTimeout(timer);
                this.suppressFlutterWidgetErrors = false;
            }
        });
    }
    toggleDebugOptions() {
        // -1 is because we skip the last combination when toggling since it seems uncommon.
        this.currentDebugOption = (this.currentDebugOption + 1) % (enums_1.debugOptionNames.length - 1);
        this.applyNewDebugOption();
    }
    applyNewDebugOption() {
        this.debugOptions.text = `Debug ${enums_1.debugOptionNames[this.currentDebugOption]}`;
        const debugExternalPackageLibraries = this.currentDebugOption === enums_1.DebugOption.MyCodePackages || this.currentDebugOption === enums_1.DebugOption.MyCodePackagesSdk;
        const debugSdkLibraries = this.currentDebugOption === enums_1.DebugOption.MyCodeSdk || this.currentDebugOption === enums_1.DebugOption.MyCodePackagesSdk;
        config_1.config.setGlobalDebugExternalPackageLibraries(debugExternalPackageLibraries);
        config_1.config.setGlobalDebugSdkLibraries(debugSdkLibraries);
        exports.debugSessions.forEach((session) => {
            session.session.customRequest("updateDebugOptions", {
                debugExternalPackageLibraries,
                debugSdkLibraries,
            });
        });
    }
    updateEditorContexts(e) {
        const isRunnable = !!(e && e.document && e.document.uri.scheme === "file" && (0, utils_3.isValidEntryFile)((0, fs_1.fsPath)(e.document.uri)));
        vs.commands.executeCommand("setContext", CURRENT_FILE_RUNNABLE, isRunnable);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DebugCommands = DebugCommands;


/***/ }),

/***/ 7244:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditCommands = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(7220);
const terminals_1 = __webpack_require__(6368);
class EditCommands {
    constructor() {
        this.commands = [];
        this.commands.push(vs.commands.registerCommand("_dart.jumpToLineColInUri", this.jumpToLineColInUri, this), vs.commands.registerCommand("_dart.showCode", utils_1.showCode, this), vs.commands.registerCommand("dart.writeRecommendedSettings", this.writeRecommendedSettings, this), vs.commands.registerCommand("dart.printSelectionToTerminal", this.printSelectionToTerminal, this), vs.commands.registerCommand("dart.toggleDartdocComment", this.toggleDartdocomment, this));
    }
    jumpToLineColInUri(uri, lineNumber, columnNumber, inOtherEditorColumn) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || uri.scheme !== "file")
                return;
            // When navigating while using the inspector, we don't expect this file to replace
            // the inspector tab, so we always target a column that's showing an editor.
            const column = inOtherEditorColumn
                ? (0, utils_1.firstEditorColumn)() || vs.ViewColumn.Beside
                : vs.ViewColumn.Active;
            const doc = yield vs.workspace.openTextDocument(uri);
            const editor = yield vs.window.showTextDocument(doc, column, inOtherEditorColumn);
            if (lineNumber) {
                const line = doc.lineAt(lineNumber > 0 ? lineNumber - 1 : 0);
                if (!columnNumber || columnNumber > line.range.end.character)
                    columnNumber = line.firstNonWhitespaceCharacterIndex;
                const char = line.range.start.translate({ characterDelta: columnNumber });
                (0, utils_1.showCode)(editor, line.range, line.range, new vs.Range(char, char));
            }
        });
    }
    writeRecommendedSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            const topLevelConfig = vs.workspace.getConfiguration("", null);
            const dartLanguageConfig = topLevelConfig.inspect("[dart]");
            const existingConfig = dartLanguageConfig ? dartLanguageConfig.globalValue : undefined;
            const newValues = Object.assign({}, constants_1.dartRecommendedConfig, existingConfig);
            yield topLevelConfig.update("[dart]", newValues, vs.ConfigurationTarget.Global);
            const action = yield vs.window.showInformationMessage("Recommended settings were written to the [dart] section of your global settings file", constants_1.openSettingsAction);
            if (action === constants_1.openSettingsAction)
                yield vs.commands.executeCommand("workbench.action.openSettingsJson");
        });
    }
    printSelectionToTerminal() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vs.window.activeTextEditor;
            const selection = editor === null || editor === void 0 ? void 0 : editor.selection;
            const text = (_a = editor === null || editor === void 0 ? void 0 : editor.document) === null || _a === void 0 ? void 0 : _a.getText(selection);
            if (text) {
                (0, terminals_1.writeToPseudoTerminal)([text]);
            }
        });
    }
    toggleDartdocomment() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vs.window.activeTextEditor;
            if (!editor || !editor.selections.length)
                return;
            const document = editor.document;
            const selections = editor.selections;
            // Track the prefix that matches all lines in all selections.
            // If any line does not start with `///` then it cannot be TRIPLE.
            // If any line does not start with '//' then it cannot be DOUBLE.
            // We start from the highest and work down as we find lines that don't match.
            let commonPrefix = "TRIPLE";
            check: {
                for (const selection of selections) {
                    for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                        const line = document.lineAt(lineNumber);
                        // Skip over blank lines, as they won't have comment markers and shouldn't
                        // influence which common prefix we find.
                        if (line.isEmptyOrWhitespace)
                            continue;
                        const text = line.text.trim();
                        if (commonPrefix === "TRIPLE" && !text.startsWith("///"))
                            commonPrefix = text.startsWith("//") ? "DOUBLE" : "NONE";
                        else if (commonPrefix === "DOUBLE" && !text.startsWith("//"))
                            commonPrefix = "NONE";
                        // Any time we hit NONE, we can bail out.
                        if (commonPrefix === "NONE")
                            break check;
                    }
                }
            }
            switch (commonPrefix) {
                case "NONE":
                    // If no prefix, insert triples.
                    this.prefixLines(editor, selections, "/// ");
                    break;
                case "DOUBLE":
                    // If already double, just add the additional one slash.
                    this.prefixLines(editor, selections, "/");
                    break;
                case "TRIPLE":
                    // If already triple, remove slashes.
                    this.removeLinePrefixes(editor, selections, ["/// ", "///"]);
                    break;
            }
        });
    }
    prefixLines(editor, selections, prefix) {
        const document = editor.document;
        // In case we have overlapping selections, keep track of lines we've done.
        const doneLines = new Set();
        // Find the minimum indent, so we can insert all slashes at the same level even if
        // there is indented code.
        let minIndent;
        for (const selection of selections) {
            for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                const line = document.lineAt(lineNumber);
                if (line.isEmptyOrWhitespace)
                    continue;
                if (!minIndent || line.firstNonWhitespaceCharacterIndex < minIndent)
                    minIndent = line.firstNonWhitespaceCharacterIndex;
            }
        }
        editor.edit((edit) => {
            for (const selection of selections) {
                for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                    if (doneLines.has(lineNumber))
                        continue;
                    doneLines.add(lineNumber);
                    const line = document.lineAt(lineNumber);
                    if (line.isEmptyOrWhitespace)
                        continue;
                    const insertionPoint = line.range.start.translate(0, minIndent);
                    edit.insert(insertionPoint, prefix);
                }
            }
        });
    }
    removeLinePrefixes(editor, selections, prefixes) {
        const document = editor.document;
        // In case we have overlapping selections, keep track of lines we've done.
        const doneLines = new Set();
        editor.edit((edit) => {
            for (const selection of selections) {
                for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                    if (doneLines.has(lineNumber))
                        continue;
                    doneLines.add(lineNumber);
                    const line = document.lineAt(lineNumber);
                    if (line.isEmptyOrWhitespace)
                        continue;
                    const lineContentStart = line.range.start.translate(0, line.firstNonWhitespaceCharacterIndex);
                    for (const prefix of prefixes) {
                        const possiblePrefixRange = new vs.Range(lineContentStart, lineContentStart.translate(0, prefix.length));
                        const possiblePrefix = document.getText(possiblePrefixRange);
                        if (possiblePrefix === prefix) {
                            edit.delete(possiblePrefixRange);
                            break;
                        }
                    }
                }
            }
        });
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
}
exports.EditCommands = EditCommands;


/***/ }),

/***/ 7511:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasOverlappingEdits = exports.DasEditCommands = void 0;
const fs = __webpack_require__(7147);
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const editors = __webpack_require__(8805);
class DasEditCommands {
    constructor(logger, context, analyzer) {
        this.logger = logger;
        this.context = context;
        this.analyzer = analyzer;
        this.commands = [];
        this.commands.push(vs.commands.registerCommand("_dart.organizeImports", this.organizeImports, this), vs.commands.registerCommand("dart.sortMembers", this.sortMembers, this), vs.commands.registerCommand("_dart.applySourceChange", this.applyEdits, this), vs.commands.registerCommand("dart.completeStatement", this.completeStatement, this));
    }
    getActiveDoc() {
        return vs.window.activeTextEditor && vs.window.activeTextEditor.document;
    }
    organizeImports(document) {
        document = document || this.getActiveDoc();
        return this.sendEdit(this.analyzer.editOrganizeDirectives, "Organize Imports", document);
    }
    sortMembers(document) {
        document = document || this.getActiveDoc();
        return this.sendEdit(this.analyzer.editSortMembers, "Sort Members", document);
    }
    completeStatement() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vs.window.activeTextEditor;
            if (!editor || !editor.selection || !this.analyzer.capabilities.hasCompleteStatementFix)
                return;
            const document = editor.document;
            const file = (0, fs_1.fsPath)(document.uri);
            const offset = document.offsetAt(editor.selection.end);
            const res = yield this.analyzer.editGetStatementCompletion({ file, offset });
            if (res && res.change)
                yield this.applyEdits(document, res.change);
        });
    }
    sendEdit(f, commandName, document) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!document || !editors.isDartDocument(document)) {
                vs.window.showWarningMessage("Not a Dart file.");
                return;
            }
            const originalDocumentVersion = document.version;
            f = f.bind(this.analyzer); // Yay JavaScript!
            try {
                const response = yield f({ file: (0, fs_1.fsPath)(document.uri) });
                const edit = response.edit;
                if (edit.edits.length === 0)
                    return;
                if (document.isClosed) {
                    vs.window.showErrorMessage(`Error running ${commandName}: Document has been closed.`);
                    return;
                }
                if (document.version !== originalDocumentVersion) {
                    vs.window.showErrorMessage(`Error running ${commandName}: Document has been modified.`);
                    return;
                }
                const editBuilder = new vs.WorkspaceEdit();
                edit.edits.forEach((edit) => {
                    const range = new vs.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length));
                    editBuilder.replace(document.uri, range, edit.replacement);
                });
                yield vs.workspace.applyEdit(editBuilder);
            }
            catch (error) {
                vs.window.showErrorMessage(`Error running ${commandName}: ${(0, utils_1.errorString)(error)}.`);
            }
        });
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
    applyEdits(initiatingDocument, change) {
        return __awaiter(this, void 0, void 0, function* () {
            // We can only apply with snippets if there's a single change.
            if (change.edits.length === 1 && change.linkedEditGroups && change.linkedEditGroups.length !== 0)
                return this.applyEditsWithSnippets(initiatingDocument, change);
            // VS Code expects offsets to be based on the original document, but the analysis server provides
            // them assuming all previous edits have already been made. This means if the server provides us a
            // set of edits where any edits offset is *equal to or greater than* a previous edit, it will do the wrong thing.
            // If this happens; we will fall back to sequential edits and write a warning.
            const hasProblematicEdits = hasOverlappingEdits(change);
            if (hasProblematicEdits) {
                this.logger.warn("Falling back to sequential edits due to overlapping edits in server.");
            }
            const applyEditsSequentially = hasProblematicEdits;
            // Otherwise, just make all the edits without the snippets.
            let changes = applyEditsSequentially ? undefined : new vs.WorkspaceEdit();
            for (const edit of change.edits) {
                const uri = vs.Uri.file(edit.file);
                // We can only create files with edits that are at 0/0 because we can't open the document if it doesn't exist.
                // If we create the file ourselves, it won't go into the single undo buffer.
                if (!fs.existsSync(edit.file) && edit.edits.find((e) => e.offset !== 0 || e.length !== 0)) {
                    this.logger.error(`Unable to edit file ${edit.file} because it does not exist and had an edit that was not the start of the file`);
                    vs.window.showErrorMessage(`Unable to edit file ${edit.file} because it does not exist and had an edit that was not the start of the file`);
                    continue;
                }
                const document = fs.existsSync(edit.file) ? yield vs.workspace.openTextDocument(uri) : undefined;
                if (changes)
                    changes.createFile(uri, { ignoreIfExists: true });
                for (const e of edit.edits) {
                    if (!changes) {
                        changes = new vs.WorkspaceEdit();
                        changes.createFile(uri, { ignoreIfExists: true });
                    }
                    const range = document
                        ? new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length))
                        : new vs.Range(new vs.Position(0, 0), new vs.Position(0, 0));
                    changes.replace(uri, range, e.replacement);
                    if (applyEditsSequentially) {
                        yield vs.workspace.applyEdit(changes);
                        changes = undefined;
                    }
                }
            }
            // If we weren't applying sequentially
            if (changes)
                yield vs.workspace.applyEdit(changes);
            // Set the cursor position.
            if (change.selection) {
                const uri = vs.Uri.file(change.selection.file);
                const document = yield vs.workspace.openTextDocument(uri);
                const editor = yield vs.window.showTextDocument(document);
                const pos = document.positionAt(change.selection.offset);
                const selection = new vs.Selection(pos, pos);
                editor.selection = selection;
            }
        });
    }
    applyEditsWithSnippets(initiatingDocument, change) {
        return __awaiter(this, void 0, void 0, function* () {
            const edit = change.edits[0];
            const document = yield vs.workspace.openTextDocument(edit.file);
            const editor = yield vs.window.showTextDocument(document);
            // Apply of all of the edits.
            yield editor.edit((eb) => {
                edit.edits.forEach((e) => {
                    eb.replace(new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length)), e.replacement);
                });
            });
            const documentText = editor.document.getText();
            // Create a list of all the placeholders.
            const placeholders = [];
            let placeholderNumber = 1;
            change.linkedEditGroups.forEach((leg) => {
                leg.positions.forEach((pos) => {
                    const defaultValue = documentText.substr(pos.offset, leg.length);
                    let choices = leg.suggestions ? leg.suggestions.map((s) => s.value) : undefined;
                    if (defaultValue && choices && choices.indexOf(defaultValue) === -1) {
                        choices = [defaultValue, ...choices];
                    }
                    placeholders.push({ offset: pos.offset, length: leg.length, defaultValue, choices, placeholderNumber });
                });
                placeholderNumber++;
            });
            // Ensure they're in offset order so the next maths works!
            placeholders.sort((p1, p2) => p1.offset - p2.offset);
            const snippet = new vs.SnippetString();
            const firstPlaceholder = placeholders[0];
            const lastPlaceholder = placeholders[placeholders.length - 1];
            const startPos = firstPlaceholder.offset;
            const endPos = lastPlaceholder.offset + lastPlaceholder.length;
            let currentPos = startPos;
            placeholders.forEach((p) => {
                // Add the text from where we last were up to current placeholder.
                if (currentPos !== p.offset)
                    snippet.appendText(documentText.substring(currentPos, p.offset));
                // Add the choices / placeholder.
                if (p.choices && p.choices.length > 1)
                    // TODO: Change this back to appendChoice when it handles commas correctly
                    // https://github.com/microsoft/vscode/issues/107220
                    // snippet.appendChoice(p.choices, p.placeholderNumber);
                    snippet.value += "${" + p.placeholderNumber.toString() + "|" + p.choices.map((c) => this.snippetStringEscape(c)).join(",") + "|}";
                else
                    snippet.appendPlaceholder(p.defaultValue, p.placeholderNumber);
                currentPos = p.offset + p.length;
            });
            // Replace the document.
            yield editor.insertSnippet(snippet, new vs.Range(document.positionAt(startPos), document.positionAt(endPos)));
            // Ensure original document is the active one.
            yield vs.window.showTextDocument(initiatingDocument);
        });
    }
    snippetStringEscape(value) {
        return value.replace(/\$|}|\\|,/g, "\\$&");
    }
}
exports.DasEditCommands = DasEditCommands;
function hasOverlappingEdits(change) {
    const priorEdits = {};
    for (const edit of change.edits) {
        if (!priorEdits[edit.file])
            priorEdits[edit.file] = [];
        for (const e of edit.edits) {
            if (priorEdits[edit.file].find((pe) => pe.offset <= e.offset))
                return true;
            priorEdits[edit.file].push(e);
        }
    }
    return false;
}
exports.hasOverlappingEdits = hasOverlappingEdits;


/***/ }),

/***/ 6039:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspEditCommands = void 0;
const vs = __webpack_require__(9496);
const vscode_languageclient_1 = __webpack_require__(2850);
class LspEditCommands {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.commands = [];
        this.commands.push(vs.commands.registerCommand("dart.sortMembers", () => this.runCodeAction("source.sortMembers")));
        // TODO: Enable this when https://github.com/dart-lang/sdk/issues/33521
        // is resolved.
        // this.commands.push(
        // 	vs.commands.registerCommand("dart.completeStatement", this.completeStatement, this),
        // );
    }
    runCodeAction(action) {
        return __awaiter(this, void 0, void 0, function* () {
            return vs.commands.executeCommand("editor.action.codeAction", { kind: action, apply: "ifSingle" });
        });
    }
    completeStatement() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vs.window.activeTextEditor;
            if (!editor || !editor.selection)
                return;
            const edit = yield this.analyzer.completeStatement({
                position: this.analyzer.client.code2ProtocolConverter.asPosition(editor.selection.start),
                textDocument: this.analyzer.client.code2ProtocolConverter.asVersionedTextDocumentIdentifier(editor.document),
            });
            if (edit) {
                if (yield this.validDocumentVersionsStillMatch(edit)) {
                    const codeEdit = this.analyzer.client.protocol2CodeConverter.asWorkspaceEdit(edit);
                    if (!(yield vs.workspace.applyEdit(codeEdit))) {
                        vs.window.showErrorMessage("VS Code failed to apply edits");
                    }
                }
                else {
                    vs.window.showErrorMessage("Documents have been modified so edits could not be applied");
                }
            }
        });
    }
    validDocumentVersionsStillMatch(edit) {
        return __awaiter(this, void 0, void 0, function* () {
            // If the edit didn't have any documentChanges (it has changes) we have
            // to assume it's all up-to-date.
            if (!edit.documentChanges)
                return true;
            const openTextDocuments = new Map();
            vs.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
            for (const change of edit.documentChanges) {
                if (vscode_languageclient_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    if (vscode_languageclient_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                        const textDocument = openTextDocuments.get(change.textDocument.uri);
                        if (textDocument && textDocument.version !== change.textDocument.version) {
                            return false;
                        }
                    }
                }
            }
            return true;
        });
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
}
exports.LspEditCommands = LspEditCommands;


/***/ }),

/***/ 2364:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterCommands = void 0;
const fs = __webpack_require__(7147);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(7068);
const constants_1 = __webpack_require__(5628);
const array_1 = __webpack_require__(7434);
const dartdocs_1 = __webpack_require__(9439);
const fs_1 = __webpack_require__(300);
const projects_1 = __webpack_require__(3953);
const flutter_samples_1 = __webpack_require__(3150);
const config_1 = __webpack_require__(4165);
const flutter_docs_snippets_1 = __webpack_require__(8137);
const util = __webpack_require__(8779);
const input_1 = __webpack_require__(9662);
const projects_2 = __webpack_require__(6417);
const sdk_1 = __webpack_require__(997);
class FlutterCommands extends sdk_1.BaseSdkCommands {
    constructor(logger, context, workspace, sdkUtils, dartCapabilities, flutterCapabilities, deviceManager) {
        super(logger, context, workspace, dartCapabilities);
        this.sdkUtils = sdkUtils;
        this.flutterCapabilities = flutterCapabilities;
        this.deviceManager = deviceManager;
        this.disposables.push(vs.commands.registerCommand("flutter.clean", this.flutterClean, this));
        this.disposables.push(vs.commands.registerCommand("_flutter.screenshot.touchBar", (args) => vs.commands.executeCommand("flutter.screenshot", args)));
        this.disposables.push(vs.commands.registerCommand("flutter.screenshot", this.flutterScreenshot, this));
        this.disposables.push(vs.commands.registerCommand("flutter.doctor", this.flutterDoctor, this));
        this.disposables.push(vs.commands.registerCommand("flutter.upgrade", this.flutterUpgrade, this));
        this.disposables.push(vs.commands.registerCommand("flutter.createProject", this.createFlutterProject, this));
        this.disposables.push(vs.commands.registerCommand("_dart.flutter.createSampleProject", this.createFlutterSampleProject, this));
        this.disposables.push(vs.commands.registerCommand("_flutter.create", this.flutterCreate, this));
        this.disposables.push(vs.commands.registerCommand("_flutter.clean", this.flutterClean, this));
    }
    flutterClean(selection) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!selection) {
                const path = yield (0, projects_2.getFolderToRunCommandIn)(this.logger, `Select the folder to run "flutter clean" in`, selection, true);
                if (!path)
                    return;
                selection = vs.Uri.file(path);
            }
            return this.runFlutter(["clean"], selection);
        });
    }
    flutterScreenshot() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            let shouldNotify = false;
            // If there is no path for this session, or it differs from config, use the one from config.
            if (!this.flutterScreenshotPath ||
                (config_1.config.flutterScreenshotPath && this.flutterScreenshotPath !== config_1.config.flutterScreenshotPath)) {
                this.flutterScreenshotPath = config_1.config.flutterScreenshotPath;
                shouldNotify = true;
            }
            // If path is still empty, bring up the folder selector.
            if (!this.flutterScreenshotPath) {
                const selectedFolder = yield vs.window.showOpenDialog({ canSelectFolders: true, openLabel: "Set screenshots folder" });
                if (selectedFolder && selectedFolder.length > 0) {
                    // Set variable to selected path. This allows prompting the user only once.
                    this.flutterScreenshotPath = selectedFolder[0].path;
                    shouldNotify = true;
                }
                else {
                    // Do nothing if the user cancelled the folder selection.
                    return;
                }
            }
            // Ensure folder exists.
            (0, fs_1.mkDirRecursive)(this.flutterScreenshotPath);
            const debugSession = vs.debug.activeDebugSession;
            if (!debugSession) {
                vs.window.showErrorMessage("You must have an active Flutter debug session to take screenshots");
                return;
            }
            if (debugSession.type !== "dart") {
                vs.window.showErrorMessage("The active debug session is not a Flutter app");
                return;
            }
            const projectFolder = debugSession.configuration.cwd;
            const deviceId = (_a = debugSession.configuration.deviceId) !== null && _a !== void 0 ? _a : (_c = (_b = this.deviceManager) === null || _b === void 0 ? void 0 : _b.currentDevice) === null || _c === void 0 ? void 0 : _c.id;
            const outputFilename = (0, fs_1.nextAvailableFilename)(this.flutterScreenshotPath, "flutter_", ".png");
            const args = ["screenshot"];
            if (deviceId) {
                args.push("-d");
                args.push(deviceId);
            }
            args.push("-o");
            args.push(path.join(this.flutterScreenshotPath, outputFilename));
            yield this.runFlutterInFolder(projectFolder, args, "screenshot");
            if (shouldNotify) {
                const res = yield vs.window.showInformationMessage(`Screenshots will be saved to ${this.flutterScreenshotPath}`, "Show Folder");
                if (res)
                    yield vs.commands.executeCommand("revealFileInOS", vs.Uri.file(this.flutterScreenshotPath));
            }
        });
    }
    flutterDoctor() {
        var _a;
        if (!this.workspace.sdks.flutter) {
            this.sdkUtils.showFlutterActivationFailure("flutter.doctor");
            return;
        }
        const tempDir = path.join(os.tmpdir(), "dart-code-cmd-run");
        if (!fs.existsSync(tempDir))
            fs.mkdirSync(tempDir);
        return this.runFlutterInFolder(tempDir, ["doctor", "-v"], "flutter", true, (_a = this.workspace.config) === null || _a === void 0 ? void 0 : _a.flutterDoctorScript);
    }
    flutterUpgrade() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.workspace.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("flutter.upgrade");
                return;
            }
            const tempDir = path.join(os.tmpdir(), "dart-code-cmd-run");
            if (!fs.existsSync(tempDir))
                fs.mkdirSync(tempDir);
            // Don't prompt to reload when the version changes, as we automatically reload here.
            sdk_1.commandState.promptToReloadOnVersionChanges = false;
            yield this.runFlutterInFolder(tempDir, ["upgrade"], "flutter", true);
            yield util.promptToReloadExtension();
        });
    }
    flutterCreate({ projectName, projectPath, triggerData, platform }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!projectPath) {
                projectPath = yield (0, projects_2.getFolderToRunCommandIn)(this.logger, `Select the folder to run "flutter create" in`, undefined, true);
                if (!projectPath)
                    return;
            }
            const args = ["create"];
            if (config_1.config.flutterCreateOffline) {
                args.push("--offline");
            }
            if (platform) {
                args.push("--platforms");
                args.push(platform);
            }
            if (projectName) {
                args.push("--project-name");
                args.push(projectName);
            }
            if (config_1.config.flutterCreateOrganization) {
                args.push("--org");
                args.push(config_1.config.flutterCreateOrganization);
            }
            if (config_1.config.flutterCreateIOSLanguage && config_1.config.flutterCreateIOSLanguage !== "swift") {
                args.push("--ios-language");
                args.push(config_1.config.flutterCreateIOSLanguage);
            }
            if (config_1.config.flutterCreateAndroidLanguage && config_1.config.flutterCreateAndroidLanguage !== "kotlin") {
                args.push("--android-language");
                args.push(config_1.config.flutterCreateAndroidLanguage);
            }
            if (triggerData === null || triggerData === void 0 ? void 0 : triggerData.sample) {
                args.push("--sample");
                args.push(triggerData.sample);
                args.push("--overwrite");
            }
            if (triggerData === null || triggerData === void 0 ? void 0 : triggerData.template) {
                args.push("--template");
                args.push(triggerData.template);
                args.push("--overwrite");
            }
            args.push(".");
            const exitCode = yield this.runFlutterInFolder(projectPath, args, projectName);
            if (!vscode_1.vsCodeVersion.supportsDebugWithoutLaunchJson) {
                this.writeDefaultLaunchJson(projectPath);
            }
            return exitCode;
        });
    }
    writeDefaultLaunchJson(projectPath) {
        const launchJsonFolder = path.join(projectPath, vscode_1.vsCodeVersion.editorConfigFolder);
        const launchJsonFile = path.join(launchJsonFolder, "launch.json");
        if (!fs.existsSync(launchJsonFile)) {
            (0, fs_1.mkDirRecursive)(launchJsonFolder);
            fs.writeFileSync(launchJsonFile, constants_1.defaultLaunchJson);
        }
    }
    getFlutterTemplates() {
        const templates = [
            {
                detail: "Generate a Flutter application.",
                label: "Application",
                template: { id: "app" },
            },
            {
                detail: "Generate a project to add a Flutter module to an existing Android or iOS application.",
                label: "Module",
                template: { id: "module" },
            },
            {
                detail: "Generate a shareable Flutter project containing modular Dart code.",
                label: "Package",
                template: { id: "package" },
            },
            {
                detail: "Generate a shareable Flutter project containing an API in Dart code with a platform-specific implementation for Android, for iOS code, or for both.",
                label: "Plugin",
                template: { id: "plugin" },
            },
        ];
        if (this.flutterCapabilities.supportsCreateSkeleton) {
            templates.push({
                detail: "Generate a List View / Detail View Flutter application that follows community best practices.",
                label: "Skeleton",
                template: { id: "skeleton" },
            });
        }
        return templates;
    }
    createFlutterProject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sdks || !this.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("flutter.createProject");
                return;
            }
            const pickItems = this.getFlutterTemplates();
            const selectedTemplate = yield vs.window.showQuickPick(pickItems, {
                matchOnDescription: true,
                placeHolder: "Which Flutter template?",
            });
            if (!selectedTemplate)
                return;
            return this.createFlutterProjectForTemplate(selectedTemplate.template.id);
        });
    }
    createFlutterProjectForTemplate(template) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sdks || !this.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("flutter.createProject");
                return;
            }
            // If already in a workspace, set the default folder to something nearby.
            const folders = yield vs.window.showOpenDialog({
                canSelectFolders: true,
                defaultUri: this.context.lastUsedNewProjectPath ? vs.Uri.file(this.context.lastUsedNewProjectPath) : undefined,
                openLabel: "Select a folder to create the project in",
            });
            if (!folders || folders.length !== 1)
                return;
            const folderPath = (0, fs_1.fsPath)(folders[0]);
            this.context.lastUsedNewProjectPath = folderPath;
            const defaultName = (0, fs_1.nextAvailableFilename)(folderPath, "flutter_application_");
            const name = yield this.promptForNameWithSettings(defaultName, folderPath);
            if (!name)
                return;
            const projectFolderUri = vs.Uri.file(path.join(folderPath, name));
            const projectFolderPath = (0, fs_1.fsPath)(projectFolderUri);
            if (fs.existsSync(projectFolderPath)) {
                vs.window.showErrorMessage(`A folder named ${name} already exists in ${folderPath}`);
                return;
            }
            // Create the empty folder so we can open it.
            fs.mkdirSync(projectFolderPath);
            const triggerData = template ? { template } : undefined;
            (0, projects_1.writeFlutterTriggerFile)(projectFolderPath, triggerData);
            // If we're using a custom SDK, we need to apply it to the new project too.
            if (config_1.config.workspaceFlutterSdkPath)
                (0, projects_1.writeFlutterSdkSettingIntoProject)(config_1.config.workspaceFlutterSdkPath, projectFolderPath);
            vs.commands.executeCommand("vscode.openFolder", projectFolderUri);
            return projectFolderUri;
        });
    }
    promptForNameWithSettings(defaultName, folderPath) {
        return __awaiter(this, void 0, void 0, function* () {
            while (true) {
                const response = yield (0, input_1.showInputBoxWithSettings)(this.context, {
                    placeholder: defaultName,
                    prompt: "Enter a name for your new project",
                    title: "Project Name",
                    validation: (s) => this.validateFlutterProjectName(s, folderPath),
                    value: defaultName,
                });
                if (response === "SETTINGS") {
                    yield (0, input_1.showSimpleSettingsEditor)("Settings for new Flutter projects", "Select a setting to change (or 'Escape' to cancel)", flutterCreateSettings);
                    continue;
                }
                else if (response) {
                    return response.value;
                }
                else {
                    return undefined;
                }
            }
        });
    }
    createFlutterSampleProject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sdks || !this.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("_dart.flutter.createSampleProject");
                return;
            }
            // Fetch the JSON for the available samples.
            let snippets;
            try {
                snippets = yield (0, flutter_docs_snippets_1.getFlutterSnippets)(this.logger, this.sdks, this.flutterCapabilities);
            }
            catch (_a) {
                vs.window.showErrorMessage("Unable to retrieve Flutter documentation snippets");
                return;
            }
            const sortedSnippets = (0, array_1.sortBy)(snippets, (s) => s.element);
            const selectedSnippet = yield vs.window.showQuickPick(sortedSnippets.map((s) => ({
                description: `${s.package}/${s.library}`,
                detail: (0, dartdocs_1.stripMarkdown)(s.description),
                label: s.element,
                snippet: s,
            })), {
                matchOnDescription: true,
                placeHolder: "Which Flutter sample?",
            });
            if (!selectedSnippet)
                return;
            return (0, flutter_samples_1.createFlutterSampleInTempFolder)(this.flutterCapabilities, selectedSnippet.snippet.id, config_1.config.workspaceFlutterSdkPath);
        });
    }
    validateFlutterProjectName(input, folderDir) {
        if (!sdk_1.packageNameRegex.test(input))
            return "Flutter project names should be all lowercase, with underscores to separate words";
        const bannedNames = ["flutter", "flutter_test", "test", "integration_test"];
        if (bannedNames.includes(input))
            return `You may not use ${input} as the name for a flutter project`;
        if (fs.existsSync(path.join(folderDir, input)))
            return `A project with this name already exists within the selected directory`;
    }
}
exports.FlutterCommands = FlutterCommands;
const flutterCreateSettings = [
    {
        currentValue: config_1.config.flutterCreateOrganization || "com.example",
        description: config_1.config.flutterCreateOrganization || "com.example",
        detail: "The organization responsible for your new Flutter project, in reverse domain name notation. This string is used in Java package names and as prefix in the iOS bundle identifier.",
        label: "Organization",
        setValue: (newValue) => config_1.config.setFlutterCreateOrganization(newValue),
        settingKind: "STRING",
    },
    {
        currentValue: config_1.config.flutterCreateAndroidLanguage || "kotlin",
        description: config_1.config.flutterCreateAndroidLanguage || "kotlin",
        detail: "The language to use for Android-specific code, either Java (legacy) or Kotlin (recommended).",
        enumValues: ["kotlin", "java"],
        label: "Android Language",
        setValue: (newValue) => config_1.config.setFlutterCreateAndroidLanguage(newValue),
        settingKind: "ENUM",
    },
    {
        currentValue: config_1.config.flutterCreateIOSLanguage || "swift",
        description: config_1.config.flutterCreateIOSLanguage || "swift",
        detail: "The language to use for iOS-specific code, either ObjectiveC (legacy) or Swift (recommended).",
        enumValues: ["swift", "objc"],
        label: "iOS Language",
        setValue: (newValue) => config_1.config.setFlutterCreateIOSLanguage(newValue),
        settingKind: "ENUM",
    },
    {
        currentValue: config_1.config.flutterCreateOffline ? "enabled" : "not enabled",
        description: config_1.config.flutterCreateOffline ? "enabled" : "not enabled",
        detail: "When \"flutter pub get\" is run by the create command, this indicates whether to run it in offline mode or not. In offline mode, it will need to have all dependencies already available in the pub cache to succeed.",
        label: "Create Projects Offline",
        setValue: (newValue) => config_1.config.setFlutterCreateOffline(newValue),
        settingKind: "BOOL",
    },
];


/***/ }),

/***/ 9021:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterOutlineCommands = exports.flutterOutlineCommands = void 0;
const vs = __webpack_require__(9496);
exports.flutterOutlineCommands = [
    "refactor.flutter.wrap.center",
    "refactor.flutter.wrap.padding",
    "refactor.flutter.wrap.column",
    "refactor.flutter.move.up",
    "refactor.flutter.move.down",
    "refactor.flutter.removeWidget",
];
class FlutterOutlineCommands {
    constructor(tree, context) {
        this.tree = tree;
        for (const id of exports.flutterOutlineCommands) {
            context.subscriptions.push(vs.commands.registerCommand("_flutter.outline." + id, () => this.applyRefactoring(id)));
        }
    }
    applyRefactoring(refactorType) {
        if (!this.tree.selection || this.tree.selection.length !== 1) {
            console.error(`Invalid selection when running Flutter Outline refactor: ${refactorType}`);
            return;
        }
        const widget = this.tree.selection[0];
        const fix = widget.fixes.filter((f) => f.command).find((f) => f.kind && f.kind.value.endsWith(refactorType));
        if (fix) {
            if (fix.command && fix.command.arguments)
                vs.commands.executeCommand(fix.command.command, ...fix.command.arguments);
            else
                console.error(`Flutter Outline fix was missing command/arguments`);
        }
        else {
            console.error(`Unable to find command for Flutter Outline: ${refactorType}`);
        }
    }
}
exports.FlutterOutlineCommands = FlutterOutlineCommands;


/***/ }),

/***/ 1471:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToSuperCommand = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const editors = __webpack_require__(8805);
const outline_1 = __webpack_require__(7104);
class GoToSuperCommand {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.goToSuper", this.goToSuper, this));
    }
    goToSuper() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = editors.getActiveDartEditor();
            if (!editor) {
                vs.window.showWarningMessage("No active Dart editor.");
                return;
            }
            const document = editor.document;
            const position = editor.selection.start;
            const outlineNode = (0, outline_1.findNearestOutlineNode)(this.analyzer.fileTracker, document, position);
            const offset = outlineNode && outlineNode.element && outlineNode.element.location
                ? outlineNode.element.location.offset
                : document.offsetAt(position);
            const hierarchy = yield this.analyzer.client.searchGetTypeHierarchy({
                file: (0, fs_1.fsPath)(document.uri),
                offset,
                superOnly: true,
            });
            if (!hierarchy || !hierarchy.hierarchyItems || !hierarchy.hierarchyItems.length || hierarchy.hierarchyItems.length === 1)
                return;
            // The first item is the current node, so skip that one and walk up till we find a matching member.
            const isClass = !hierarchy.hierarchyItems[0].memberElement;
            const item = hierarchy.hierarchyItems.slice(1).find((h) => isClass ? !!h.classElement : !!h.memberElement);
            const element = isClass ? item && item.classElement : item && item.memberElement;
            if (!element || !element.location)
                return;
            const elementDocument = yield vs.workspace.openTextDocument(element.location.file);
            const elementEditor = yield vs.window.showTextDocument(elementDocument);
            const range = (0, utils_2.toRangeOnLine)(element.location);
            (0, utils_2.showCode)(elementEditor, range, range, range);
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.GoToSuperCommand = GoToSuperCommand;


/***/ }),

/***/ 9475:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggingCommands = exports.isLogging = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
const utils_2 = __webpack_require__(8779);
const log_1 = __webpack_require__(8202);
exports.isLogging = false;
class LoggingCommands {
    constructor(logger, extensionLogPath) {
        this.logger = logger;
        this.extensionLogPath = extensionLogPath;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.startLogging", this.startLoggingViaPicker, this), vs.commands.registerCommand("dart.startLoggingDebugging", this.startLoggingDebugging, this), vs.commands.registerCommand("dart.startLoggingAnalysisServer", this.startLoggingAnalysisServer, this), vs.commands.registerCommand("dart.startLoggingExtensionOnly", this.startLoggingExtensionOnly, this), vs.commands.registerCommand("dart.openExtensionLog", this.openExtensionLog, this), vs.commands.registerCommand("dart.stopLogging", this.stopLogging, this));
    }
    startLoggingViaPicker() {
        return __awaiter(this, void 0, void 0, function* () {
            const selectedLogCategories = yield vs.window.showQuickPick(Object.keys(log_1.userSelectableLogCategories).map((k) => ({
                label: k,
                logCategory: log_1.userSelectableLogCategories[k],
                picked: true,
            })), {
                canPickMany: true,
                placeHolder: "Select which categories to include in the log",
            });
            if (!selectedLogCategories || !selectedLogCategories.length)
                return;
            return this.startLogging(selectedLogCategories.map((s) => s.logCategory));
        });
    }
    startLoggingDebugging() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.startLogging(log_1.debuggingLogCategories);
        });
    }
    startLoggingAnalysisServer() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.startLogging(log_1.analysisServerLogCategories);
        });
    }
    startLoggingExtensionOnly() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.startLogging(log_1.extensionsLogCategories);
        });
    }
    startLogging(categoriesToLog) {
        return __awaiter(this, void 0, void 0, function* () {
            const logFilename = path.join((0, fs_1.forceWindowsDriveLetterToUppercase)(this.extensionLogPath), this.generateFilename());
            const logUri = vs.Uri.file(logFilename);
            (0, utils_2.createFolderForFile)(logFilename);
            const allLoggedCategories = [enums_1.LogCategory.General].concat(categoriesToLog);
            const logger = (0, logging_1.captureLogs)(this.logger, (0, fs_1.fsPath)(logUri), (0, log_1.getLogHeader)(), config_1.config.maxLogLineLength, allLoggedCategories);
            exports.isLogging = true;
            this.disposables.push(logger);
            vs.commands.executeCommand("setContext", constants_1.DART_IS_CAPTURING_LOGS_CONTEXT, true);
            const completer = new utils_1.PromiseCompleter();
            this.currentLogCompleter = completer;
            yield vs.window.withProgress({
                cancellable: true,
                location: vs.ProgressLocation.Notification,
                title: `Dart and Flutter logs are being captured. Reproduce your issue then click Cancel.`,
            }, (_, token) => {
                token.onCancellationRequested(() => completer.resolve());
                return completer.promise;
            });
            exports.isLogging = false;
            yield logger.dispose();
            const doc = yield vs.workspace.openTextDocument(logUri);
            yield vs.window.showTextDocument(doc);
            return logFilename;
        });
    }
    openExtensionLog() {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield vs.workspace.openTextDocument(vs.Uri.file((0, log_1.getExtensionLogPath)()));
            yield vs.window.showTextDocument(doc);
        });
    }
    stopLogging() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentLogCompleter)
                this.currentLogCompleter.resolve();
        });
    }
    generateFilename() {
        const pad = (s) => `0${s.toString()}`.slice(-2);
        const now = new Date();
        const formattedDate = `${now.getFullYear()}-${pad(now.getMonth())}-${pad(now.getDay())} ${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
        return `Dart-Code-Log-${formattedDate}.txt`;
    }
    dispose() {
        for (const command of this.disposables)
            command.dispose();
    }
}
exports.LoggingCommands = LoggingCommands;


/***/ }),

/***/ 7809:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpenInOtherEditorCommands = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const fs_1 = __webpack_require__(300);
const misc_1 = __webpack_require__(9106);
const processes_1 = __webpack_require__(5430);
class OpenInOtherEditorCommands {
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("flutter.openInAndroidStudio", this.openInAndroidStudio, this), vs.commands.registerCommand("flutter.openInXcode", this.openInXcode, this));
    }
    openInAndroidStudio(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = (0, fs_1.fsPath)(resource);
            let androidStudioDir = yield this.getAndroidStudioDir(folder);
            if (!androidStudioDir) {
                vs.window.showErrorMessage("Unable to find Android Studio");
                return;
            }
            if (constants_1.isMac && androidStudioDir.endsWith("/Contents")) {
                androidStudioDir = androidStudioDir.substr(0, androidStudioDir.length - "/Contents".length);
                (0, processes_1.safeToolSpawn)(folder, "open", ["-a", androidStudioDir, folder]);
                return;
            }
            else {
                for (const androidStudioPath of constants_1.androidStudioPaths) {
                    const fullPath = path.join(androidStudioDir, androidStudioPath);
                    if (fs.existsSync(fullPath)) {
                        (0, processes_1.safeToolSpawn)(folder, fullPath, [folder]);
                        return;
                    }
                }
            }
            vs.window.showErrorMessage("Unable to locate Android Studio executable");
        });
    }
    openInXcode(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = (0, fs_1.fsPath)(resource);
            const files = fs
                .readdirSync(folder, { withFileTypes: true })
                .filter((item) => item.isDirectory())
                .filter((item) => item.name.endsWith(".xcworkspace") || item.name.endsWith(".xcodeproj"))
                .sort((f1, f2) => f1.name.endsWith(".xcworkspace") ? -1 : 1);
            if (!files || !files.length) {
                vs.window.showErrorMessage(`Unable to find an Xcode project in your 'ios' folder`);
                return;
            }
            const file = path.join(folder, files[0].name);
            (0, processes_1.safeToolSpawn)(folder, "open", [file]);
        });
    }
    getAndroidStudioDir(folder) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, misc_1.getFlutterConfigValue)(this.logger, this.sdks.flutter, folder, "android-studio-dir");
        });
    }
    dispose() {
        for (const command of this.disposables)
            command.dispose();
    }
}
exports.OpenInOtherEditorCommands = OpenInOtherEditorCommands;


/***/ }),

/***/ 8128:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageCommands = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const pub_1 = __webpack_require__(8376);
const util = __webpack_require__(8779);
const projects_1 = __webpack_require__(6417);
const sdk_1 = __webpack_require__(997);
let isFetchingPackages = false;
let runPubGetDelayTimer;
let lastPubspecSaveReason;
class PackageCommands extends sdk_1.BaseSdkCommands {
    constructor(logger, context, workspace, dartCapabilities) {
        super(logger, context, workspace, dartCapabilities);
        this.disposables.push(vs.commands.registerCommand("dart.getPackages", this.getPackages, this));
        this.disposables.push(vs.commands.registerCommand("dart.listOutdatedPackages", this.listOutdatedPackages, this));
        this.disposables.push(vs.commands.registerCommand("dart.upgradePackages", this.upgradePackages, this));
        this.disposables.push(vs.commands.registerCommand("dart.upgradePackages.majorVersions", this.upgradePackagesMajorVersions, this));
        // Pub commands.
        this.disposables.push(vs.commands.registerCommand("pub.get", (selection) => vs.commands.executeCommand("dart.getPackages", selection)));
        this.disposables.push(vs.commands.registerCommand("pub.upgrade", (selection) => vs.commands.executeCommand("dart.upgradePackages", selection)));
        this.disposables.push(vs.commands.registerCommand("pub.upgrade.majorVersions", (selection) => vs.commands.executeCommand("dart.upgradePackages.majorVersions", selection)));
        this.disposables.push(vs.commands.registerCommand("pub.outdated", (selection) => vs.commands.executeCommand("dart.listOutdatedPackages", selection)));
        // Flutter commands.
        this.disposables.push(vs.commands.registerCommand("flutter.packages.get", (selection) => vs.commands.executeCommand("dart.getPackages", selection)));
        this.disposables.push(vs.commands.registerCommand("flutter.packages.upgrade", (selection) => vs.commands.executeCommand("dart.upgradePackages", selection)));
        this.disposables.push(vs.commands.registerCommand("flutter.packages.upgrade.majorVersions", (selection) => vs.commands.executeCommand("dart.upgradePackages.majorVersions", selection)));
        this.disposables.push(vs.commands.registerCommand("flutter.packages.outdated", (selection) => vs.commands.executeCommand("dart.listOutdatedPackages", selection)));
        // Hook saving pubspec to run pub.get.
        this.setupPubspecWatcher();
    }
    getPackages(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || !(uri instanceof vs.Uri)) {
                uri = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to get packages for");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            if (util.isInsideFlutterProject(uri)) {
                return this.runFlutter(["pub", "get"], uri);
            }
            else {
                return this.runPub(["get"], uri);
            }
        });
    }
    listOutdatedPackages(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || !(uri instanceof vs.Uri)) {
                uri = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to check for outdated packages");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            if (util.isInsideFlutterProject(uri))
                return this.runFlutter(["pub", "outdated"], uri, true);
            else
                return this.runPub(["outdated"], uri, true);
        });
    }
    upgradePackages(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || !(uri instanceof vs.Uri)) {
                uri = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to upgrade packages in");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            if (util.isInsideFlutterProject(uri))
                return this.runFlutter(["pub", "upgrade"], uri);
            else
                return this.runPub(["upgrade"], uri);
        });
    }
    upgradePackagesMajorVersions(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.dartCapabilities.supportsPubUpgradeMajorVersions) {
                vs.window.showErrorMessage("Your current Dart SDK does not support 'pub upgrade --major-versions'");
                return;
            }
            if (!this.context.hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation) {
                const resp = yield vs.window.showWarningMessage("Running 'pub get --major-versions' will update your pubspec.yaml to match the 'resolvable' column reported in 'pub outdated'", constants_1.iUnderstandAction);
                if (resp !== constants_1.iUnderstandAction) {
                    return;
                }
                this.context.hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation = true;
            }
            if (!uri || !(uri instanceof vs.Uri)) {
                uri = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to upgrade packages --major-versions in");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            if (util.isInsideFlutterProject(uri))
                return this.runFlutter(["pub", "upgrade", "--major-versions"], uri);
            else
                return this.runPub(["upgrade", "--major-versions"], uri);
        });
    }
    setupPubspecWatcher() {
        this.disposables.push(vs.workspace.onWillSaveTextDocument((e) => {
            if (path.basename((0, fs_1.fsPath)(e.document.uri)).toLowerCase() === "pubspec.yaml")
                lastPubspecSaveReason = e.reason;
        }));
        const watcher = vs.workspace.createFileSystemWatcher("**/pubspec.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(this.handlePubspecChange, this);
        watcher.onDidCreate(this.handlePubspecChange, this);
    }
    handlePubspecChange(uri) {
        const filePath = (0, fs_1.fsPath)(uri);
        // Never do anything for files inside hidden or build folders.
        if (filePath.includes(`${path.sep}.`) || filePath.includes(`${path.sep}build${path.sep}`)) {
            this.logger.info(`Skipping pubspec change for ignored folder ${filePath}`);
            return;
        }
        this.logger.info(`Pubspec ${filePath} was modified`);
        const conf = config_1.config.for(uri);
        // Don't do anything if we're disabled.
        if (!conf.runPubGetOnPubspecChanges) {
            this.logger.info(`Automatically running "pub get" is disabled`);
            return;
        }
        // Or if the workspace config says we shouldn't run.
        if (this.workspace.config.disableAutomaticPackageGet) {
            this.logger.info(`Workspace suppresses automatic "pub get"`);
            return;
        }
        // Don't do anything if we're in the middle of creating projects, as packages
        // may  be fetched automatically.
        if (sdk_1.commandState.numProjectCreationsInProgress > 0) {
            this.logger.info("Skipping package fetch because project creation is in progress");
            return;
        }
        // Cancel any existing delayed timer.
        if (runPubGetDelayTimer) {
            clearTimeout(runPubGetDelayTimer);
        }
        // If the save was triggered by one of the auto-save options, then debounce longer.
        const debounceDuration = lastPubspecSaveReason === vs.TextDocumentSaveReason.FocusOut
            || lastPubspecSaveReason === vs.TextDocumentSaveReason.AfterDelay
            ? 10000
            : 1000;
        runPubGetDelayTimer = setTimeout(() => {
            runPubGetDelayTimer = undefined;
            lastPubspecSaveReason = undefined;
            // tslint:disable-next-line: no-floating-promises
            this.fetchPackagesOrPrompt(uri);
        }, debounceDuration); // TODO: Does this need to be configurable?
    }
    fetchPackagesOrPrompt(uri, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isFetchingPackages) {
                this.logger.info(`Already running pub get, skipping!`);
                return;
            }
            isFetchingPackages = true;
            // TODO: Extract this into a Pub class with the things in pub.ts.
            try {
                const forcePrompt = options && options.alwaysPrompt;
                // We debounced so we might get here and have multiple projects to fetch for
                // for ex. when we change Git branch we might change many files at once. So
                // check how many there are, and if there are:
                //   0 - then just use Uri
                //   1 - then just do that one
                //   more than 1 - prompt to do all
                const folders = yield (0, utils_2.getAllProjectFolders)(this.logger, util.getExcludedFolders, { requirePubspec: true });
                const foldersRequiringPackageGet = (0, utils_1.uniq)(folders)
                    .map(vs.Uri.file)
                    .filter((uri) => config_1.config.for(uri).promptToGetPackages)
                    .filter((uri) => (0, pub_1.isPubGetProbablyRequired)(this.sdks, this.logger, uri));
                this.logger.info(`Found ${foldersRequiringPackageGet.length} folders requiring "pub get":${foldersRequiringPackageGet.map((uri) => `\n    ${(0, fs_1.fsPath)(uri)}`).join("")}`);
                if (!forcePrompt && foldersRequiringPackageGet.length === 0)
                    yield vs.commands.executeCommand("dart.getPackages", uri);
                else if (!forcePrompt && foldersRequiringPackageGet.length === 1)
                    yield vs.commands.executeCommand("dart.getPackages", foldersRequiringPackageGet[0]);
                else if (foldersRequiringPackageGet.length)
                    (0, pub_1.promptToRunPubGet)(foldersRequiringPackageGet);
            }
            finally {
                isFetchingPackages = false;
            }
        });
    }
}
exports.PackageCommands = PackageCommands;


/***/ }),

/***/ 883:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RefactorCommands = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(4411);
const config_1 = __webpack_require__(4165);
const edit_das_1 = __webpack_require__(7511);
const refactorOptions = {
    EXTRACT_LOCAL_VARIABLE: getExtractLocalVariableArgs,
    EXTRACT_METHOD: getExtractMethodArgs,
    EXTRACT_WIDGET: getExtractWidgetArgs,
};
class RefactorCommands {
    constructor(logger, context, analyzer) {
        this.logger = logger;
        this.context = context;
        this.analyzer = analyzer;
        this.subscriptions = [];
        this.isProcessingMoveEvent = false;
        /// Server only supports one refactoring at a time, so we need to ensure we
        /// wait for any previous one to finish before sending this.
        this.inProgressRefactor = promises_1.resolvedPromise;
        this.subscriptions.push(vs.commands.registerCommand("_dart.performRefactor", this.performRefactor, this));
        if (analyzer.capabilities.supportsMoveFile && config_1.config.updateImportsOnRename)
            this.subscriptions.push(vs.workspace.onWillRenameFiles((e) => this.onWillRenameFiles(e)));
    }
    performRefactor(document, range, refactorKind) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure the document is still valid.
            if (!document || document.isClosed)
                return;
            const originalDocumentVersion = document.version;
            // Validate that there are no problems if we execute this refactor.
            const validationResult = yield this.getRefactor(document, refactorKind, range, true);
            if (this.shouldAbortRefactor(validationResult))
                return;
            // Request the options from the user if required.
            let options;
            if (refactorOptions[refactorKind]) {
                options = yield refactorOptions[refactorKind](validationResult.feedback);
                if (!options)
                    return;
            }
            // Send the request for the refactor edits and prompt to apply if required.
            const editResult = yield this.getRefactor(document, refactorKind, range, false, options);
            const applyEdits = yield this.shouldApplyEdits(editResult, document, originalDocumentVersion);
            if (applyEdits)
                yield vs.commands.executeCommand("_dart.applySourceChange", document, editResult.change);
        });
    }
    getRefactor(document, refactorKind, range, validateOnly, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let remainingTries = 3;
            while (true) {
                try {
                    remainingTries--;
                    // await is important for the catch!
                    return yield this.analyzer.editGetRefactoring({
                        file: (0, fs_1.fsPath)(document.uri),
                        kind: refactorKind,
                        length: document.offsetAt(range.end) - document.offsetAt(range.start),
                        offset: document.offsetAt(range.start),
                        options,
                        validateOnly,
                    });
                }
                catch (e) {
                    this.logger.error(e);
                    if (remainingTries <= 0 || e.code !== "REFACTORING_REQUEST_CANCELLED")
                        throw e;
                    else
                        this.logger.info(`getRefactor failed, will try ${remainingTries} more times...`);
                }
            }
        });
    }
    shouldAbortRefactor(validationResult) {
        const validationProblems = validationResult.initialProblems
            .concat(validationResult.optionsProblems)
            .concat(validationResult.finalProblems)
            .filter((e) => e.severity === "FATAL");
        if (validationProblems.length) {
            vs.window.showErrorMessage(validationProblems[0].message);
            return true;
        }
        return false;
    }
    shouldApplyEdits(editResult, document, originalDocumentVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            const allProblems = editResult.initialProblems
                .concat(editResult.optionsProblems)
                .concat(editResult.finalProblems);
            const editFatals = allProblems.filter((e) => e.severity === "FATAL");
            const editWarnings = allProblems.filter((e) => e.severity === "ERROR" || e.severity === "WARNING");
            const hasErrors = !!allProblems.find((e) => e.severity === "ERROR");
            // Fatal errors can never be applied, just tell the user and quit.
            if (editFatals.length) {
                vs.window.showErrorMessage((0, array_1.unique)(editFatals.map((e) => e.message)).join("\n\n") + "\n\nYour refactor was not applied.");
                return false;
            }
            // If we somehow got here with no change, we also cannot apply them.
            if (!editResult.change)
                return false;
            let applyEdits = true;
            // If we have warnings/errors, the user can decide whether to go ahead.
            if (editWarnings.length) {
                const show = hasErrors ? vs.window.showErrorMessage : vs.window.showWarningMessage;
                applyEdits = (constants_1.REFACTOR_ANYWAY === (yield show((0, array_1.unique)(editWarnings.map((w) => w.message)).join("\n\n"), constants_1.REFACTOR_ANYWAY)));
            }
            // If we're trying to apply changes but the document is modified, we have to quit.
            if (applyEdits && document && document.version !== originalDocumentVersion) {
                vs.window.showErrorMessage(constants_1.REFACTOR_FAILED_DOC_MODIFIED);
                return false;
            }
            return applyEdits;
        });
    }
    onWillRenameFiles(e) {
        // TODO: VS Code always calls this once-per-file, concurrently for multiple files moved at once
        // which currently results in REFACTOR_CANCELLED for all but the first since the server doesn't
        // support multiple refactors at the same time. Running them sequentially fixes this, however it
        // hits an issue in VS Code (https://github.com/microsoft/vscode/issues/98309) so for now, we will
        // only process a single event at a time.
        if (this.isProcessingMoveEvent) {
            this.logger.info(`Skipping rename event for some files because another is in progress`);
            return;
        }
        try {
            const filesToRename = (0, utils_1.flatMap)(e.files, (f) => this.getResourcesToRename({ oldPath: (0, fs_1.fsPath)(f.oldUri), newPath: (0, fs_1.fsPath)(f.newUri) }))
                // Renames are only supported for Dart files, so filter out anything else to avoid producing an edit that will
                // trigger VS Code to show the rename dialog.
                .filter((f) => path.extname(f.oldPath).toLowerCase() === ".dart");
            if (filesToRename.length === 0)
                return;
            this.isProcessingMoveEvent = true;
            const edits = this.getRenameEdits(filesToRename);
            e.waitUntil(edits.finally(() => this.isProcessingMoveEvent = false));
        }
        catch (e) {
            this.isProcessingMoveEvent = false;
        }
    }
    runSequentially(func) {
        return __awaiter(this, void 0, void 0, function* () {
            this.inProgressRefactor = this.inProgressRefactor.then(() => func());
            return this.inProgressRefactor;
        });
    }
    getRenameEdits(filesToRename) {
        return __awaiter(this, void 0, void 0, function* () {
            const changes = new vs.WorkspaceEdit();
            for (const file of filesToRename) {
                const editResult = yield this.runSequentially(() => this.analyzer.editGetRefactoring({
                    file: file.oldPath,
                    kind: "MOVE_FILE",
                    length: 0,
                    offset: 0,
                    options: { newFile: file.newPath },
                    validateOnly: false,
                }));
                if (!editResult.change)
                    continue;
                const applyEdits = yield this.shouldApplyEdits(editResult);
                if (!applyEdits)
                    continue;
                if ((0, edit_das_1.hasOverlappingEdits)(editResult.change)) {
                    vs.window.showErrorMessage("Unable to update references; edits contain ambigious positions.");
                    this.logger.error(`Unable to apply MOVE_FILE edits due to ambigious edits:\n\n${JSON.stringify(editResult.change, undefined, 4)}`);
                    return;
                }
                for (const edit of editResult.change.edits) {
                    for (const e of edit.edits) {
                        const uri = vs.Uri.file(edit.file);
                        const document = yield vs.workspace.openTextDocument(uri);
                        changes.replace(vs.Uri.file(edit.file), new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length)), e.replacement);
                    }
                }
            }
            if (changes.size === 0)
                return;
            return changes;
        });
    }
    getResourcesToRename(rename) {
        const filesToRename = [];
        if (fs.statSync(rename.oldPath).isFile()) {
            // TODO: if (isAnalyzableAndInWorkspace(rename.oldPath))
            filesToRename.push(rename);
        }
        return filesToRename;
    }
    dispose() {
        for (const command of this.subscriptions)
            command.dispose();
    }
}
exports.RefactorCommands = RefactorCommands;
function getExtractLocalVariableArgs(f) {
    return __awaiter(this, void 0, void 0, function* () {
        const feedback = f;
        const proposedName = feedback && feedback.names && feedback.names.length ? feedback.names[0] : "x";
        return { name: proposedName, extractAll: false };
    });
}
function getExtractMethodArgs(f) {
    return __awaiter(this, void 0, void 0, function* () {
        const feedback = f;
        const suggestedName = feedback && feedback.names && feedback.names.length ? feedback.names[0] : undefined;
        const name = yield vs.window.showInputBox({ prompt: "Enter a name for the method", value: suggestedName });
        if (!name)
            return;
        return {
            createGetter: false,
            extractAll: false,
            name,
            parameters: feedback && feedback.parameters,
            returnType: feedback && feedback.returnType,
        };
    });
}
function getExtractWidgetArgs(f) {
    return __awaiter(this, void 0, void 0, function* () {
        const name = yield vs.window.showInputBox({ prompt: "Enter a name for the widget" });
        return name ? { name } : undefined;
    });
}


/***/ }),

/***/ 997:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.markProjectCreationEnded = exports.markProjectCreationStarted = exports.SdkCommands = exports.BaseSdkCommands = exports.commandState = exports.packageNameRegex = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const processes_1 = __webpack_require__(5837);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
const sdk_manager_1 = __webpack_require__(3570);
const util = __webpack_require__(8779);
const processes_2 = __webpack_require__(5430);
const projects_1 = __webpack_require__(6417);
const channels = __webpack_require__(1026);
exports.packageNameRegex = new RegExp("^[a-z][a-z0-9_]*$");
// TODO: Find a better way/place for this.
exports.commandState = {
    numProjectCreationsInProgress: 0,
    promptToReloadOnVersionChanges: true,
};
class BaseSdkCommands {
    constructor(logger, context, workspace, dartCapabilities) {
        this.logger = logger;
        this.context = context;
        this.workspace = workspace;
        this.dartCapabilities = dartCapabilities;
        this.disposables = [];
        // A map of any in-progress commands so we can terminate them if we want to run another.
        this.runningCommands = {};
        this.sdks = workspace.sdks;
    }
    runCommandForWorkspace(handler, placeHolder, args, selection, alwaysShowOutput = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const folderToRunCommandIn = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, placeHolder, selection);
            if (!folderToRunCommandIn)
                return;
            const containingWorkspace = vs.workspace.getWorkspaceFolder(vs.Uri.file(folderToRunCommandIn));
            if (!containingWorkspace) {
                this.logger.error(`Failed to get workspace folder for ${folderToRunCommandIn}`);
                throw new Error(`Failed to get workspace folder for ${folderToRunCommandIn}`);
            }
            const containingWorkspacePath = (0, fs_1.fsPath)(containingWorkspace.uri);
            // Display the relative path from the workspace root to the folder we're running, or if they're
            // the same then the folder name we're running in.
            const shortPath = path.relative(containingWorkspacePath, folderToRunCommandIn)
                || path.basename(folderToRunCommandIn);
            return handler(folderToRunCommandIn, args, shortPath, alwaysShowOutput);
        });
    }
    runFlutter(args, selection, alwaysShowOutput = false) {
        return this.runCommandForWorkspace(this.runFlutterInFolder.bind(this), `Select the folder to run "flutter ${args.join(" ")}" in`, args, selection, alwaysShowOutput);
    }
    runFlutterInFolder(folder, args, shortPath, alwaysShowOutput = false, customScript) {
        if (!this.sdks.flutter)
            throw new Error("Flutter SDK not available");
        const execution = (0, utils_1.usingCustomScript)(path.join(this.sdks.flutter, constants_1.flutterPath), args, customScript);
        const allArgs = (0, processes_2.getGlobalFlutterArgs)()
            .concat(config_1.config.for(vs.Uri.file(folder)).flutterAdditionalArgs)
            .concat(execution.args);
        return this.runCommandInFolder(shortPath, folder, execution.executable, allArgs, alwaysShowOutput);
    }
    runPub(args, selection, alwaysShowOutput = false) {
        return this.runCommandForWorkspace(this.runPubInFolder.bind(this), `Select the folder to run "pub ${args.join(" ")}" in`, args, selection, alwaysShowOutput);
    }
    runPubInFolder(folder, args, shortPath, alwaysShowOutput = false) {
        if (!this.sdks.dart)
            throw new Error("Dart SDK not available");
        args = args.concat(...config_1.config.for(vs.Uri.file(folder)).pubAdditionalArgs);
        const pubExecution = (0, processes_1.getPubExecutionInfo)(this.dartCapabilities, this.sdks.dart, args);
        return this.runCommandInFolder(shortPath, folder, pubExecution.executable, pubExecution.args, alwaysShowOutput);
    }
    runCommandInFolder(shortPath, folder, binPath, args, alwaysShowOutput) {
        shortPath = shortPath || path.basename(folder);
        const commandName = path.basename(binPath).split(".")[0]; // Trim file extension.
        const channel = channels.getOutputChannel(`${commandName} (${shortPath})`, true);
        if (alwaysShowOutput)
            channel.show();
        // Figure out if there's already one of this command running, in which case we'll chain off the
        // end of it.
        const commandId = `${folder}|${commandName}|${args}`;
        const existingProcess = this.runningCommands[commandId];
        if (existingProcess && !existingProcess.hasStarted) {
            // We already have a queued version of this command so there's no value in queueing another
            // just bail.
            return Promise.resolve(undefined);
        }
        return vs.window.withProgress({
            cancellable: true,
            location: vs.ProgressLocation.Notification,
            title: `${commandName} ${args.join(" ")}`,
        }, (progress, token) => {
            if (existingProcess) {
                progress.report({ message: "terminating previous command..." });
                existingProcess.cancel();
            }
            else {
                channel.clear();
            }
            const process = new ChainedProcess(() => {
                channel.appendLine(`[${shortPath}] ${commandName} ${args.join(" ")}`);
                progress.report({ message: "running..." });
                const proc = (0, processes_2.safeToolSpawn)(folder, binPath, args);
                channels.runProcessInOutputChannel(proc, channel);
                this.logger.info(`(PROC ${proc.pid}) Spawned ${binPath} ${args.join(" ")} in ${folder}`, enums_1.LogCategory.CommandProcesses);
                (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
                // If we complete with a non-zero code, or don't complete within 10s, we should show
                // the output pane.
                const completedWithErrorPromise = new Promise((resolve) => proc.on("close", resolve));
                const timedOutPromise = new Promise((resolve) => setTimeout(() => resolve(true), 10000));
                // tslint:disable-next-line: no-floating-promises
                Promise.race([completedWithErrorPromise, timedOutPromise]).then((showOutput) => {
                    if (showOutput)
                        channel.show(true);
                });
                return proc;
            }, existingProcess);
            this.runningCommands[commandId] = process;
            token.onCancellationRequested(() => process.cancel());
            return process.completed;
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.BaseSdkCommands = BaseSdkCommands;
class SdkCommands extends BaseSdkCommands {
    constructor(logger, context, workspace, dartCapabilities) {
        super(logger, context, workspace, dartCapabilities);
        const dartSdkManager = new sdk_manager_1.DartSdkManager(this.logger, this.workspace.sdks);
        this.disposables.push(vs.commands.registerCommand("dart.changeSdk", () => dartSdkManager.changeSdk()));
        if (workspace.hasAnyFlutterProjects) {
            const flutterSdkManager = new sdk_manager_1.FlutterSdkManager(this.logger, workspace.sdks);
            this.disposables.push(vs.commands.registerCommand("dart.changeFlutterSdk", () => flutterSdkManager.changeSdk()));
        }
        // Monitor version files for SDK upgrades.
        this.setupVersionWatcher();
    }
    setupVersionWatcher() {
        return __awaiter(this, void 0, void 0, function* () {
            // On Windows, the watcher sometimes fires even if the file wasn't modified (could be when
            // accessed), so we need to filter those out. We can't just check the modified time is "recent"
            // because the unzip preserves the modification dates of the SDK. Instead, we'll capture the mtime
            // of the file at start, and then fire only if that time actually changes.
            const versionFile = path.join(this.sdks.dart, "version");
            const getModifiedTimeMs = () => __awaiter(this, void 0, void 0, function* () {
                try {
                    return (yield fs.promises.stat(versionFile)).mtime.getTime();
                }
                catch (error) {
                    this.logger.warn(`Failed to check modification time on version file. ${error}`);
                    return;
                }
            });
            let lastModifiedTime = yield getModifiedTimeMs();
            // If we couldn't get the initial modified time, we can't track this.
            if (!lastModifiedTime)
                return;
            const watcher = fs.watch(versionFile, { persistent: false }, (eventType) => __awaiter(this, void 0, void 0, function* () {
                if (!exports.commandState.promptToReloadOnVersionChanges)
                    return;
                const newModifiedTime = yield getModifiedTimeMs();
                // Bail if we couldn't get a new modified time, or it was the same as the last one.
                if (!newModifiedTime || newModifiedTime === lastModifiedTime)
                    return;
                lastModifiedTime = newModifiedTime;
                // Ensure we don't fire too often as some OSes may generate multiple events.
                exports.commandState.promptToReloadOnVersionChanges = false;
                // Allow it again in 60 seconds.
                setTimeout(() => exports.commandState.promptToReloadOnVersionChanges = true, 60000);
                // Wait a short period before prompting.
                setTimeout(() => util.promptToReloadExtension("Your Dart SDK has been updated. Reload using the new SDK?", undefined, false), 1000);
            }));
            this.disposables.push({ dispose() { watcher.close(); } });
        });
    }
}
exports.SdkCommands = SdkCommands;
function markProjectCreationStarted() {
    exports.commandState.numProjectCreationsInProgress++;
}
exports.markProjectCreationStarted = markProjectCreationStarted;
function markProjectCreationEnded() {
    exports.commandState.numProjectCreationsInProgress--;
}
exports.markProjectCreationEnded = markProjectCreationEnded;
class ChainedProcess {
    constructor(spawn, parent) {
        this.spawn = spawn;
        this.processNumber = ChainedProcess.processNumber++;
        this.completer = new utils_1.PromiseCompleter();
        this.completed = this.completer.promise;
        this.isCancelled = false;
        // We'll either start immediately, or if given a parent process only when it completes.
        if (parent) {
            // tslint:disable-next-line: no-floating-promises
            parent.completed.then(() => this.start());
        }
        else {
            this.start();
        }
    }
    get hasStarted() {
        return this.process !== undefined;
    }
    start() {
        if (this.process)
            throw new Error(`${this.processNumber} Can't start an already started process!`);
        if (this.isCancelled) {
            this.completer.resolve(undefined);
            return;
        }
        this.process = this.spawn();
        this.process.on("close", (code) => this.completer.resolve((0, utils_1.nullToUndefined)(code)));
    }
    cancel() {
        this.isCancelled = true;
    }
}
ChainedProcess.processNumber = 1;


/***/ }),

/***/ 6003:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestCommands = exports.isInImplementationFileThatCanHaveTest = exports.isInTestFileThatHasImplementation = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const test_model_1 = __webpack_require__(1159);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const test_1 = __webpack_require__(8729);
const utils_2 = __webpack_require__(7220);
const editors_1 = __webpack_require__(8805);
const utils_3 = __webpack_require__(8779);
const CAN_JUMP_BETWEEN_TEST_IMPLEMENTATION = "dart-code:canGoToTestOrImplementationFile";
// HACK: Used for testing since we can't read contexts?
exports.isInTestFileThatHasImplementation = false;
exports.isInImplementationFileThatCanHaveTest = false;
class TestCommands {
    constructor(logger, testModel, wsContext, vsCodeTestController, flutterCapabilities) {
        this.logger = logger;
        this.testModel = testModel;
        this.wsContext = wsContext;
        this.vsCodeTestController = vsCodeTestController;
        this.flutterCapabilities = flutterCapabilities;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("_dart.startDebuggingTestsFromVsTestController", (suiteData, treeNodes, suppressPromptOnErrors, testRun) => this.runTestsForNode(suiteData, this.getTestNamesForNodes(treeNodes), true, suppressPromptOnErrors, treeNodes.length === 1 && treeNodes[0] instanceof test_model_1.TestNode, undefined, testRun)), vs.commands.registerCommand("_dart.startWithoutDebuggingTestsFromVsTestController", (suiteData, treeNodes, suppressPromptOnErrors, testRun) => this.runTestsForNode(suiteData, this.getTestNamesForNodes(treeNodes), false, suppressPromptOnErrors, treeNodes.length === 1 && treeNodes[0] instanceof test_model_1.TestNode, undefined, testRun)), vs.commands.registerCommand("dart.startDebuggingTest", (treeNode) => this.runTestsForNode(treeNode.suiteData, this.getTestNames(treeNode), true, false, treeNode instanceof test_model_1.TestNode, undefined)), vs.commands.registerCommand("dart.startWithoutDebuggingTest", (treeNode) => this.runTestsForNode(treeNode.suiteData, this.getTestNames(treeNode), false, false, treeNode instanceof test_model_1.TestNode, undefined)), vs.commands.registerCommand("dart.startDebuggingSkippedTests", (treeNode) => this.runTestsForNode(treeNode.suiteData, this.getTestNames(treeNode, enums_1.TestStatus.Skipped), true, false, true)), vs.commands.registerCommand("dart.startWithoutDebuggingSkippedTests", (treeNode) => this.runTestsForNode(treeNode.suiteData, this.getTestNames(treeNode, enums_1.TestStatus.Skipped), false, false, true)), vs.commands.registerCommand("dart.startDebuggingFailedTests", (treeNode) => this.runTestsForNode(treeNode.suiteData, this.getTestNames(treeNode, enums_1.TestStatus.Failed), true, false, false)), vs.commands.registerCommand("dart.startWithoutDebuggingFailedTests", (treeNode) => this.runTestsForNode(treeNode.suiteData, this.getTestNames(treeNode, enums_1.TestStatus.Failed), false, false, false)), vs.commands.registerCommand("_dart.runAllTestsWithoutDebugging", (suites, testRun) => this.runAllTestsWithoutDebugging(suites, testRun)), vs.commands.registerCommand("dart.goToTests", (resource) => this.goToTestOrImplementationFile(resource), this), vs.commands.registerCommand("dart.goToTestOrImplementationFile", () => this.goToTestOrImplementationFile(), this), vs.window.onDidChangeActiveTextEditor((e) => this.updateEditorContexts(e)));
        // Run for current open editor.
        this.updateEditorContexts(vs.window.activeTextEditor);
        this.disposables.push(vs.commands.registerCommand("_dart.startDebuggingTestFromOutline", (test, launchTemplate) => this.startTestFromOutline(false, test, launchTemplate)));
        this.disposables.push(vs.commands.registerCommand("_dart.startWithoutDebuggingTestFromOutline", (test, launchTemplate) => this.startTestFromOutline(true, test, launchTemplate)));
    }
    runAllTestsWithoutDebugging(suites, testRun) {
        return __awaiter(this, void 0, void 0, function* () {
            // To run multiple folders/suites, we can pass the first as `program` and the rest as `args` which
            // will be appended immediately after `program`. However, this only works for things in the same project
            // as the first one that runs will be used for resolving package: URIs etc.
            // So, fetch all project folders, then if we have suites, group them into those folders, and otherwise
            // use their 'test' folders.
            function getItemsToRunInProject(projectFolder) {
                if (suites) {
                    return suites
                        .map((suite) => suite.suiteData.path)
                        .filter((suitePath) => (0, fs_1.isWithinPath)(suitePath, projectFolder));
                }
                else {
                    const testFolder = path.join(projectFolder, "test");
                    return fs.existsSync(testFolder) ? [testFolder] : [];
                }
            }
            const projectsWithTests = (yield (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true }))
                .map(getItemsToRunInProject)
                .filter((tests) => tests.length);
            if (projectsWithTests.length === 0) {
                vs.window.showErrorMessage("Unable to find any test folders");
                return;
            }
            yield Promise.all(projectsWithTests.map((projectWithTests) => {
                const template = projectWithTests.length > 1
                    ? { args: projectWithTests.slice(1) }
                    : undefined;
                return this.runTests(projectWithTests[0], false, undefined, false, true, template, testRun, undefined);
            }));
        });
    }
    runTestsForNode(suiteData, testNames, debug, suppressPromptOnErrors, runSkippedTests, token, testRun) {
        return __awaiter(this, void 0, void 0, function* () {
            const programPath = (0, fs_1.fsPath)(suiteData.path);
            const canRunSkippedTest = this.flutterCapabilities.supportsRunSkippedTests || !(0, utils_3.isInsideFlutterProject)(vs.Uri.file(suiteData.path));
            const shouldRunSkippedTests = runSkippedTests && canRunSkippedTest;
            return this.runTests(programPath, debug, testNames, shouldRunSkippedTests, suppressPromptOnErrors, undefined, testRun, token);
        });
    }
    runTests(programPath, debug, testNames, shouldRunSkippedTests, suppressPromptOnErrors, launchTemplate, testRun, token) {
        const subs = [];
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            let testsName = path.basename(programPath);
            // Handle when running whole test folder.
            if (testsName === "test")
                testsName = path.basename(path.dirname(programPath));
            const launchConfiguration = Object.assign(Object.assign({ suppressPromptOnErrors }, (0, test_1.getLaunchConfig)(!debug, programPath, testNames, shouldRunSkippedTests, launchTemplate)), { name: `${path.basename(programPath)} tests` });
            // Ensure we have a unique ID for this session so we can track when it completes.
            const dartCodeDebugSessionID = (0, utils_3.ensureDebugLaunchUniqueId)(launchConfiguration);
            // If we were given a test to use by VS Code, use it. Otherwise we'll lazily create one at the
            // other end.
            if (testRun)
                (_a = this.vsCodeTestController) === null || _a === void 0 ? void 0 : _a.registerTestRun(dartCodeDebugSessionID, testRun, false);
            if (token) {
                subs.push(vs.debug.onDidStartDebugSession((e) => {
                    if (e.configuration.dartCodeDebugSessionID === dartCodeDebugSessionID)
                        subs.push(token.onCancellationRequested(() => e.customRequest("disconnect")));
                }));
            }
            subs.push(vs.debug.onDidTerminateDebugSession((e) => {
                if (e.configuration.dartCodeDebugSessionID === dartCodeDebugSessionID)
                    resolve(true);
            }));
            const didStart = yield vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(vs.Uri.file(programPath)), launchConfiguration);
            if (!didStart)
                reject();
        })).finally(() => {
            (0, utils_1.disposeAll)(subs);
        });
    }
    getTestNamesForNodes(nodes) {
        if (nodes.find((node) => node instanceof test_model_1.SuiteNode))
            return undefined;
        return nodes
            .filter((treeNode) => treeNode.name)
            .map((treeNode) => ({ name: treeNode.name, isGroup: treeNode instanceof test_model_1.GroupNode }));
    }
    getTestNames(treeNode, onlyOfStatus) {
        // If we're getting all tests, we can just use the test name/group name (or undefined for suite) directly.
        if (onlyOfStatus === undefined) {
            if ((treeNode instanceof test_model_1.TestNode || treeNode instanceof test_model_1.GroupNode) && treeNode.name !== undefined)
                return [{ name: treeNode.name, isGroup: treeNode instanceof test_model_1.GroupNode }];
            return undefined;
        }
        // Otherwise, collect all descendant tests that are of the specified type.
        let names = [];
        if (treeNode instanceof test_model_1.SuiteNode || treeNode instanceof test_model_1.GroupNode) {
            for (const child of treeNode.children) {
                const childNames = this.getTestNames(child, onlyOfStatus);
                if (childNames)
                    names = names.concat(childNames);
            }
        }
        else if (treeNode instanceof test_model_1.TestNode && treeNode.name !== undefined) {
            if (treeNode.status === onlyOfStatus)
                names.push({ name: treeNode.name, isGroup: treeNode instanceof test_model_1.GroupNode });
        }
        return names;
    }
    startTestFromOutline(noDebug, test, launchTemplate) {
        const canRunSkippedTest = !test.isGroup && (this.flutterCapabilities.supportsRunSkippedTests || !(0, utils_3.isInsideFlutterProject)(vs.Uri.file(test.file)));
        const shouldRunSkippedTests = canRunSkippedTest; // These are the same when running directly, since we always run skipped.
        return this.runTests(test.file, !noDebug, [{ name: test.fullName, isGroup: test.isGroup }], shouldRunSkippedTests, false, launchTemplate, undefined, undefined);
    }
    goToTestOrImplementationFile(resource) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const doc = resource
                ? yield vs.workspace.openTextDocument(resource)
                : (_a = vs.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document;
            if (doc && (0, editors_1.isDartDocument)(doc)) {
                const filePath = (0, fs_1.fsPath)(doc.uri);
                const isTest = (0, utils_3.isTestFile)(filePath);
                const otherFile = isTest
                    ? this.getImplementationFileForTest(filePath)
                    : this.getTestFileForImplementation(filePath);
                if (!otherFile || (isTest && !fs.existsSync(otherFile)))
                    return;
                let selectionOffset;
                let selectionLength;
                // Offer to create test files.
                if (!fs.existsSync(otherFile)) {
                    if (isTest)
                        return;
                    const relativePath = vs.workspace.asRelativePath(otherFile, false);
                    const yesAction = (0, test_1.createTestFileAction)(relativePath);
                    const response = yield vs.window.showInformationMessage(`Would you like to create a test file at ${relativePath}?`, yesAction, constants_1.noAction);
                    if (response !== yesAction)
                        return;
                    (0, fs_1.mkDirRecursive)(path.dirname(otherFile));
                    const testFileInfo = (0, test_1.defaultTestFileContents)(this.wsContext.hasAnyFlutterProjects, (0, utils_1.escapeDartString)((0, utils_1.generateTestNameFromFileName)(relativePath)));
                    fs.writeFileSync(otherFile, testFileInfo.contents);
                    selectionOffset = testFileInfo.selectionOffset;
                    selectionLength = testFileInfo.selectionLength;
                }
                const document = yield vs.workspace.openTextDocument(otherFile);
                const editor = yield vs.window.showTextDocument(document);
                if (selectionOffset && selectionLength)
                    editor.selection = new vs.Selection(document.positionAt(selectionOffset), document.positionAt(selectionOffset + selectionLength));
            }
        });
    }
    updateEditorContexts(e) {
        exports.isInTestFileThatHasImplementation = false;
        exports.isInImplementationFileThatCanHaveTest = false;
        if (e && e.document && (0, editors_1.isDartDocument)(e.document)) {
            const filePath = (0, fs_1.fsPath)(e.document.uri);
            if ((0, utils_3.isTestFile)(filePath)) {
                // Implementation files must exist.
                const implementationFilePath = this.getImplementationFileForTest(filePath);
                exports.isInTestFileThatHasImplementation = !!implementationFilePath && fs.existsSync(implementationFilePath);
            }
            else {
                exports.isInImplementationFileThatCanHaveTest = !!this.getTestFileForImplementation(filePath);
            }
        }
        vs.commands.executeCommand("setContext", CAN_JUMP_BETWEEN_TEST_IMPLEMENTATION, exports.isInTestFileThatHasImplementation || exports.isInImplementationFileThatCanHaveTest);
    }
    getImplementationFileForTest(filePath) {
        const pathSegments = filePath.split(path.sep);
        // Replace test folder with lib.
        const testFolderIndex = pathSegments.lastIndexOf("test");
        if (testFolderIndex !== -1)
            pathSegments[testFolderIndex] = "lib";
        // Remove _test from the filename.
        pathSegments[pathSegments.length - 1] = pathSegments[pathSegments.length - 1].replace(/_test\.dart/, ".dart");
        return pathSegments.join(path.sep);
    }
    getTestFileForImplementation(filePath) {
        const pathSegments = filePath.split(path.sep);
        // Replace lib folder with test.
        const libFolderIndex = pathSegments.lastIndexOf("lib");
        if (libFolderIndex === -1)
            return undefined;
        pathSegments[libFolderIndex] = "test";
        // Add _test to the filename.
        pathSegments[pathSegments.length - 1] = pathSegments[pathSegments.length - 1].replace(/\.dart/, "_test.dart");
        return pathSegments.join(path.sep);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestCommands = TestCommands;


/***/ }),

/***/ 4593:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyCommand = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const editors = __webpack_require__(8805);
class TypeHierarchyCommand {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.showTypeHierarchy", this.showTypeHierarchy, this));
    }
    showTypeHierarchy() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = editors.getActiveDartEditor();
            if (!editor) {
                vs.window.showWarningMessage("No active Dart editor.");
                return;
            }
            const document = editor.document;
            const originalSelection = editor.selection;
            const response = yield this.analyzer.searchGetTypeHierarchy({
                file: (0, fs_1.fsPath)(document.uri),
                offset: document.offsetAt(editor.selection.active),
            });
            const items = response.hierarchyItems;
            if (!items) {
                vs.window.showInformationMessage("Type hierarchy not available.");
                return;
            }
            const options = {
                onDidSelectItem: (item) => this.openLocation(item, true),
                placeHolder: name(items, 0),
            };
            // TODO: How / where to show implements?
            const tree = [];
            const startItem = items[0];
            tree.push(startItem);
            addParents(items, tree, startItem);
            addChildren(items, tree, startItem);
            const result = yield vs.window.showQuickPick(tree.map((item) => itemToPick(item, items)), options);
            if (result && result.location) {
                yield this.openLocation(result);
            }
            else {
                // Move the use back to where they were.
                const ed = yield vs.window.showTextDocument(document);
                ed.revealRange(editor.selection, vs.TextEditorRevealType.InCenterIfOutsideViewport);
                ed.selection = originalSelection;
            }
        });
    }
    openLocation(result, asPreview = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!result.location) {
                this.logger.warn(`Unable to open item with no location`);
                return;
            }
            const location = result.location;
            const document = yield vs.workspace.openTextDocument(location.file);
            const editor = yield vs.window.showTextDocument(document, {
                preserveFocus: asPreview,
                preview: asPreview,
            });
            const range = (0, utils_2.toRangeOnLine)(location);
            (0, utils_2.showCode)(editor, range, range, range);
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TypeHierarchyCommand = TypeHierarchyCommand;
function addParents(items, tree, item) {
    if (item.superclass) {
        const parent = items[item.superclass];
        if (parent.classElement.name !== "Object") {
            tree.unshift(parent);
            addParents(items, tree, parent);
        }
    }
}
function addChildren(items, tree, item) {
    // Handle direct children.
    for (const index of item.subclasses) {
        const child = items[index];
        tree.push(child);
    }
    // Handle grandchildren.
    for (const index of item.subclasses) {
        const child = items[index];
        if (child.subclasses.length > 0)
            addChildren(items, tree, child);
    }
}
function itemToPick(item, items) {
    let desc = "";
    // extends
    if (item.superclass !== undefined && name(items, item.superclass) !== "Object")
        desc += `extends ${name(items, item.superclass)}`;
    // implements
    if (item.interfaces.length > 0) {
        if (desc.length > 0)
            desc += ", ";
        desc += `implements ${item.interfaces.map((i) => name(items, i)).join(", ")}`;
    }
    // with
    if (item.mixins.length > 0) {
        if (desc.length > 0)
            desc += ", ";
        desc += `with ${item.mixins.map((i) => name(items, i)).join(", ")}`;
    }
    const result = {
        description: desc,
        label: item.classElement.name,
        location: item.classElement.location,
    };
    return result;
}
function name(items, index) {
    return items[index].classElement.name;
}


/***/ }),

/***/ 4165:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.config = exports.ResourceConfig = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
class Config {
    constructor() {
        vscode_1.workspace.onDidChangeConfiguration((e) => this.reloadConfig());
        this.config = vscode_1.workspace.getConfiguration("dart");
        (0, processes_1.setupToolEnv)(this.env);
    }
    reloadConfig() {
        this.config = vscode_1.workspace.getConfiguration("dart");
        (0, processes_1.setupToolEnv)(this.env);
    }
    getConfig(key, defaultValue) {
        const value = this.config.get(key, defaultValue);
        return (0, utils_1.nullToUndefined)(value);
    }
    getWorkspaceConfig(key) {
        const c = this.config.inspect(key);
        if (c && c.workspaceValue)
            return (0, utils_1.nullToUndefined)(c.workspaceValue);
        if (c && c.workspaceFolderValue)
            return (0, utils_1.nullToUndefined)(c.workspaceFolderValue);
        return undefined;
    }
    setConfig(key, value, target) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.config.update(key, value, target);
        });
    }
    get additionalAnalyzerFileExtensions() { return this.getConfig("additionalAnalyzerFileExtensions", []); }
    get allowAnalytics() { return this.getConfig("allowAnalytics", true); }
    get allowTestsOutsideTestFolder() { return this.getConfig("allowTestsOutsideTestFolder", false); }
    get analysisServerFolding() { return this.getConfig("analysisServerFolding", true); }
    get analyzeAngularTemplates() { return this.getConfig("analyzeAngularTemplates", true); }
    get analyzerAdditionalArgs() { return this.getConfig("analyzerAdditionalArgs", []); }
    get analyzerDiagnosticsPort() { return this.getConfig("analyzerDiagnosticsPort", null); }
    get analyzerInstrumentationLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("analyzerInstrumentationLogFile", null))); }
    get analyzerLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("analyzerLogFile", null))); }
    get analyzerPath() { return (0, utils_2.resolvePaths)(this.getConfig("analyzerPath", null)); }
    get analyzerSshHost() { return this.getConfig("analyzerSshHost", null); }
    get analyzerVmServicePort() { return this.getConfig("analyzerVmServicePort", null); }
    get autoImportCompletions() { return this.getConfig("autoImportCompletions", true); }
    get automaticCommentSlashes() { return this.getConfig("automaticCommentSlashes", "tripleSlash"); }
    get buildRunnerAdditionalArgs() { return this.getConfig("buildRunnerAdditionalArgs", []); }
    get checkForSdkUpdates() { return this.getConfig("checkForSdkUpdates", true); }
    get cliConsole() { return this.getConfig("cliConsole", "debugConsole"); }
    get closingLabels() { return this.getConfig("closingLabels", true); }
    get dapLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("dapLogFile", null))); }
    get dartTestLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("dartTestLogFile", null))); }
    get debugExtensionBackendProtocol() { return this.getConfig("debugExtensionBackendProtocol", "ws"); }
    get debugExternalPackageLibraries() { return this.getConfig("debugExternalPackageLibraries", false); }
    get debugSdkLibraries() { return this.getConfig("debugSdkLibraries", false); }
    get devToolsBrowser() { return this.getConfig("devToolsBrowser", "chrome"); }
    get devToolsLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("devToolsLogFile", null))); }
    get devToolsPort() { return this.getConfig("devToolsPort", null); }
    get devToolsReuseWindows() { return this.getConfig("devToolsReuseWindows", true); }
    get devToolsTheme() { return this.getConfig("devToolsTheme", "dark"); }
    get embedDevTools() { return this.getConfig("embedDevTools", true); }
    get enableSdkFormatter() { return this.getConfig("enableSdkFormatter", true); }
    get enableServerSnippets() { return this.getConfig("enableServerSnippets", false); }
    get enableSnippets() { return this.getConfig("enableSnippets", true); }
    get env() { return this.getConfig("env", {}); }
    get evaluateToStringInDebugViews() { return this.getConfig("evaluateToStringInDebugViews", true); }
    get experimentalDartDapPath() { return (0, utils_2.resolvePaths)(this.getConfig("experimentalDartDapPath", null)); }
    get experimentalFlutterDapPath() { return (0, utils_2.resolvePaths)(this.getConfig("experimentalFlutterDapPath", null)); }
    get extensionLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("extensionLogFile", null))); }
    get flutterAdbConnectOnChromeOs() { return this.getConfig("flutterAdbConnectOnChromeOs", false); }
    get flutterCreateAndroidLanguage() { return this.getConfig("flutterCreateAndroidLanguage", "kotlin"); }
    get flutterCreateIOSLanguage() { return this.getConfig("flutterCreateIOSLanguage", "swift"); }
    get flutterCreateOffline() { return this.getConfig("flutterCreateOffline", false); }
    get flutterCreateOrganization() { return this.getConfig("flutterCreateOrganization", null); }
    get flutterCustomEmulators() { return this.getConfig("flutterCustomEmulators", []); }
    get flutterDaemonLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterDaemonLogFile", null))); }
    get flutterGutterIcons() { return this.getConfig("flutterGutterIcons", true); }
    get flutterHotReloadOnSave() {
        const value = this.getConfig("flutterHotReloadOnSave", "manual");
        // Convert the legacy bool value to its new enum type, if required.
        if (value === true)
            return "manual";
        else if (value === false)
            return "never";
        else
            return value;
    }
    get flutterHotRestartOnSave() { return this.getConfig("flutterHotRestartOnSave", true); }
    get flutterOutline() { return this.getConfig("flutterOutline", true); }
    get flutterRunLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterRunLogFile", null))); }
    get flutterScreenshotPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterScreenshotPath", null)); }
    get flutterSdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterSdkPath", null)); }
    get flutterSdkPaths() { return this.getConfig("flutterSdkPaths", []).map(utils_2.resolvePaths); }
    get flutterSelectDeviceWhenConnected() { return this.getConfig("flutterSelectDeviceWhenConnected", true); }
    get flutterShowEmulators() { return this.getConfig("flutterShowEmulators", "local"); }
    get flutterShowWebServerDevice() { return this.getConfig("flutterShowWebServerDevice", "remote"); }
    get flutterTestLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterTestLogFile", null))); }
    get flutterWebRenderer() { return this.getConfig("flutterWebRenderer", "auto"); }
    get hotReloadOnSave() { return this.getConfig("hotReloadOnSave", "never"); }
    get hotReloadProgress() { return this.getConfig("hotReloadProgress", "notification"); }
    get lspSnippetTextEdits() { return this.getConfig("lspSnippetTextEdits", true); }
    get maxLogLineLength() { return this.getConfig("maxLogLineLength", 2000); }
    get normalizeFileCasing() { return this.getConfig("normalizeFileCasing", false); }
    get notifyAnalyzerErrors() { return this.getConfig("notifyAnalyzerErrors", true); }
    get onlyAnalyzeProjectsWithOpenFiles() { return this.getConfig("onlyAnalyzeProjectsWithOpenFiles", false); }
    get openDevTools() { return this.getConfig("openDevTools", "never"); }
    get openTestView() { return this.getConfig("openTestView", ["testRunStart"]); }
    get previewBazelWorkspaceCustomScripts() { return this.getConfig("previewBazelWorkspaceCustomScripts", false); }
    get previewCommitCharacters() { return this.getConfig("previewCommitCharacters", false); }
    get previewFlutterUiGuides() { return this.getConfig("previewFlutterUiGuides", false); }
    get previewFlutterUiGuidesCustomTracking() { return this.getConfig("previewFlutterUiGuidesCustomTracking", false); }
    get previewHotReloadOnSaveWatcher() { return this.getConfig("previewHotReloadOnSaveWatcher", false); }
    get promptToRunIfErrors() { return this.getConfig("promptToRunIfErrors", true); }
    get renameFilesWithClasses() { return this.getConfig("renameFilesWithClasses", "never"); }
    get sdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("sdkPath", null)); }
    get sdkPaths() { return this.getConfig("sdkPaths", []).map(utils_2.resolvePaths); }
    get shareDevToolsWithFlutter() { return this.getConfig("shareDevToolsWithFlutter", true); }
    get showDartPadSampleCodeLens() { return this.getConfig("showDartPadSampleCodeLens", true); }
    get showDevToolsDebugToolBarButtons() { return this.getConfig("showDevToolsDebugToolBarButtons", true); }
    get showIgnoreQuickFixes() { return this.getConfig("showIgnoreQuickFixes", true); }
    get showInspectorNotificationsForWidgetErrors() { return this.getConfig("showInspectorNotificationsForWidgetErrors", true); }
    get showMainCodeLens() { return this.getConfig("showMainCodeLens", true); }
    get showSkippedTests() { return this.getConfig("showSkippedTests", true); }
    get showTestCodeLens() { return this.getConfig("showTestCodeLens", true); }
    get showTodos() { return this.getConfig("showTodos", true); }
    get triggerSignatureHelpAutomatically() { return this.getConfig("triggerSignatureHelpAutomatically", false); }
    get updateImportsOnRename() { return this.getConfig("updateImportsOnRename", true); }
    get useLsp() { return this.getConfig("useLsp", true); }
    get vmServiceLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("vmServiceLogFile", null))); }
    get warnWhenEditingFilesInPubCache() { return this.getConfig("warnWhenEditingFilesInPubCache", true); }
    get warnWhenEditingFilesOutsideWorkspace() { return this.getConfig("warnWhenEditingFilesOutsideWorkspace", true); }
    get webDaemonLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("webDaemonLogFile", null))); }
    // Helpers
    get useDevToolsDarkTheme() { return this.devToolsTheme === "dark"; }
    get openTestViewOnFailure() { return this.openTestView.indexOf("testFailure") !== -1; }
    get openTestViewOnStart() { return this.openTestView.indexOf("testRunStart") !== -1; }
    get workspaceSdkPath() { return (0, utils_2.resolvePaths)(this.getWorkspaceConfig("sdkPath")); }
    get workspaceFlutterSdkPath() { return (0, utils_2.resolvePaths)(this.getWorkspaceConfig("flutterSdkPath")); }
    // Options that can be set programatically.
    setCheckForSdkUpdates(value) { return this.setConfig("checkForSdkUpdates", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreateOrganization(value) { return this.setConfig("flutterCreateOrganization", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreateAndroidLanguage(value) { return this.setConfig("flutterCreateAndroidLanguage", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreateIOSLanguage(value) { return this.setConfig("flutterCreateIOSLanguage", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreateOffline(value) { return this.setConfig("flutterCreateOffline", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterSdkPath(value) { return this.setConfig("flutterSdkPath", value, vscode_1.ConfigurationTarget.Workspace); }
    setGlobalDartSdkPath(value) { return this.setConfig("sdkPath", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalDebugSdkLibraries(value) { return this.setConfig("debugSdkLibraries", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalDebugExternalPackageLibraries(value) { return this.setConfig("debugExternalPackageLibraries", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalFlutterSdkPath(value) { return this.setConfig("flutterSdkPath", value, vscode_1.ConfigurationTarget.Global); }
    setOpenDevTools(value) { return this.setConfig("openDevTools", value, vscode_1.ConfigurationTarget.Global); }
    setShowInspectorNotificationsForWidgetErrors(value) { return this.setConfig("showInspectorNotificationsForWidgetErrors", value, vscode_1.ConfigurationTarget.Global); }
    setSdkPath(value) { return this.setConfig("sdkPath", value, vscode_1.ConfigurationTarget.Workspace); }
    setWarnWhenEditingFilesOutsideWorkspace(value) { return this.setConfig("warnWhenEditingFilesOutsideWorkspace", value, vscode_1.ConfigurationTarget.Global); }
    setWarnWhenEditingFilesInPubCache(value) { return this.setConfig("warnWhenEditingFilesInPubCache", value, vscode_1.ConfigurationTarget.Global); }
    for(uri) {
        return new ResourceConfig(uri);
    }
}
class ResourceConfig {
    constructor(uri) {
        this.uri = uri;
        this.config = vscode_1.workspace.getConfiguration("dart", this.uri);
    }
    getConfig(key, defaultValue) {
        return (0, utils_1.nullToUndefined)(this.config.get(key, defaultValue));
    }
    get analysisExcludedFolders() { return this.getConfig("analysisExcludedFolders", []); }
    get analyzerInstrumentationLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("analyzerInstrumentationLogFile", null))); }
    get analyzerLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("analyzerLogFile", null))); }
    get analyzerPath() { return (0, utils_2.resolvePaths)(this.getConfig("analyzerPath", null)); }
    get cliAdditionalArgs() { return this.getConfig("cliAdditionalArgs", []); }
    get completeFunctionCalls() { return this.getConfig("completeFunctionCalls", true); }
    get dapLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("dapLogFile", null))); }
    get dartTestLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("dartTestLogFile", null))); }
    get devToolsLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("devToolsLogFile", null))); }
    get doNotFormat() { return this.getConfig("doNotFormat", []); }
    get enableCompletionCommitCharacters() { return this.getConfig("enableCompletionCommitCharacters", false); }
    get evaluateGettersInDebugViews() { return this.getConfig("evaluateGettersInDebugViews", true); }
    get extensionLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("extensionLogFile", null))); }
    get flutterAdditionalArgs() { return this.getConfig("flutterAdditionalArgs", []); }
    get flutterAttachAdditionalArgs() { return this.getConfig("flutterAttachAdditionalArgs", []); }
    get flutterDaemonLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterDaemonLogFile", null))); }
    get flutterRunAdditionalArgs() { return this.getConfig("flutterRunAdditionalArgs", []); }
    get flutterRunLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterRunLogFile", null))); }
    get flutterScreenshotPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterScreenshotPath", null)); }
    get flutterSdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterSdkPath", null)); }
    get flutterSdkPaths() { return this.getConfig("flutterSdkPaths", []).map(utils_2.resolvePaths); }
    get flutterStructuredErrors() { return this.getConfig("flutterStructuredErrors", true); }
    get flutterTestAdditionalArgs() { return this.getConfig("flutterTestAdditionalArgs", []); }
    get flutterTestLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterTestLogFile", null))); }
    get flutterTrackWidgetCreation() { return this.getConfig("flutterTrackWidgetCreation", true); }
    get insertArgumentPlaceholders() { return this.getConfig("insertArgumentPlaceholders", true); }
    get lineLength() { return this.getConfig("lineLength", 80); }
    get promptToGetPackages() { return this.getConfig("promptToGetPackages", true); }
    get pubAdditionalArgs() { return this.getConfig("pubAdditionalArgs", []); }
    get runPubGetOnPubspecChanges() { return this.getConfig("runPubGetOnPubspecChanges", true); }
    get sdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("sdkPath", null)); }
    get sdkPaths() { return this.getConfig("sdkPaths", []).map(utils_2.resolvePaths); }
    get showDartDeveloperLogs() { return this.getConfig("showDartDeveloperLogs", true); }
    get suppressTestTimeouts() { return this.getConfig("suppressTestTimeouts", "never"); }
    get testAdditionalArgs() { return this.getConfig("testAdditionalArgs", []); }
    get vmAdditionalArgs() { return this.getConfig("vmAdditionalArgs", []); }
    get vmServiceLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("vmServiceLogFile", null))); }
    get webDaemonLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("webDaemonLogFile", null))); }
}
exports.ResourceConfig = ResourceConfig;
exports.config = new Config();


/***/ }),

/***/ 4530:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartTaskProvider = exports.BaseTaskProvider = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const utils_2 = __webpack_require__(8461);
const utils_3 = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
const projects_1 = __webpack_require__(6417);
const buildRunnerProblemMatcher = "$dart-build_runner";
const buildRunnerBuildOptions = { problemMatchers: [buildRunnerProblemMatcher], isBackground: true, group: vs.TaskGroup.Build, runtimeArgs: () => config_1.config.buildRunnerAdditionalArgs };
const buildRunnerTestOptions = { problemMatchers: [buildRunnerProblemMatcher], isBackground: true, group: vs.TaskGroup.Test, runtimeArgs: () => config_1.config.buildRunnerAdditionalArgs };
const flutterBuildOptions = { isBackground: true, group: vs.TaskGroup.Build };
const taskOptions = [
    // test must come first so it matches before the next catch-all one
    [["pub", "run", "build_runner", "test"], buildRunnerTestOptions],
    [["pub", "run", "build_runner"], buildRunnerBuildOptions],
    [["build"], flutterBuildOptions],
];
class BaseTaskProvider {
    constructor(logger, context, sdks) {
        this.logger = logger;
        this.context = context;
        this.sdks = sdks;
    }
    /// Tasks that will either be run by Dart or Flutter depending on the project type.
    createSharedTasks(folder) {
        const promises = [];
        promises.push(this.createPubTask(folder, ["get"]));
        promises.push(this.createPubTask(folder, ["upgrade"]));
        if ((0, utils_2.referencesBuildRunner)((0, fs_1.fsPath)(folder.uri))) {
            promises.push(this.createPubTask(folder, ["run", "build_runner", "watch"]));
            promises.push(this.createPubTask(folder, ["run", "build_runner", "build"]));
            promises.push(this.createPubTask(folder, ["run", "build_runner", "serve"]));
            promises.push(this.createPubTask(folder, ["run", "build_runner", "test"]));
        }
        return promises;
    }
    resolveTask(task, token) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            const scope = task.scope;
            const cwd = "uri" in scope ? (0, fs_1.fsPath)(scope.uri) : undefined;
            const definition = task.definition;
            // Pub commands should be run through Flutter if a Flutter project.
            if (definition.command === "pub" && (0, utils_3.isFlutterProjectFolder)(cwd)) {
                definition.command = "flutter";
                definition.args = ["pub", ...((_a = definition.args) !== null && _a !== void 0 ? _a : [])];
            }
            const options = this.getOptions(definition);
            if (options === null || options === void 0 ? void 0 : options.runtimeArgs) {
                definition.args = ((_b = definition.args) !== null && _b !== void 0 ? _b : []).concat((_c = (yield (options === null || options === void 0 ? void 0 : options.runtimeArgs()))) !== null && _c !== void 0 ? _c : []);
            }
            this.injectArgs(definition);
            // We *must* return a new Task here, otherwise the task cannot be customised
            // in task.json.
            // https://github.com/microsoft/vscode/issues/58836#issuecomment-696620105
            const newTask = new vs.Task(definition, 
            // This should never be undefined, but the type allows it but the constructor
            // arg does not.
            task.scope || vs.TaskScope.Workspace, task.name, task.source, yield this.createTaskExecution(this.sdks, definition, cwd), undefined);
            newTask.problemMatchers = (_d = (newTask.problemMatchers && newTask.problemMatchers.length ? newTask.problemMatchers : options === null || options === void 0 ? void 0 : options.problemMatchers)) !== null && _d !== void 0 ? _d : [];
            newTask.group = (_e = task.group) !== null && _e !== void 0 ? _e : options === null || options === void 0 ? void 0 : options.group;
            newTask.isBackground = task.isBackground || ((_f = options === null || options === void 0 ? void 0 : options.isBackground) !== null && _f !== void 0 ? _f : false);
            return newTask;
        });
    }
    injectArgs(_) {
    }
    getOptions(def) {
        var _a;
        let taskCommand = [def.command, ...((_a = def.args) !== null && _a !== void 0 ? _a : [])];
        // Strip ""dart" or flutter" from the front for easier matching.
        if (taskCommand[0] === "flutter" || taskCommand[0] === "dart")
            taskCommand = taskCommand.slice(1);
        for (const knownOption of taskOptions) {
            const [command, options] = knownOption;
            if ((0, array_1.arrayStartsWith)(taskCommand, command))
                return options;
        }
    }
    createTaskStub(folder, command, args) {
        return new vs.Task({ type: this.type, command, args }, folder, [command, ...args].join(" "), this.type, undefined, undefined);
    }
    createTask(wf, command, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const task = this.createTaskStub(wf, command, args);
            return this.resolveTask(task);
        });
    }
    runTask(uri, command, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let folder = uri ? vs.workspace.getWorkspaceFolder(uri) : undefined;
            if (!folder) {
                const folderPath = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which project to run the command for");
                if (!folderPath)
                    return;
                folder = vs.workspace.getWorkspaceFolder(vs.Uri.file(folderPath));
            }
            if (!folder)
                return;
            const task = yield this.createTask(folder, command, args);
            return vs.tasks.executeTask(task);
        });
    }
    createTaskExecution(sdks, definition, cwd) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!definition.command)
                return;
            const sdk = definition.command === "flutter" && sdks.flutter ? sdks.flutter : sdks.dart;
            const executable = (0, constants_1.getExecutableName)(definition.command);
            const program = path.join(sdk, "bin", executable);
            let args = (_a = definition.args) !== null && _a !== void 0 ? _a : [];
            if (definition.runtimeArgs) {
                const runtimeArgs = yield definition.runtimeArgs();
                if (runtimeArgs)
                    args = args.concat(runtimeArgs);
            }
            return new vs.ProcessExecution(program, args || [], { cwd, env: (0, processes_1.getToolEnv)() });
        });
    }
}
exports.BaseTaskProvider = BaseTaskProvider;
class DartTaskProvider extends BaseTaskProvider {
    constructor(logger, context, sdks, dartCapabilities) {
        super(logger, context, sdks);
        this.dartCapabilities = dartCapabilities;
        context.subscriptions.push(vs.commands.registerCommand("dart.task.dartdoc", (uri) => this.runTask(uri, "dartdoc", [])));
    }
    get type() { return DartTaskProvider.type; }
    provideTasks(token) {
        return __awaiter(this, void 0, void 0, function* () {
            const dartProjects = (0, utils_1.getDartWorkspaceFolders)();
            let promises = [];
            dartProjects.forEach((folder) => {
                const isFlutter = (0, utils_3.isFlutterWorkspaceFolder)(folder);
                if (!isFlutter)
                    promises = promises.concat(this.createSharedTasks(folder));
                promises.push(this.createTask(folder, "dartdoc", []));
                // For testing...
                // tasks.push(this.createTask(folder, "--version"));
            });
            const tasks = (yield Promise.all(promises));
            return tasks;
        });
    }
    createPubTask(folder, args) {
        if (this.dartCapabilities.supportsDartPub)
            return this.createTask(folder, "dart", ["pub", ...args]);
        else
            return this.createTask(folder, "pub", args);
    }
}
exports.DartTaskProvider = DartTaskProvider;
DartTaskProvider.type = "dart"; // also referenced in package.json


/***/ }),

/***/ 3424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HotReloadOnSaveHandler = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
const utils_2 = __webpack_require__(8779);
class HotReloadOnSaveHandler {
    constructor(debugCommands, flutterCapabilities) {
        this.debugCommands = debugCommands;
        this.flutterCapabilities = flutterCapabilities;
        this.disposables = [];
        // Non-FS-watcher version (onDidSave).
        this.disposables.push(vscode_1.workspace.onWillSaveTextDocument((e) => this.lastSaveReason = e.reason));
        this.disposables.push(vscode_1.workspace.onDidSaveTextDocument((td) => {
            // Bail if we're using fs-watcher instead. We still wire this
            // handler up so we don't need to reload for this setting change.
            if (config_1.config.previewHotReloadOnSaveWatcher)
                return;
            this.triggerReload(td);
        }));
        // FS-watcher version.
        // TODO: Make this support everything that shouldHotReloadFor() does.
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/*.dart");
        this.disposables.push(watcher);
        watcher.onDidChange(this.handleFileSystemChange, this);
        watcher.onDidCreate(this.handleFileSystemChange, this);
    }
    handleFileSystemChange(uri) {
        // Bail if we're not using fs-watcher instead. We still wire this
        // handler up so we don't need to reload for this setting change.
        if (!config_1.config.previewHotReloadOnSaveWatcher)
            return;
        this.triggerReload({ uri });
    }
    triggerReload(file) {
        const isAutoSave = this.lastSaveReason === vscode_1.TextDocumentSaveReason.FocusOut ||
            this.lastSaveReason === vscode_1.TextDocumentSaveReason.AfterDelay;
        // Never do anything for files inside .dart_tool folders.
        if ((0, fs_1.fsPath)(file.uri).indexOf(`${path.sep}.dart_tool${path.sep}`) !== -1)
            return;
        // Bail out if we're in an external file, or not Dart.
        if (!(0, utils_2.isWithinWorkspace)((0, fs_1.fsPath)(file.uri)) || !(0, utils_2.shouldHotReloadFor)(file))
            return;
        // Don't do if we have errors for the saved file.
        const errors = vscode_1.languages.getDiagnostics(file.uri);
        const hasErrors = errors && !!errors.find((d) => d.source === "dart" && d.severity === vscode_1.DiagnosticSeverity.Error);
        if (hasErrors)
            return;
        this.reloadDart(isAutoSave);
        this.reloadFlutter(isAutoSave);
    }
    reloadDart(isAutoSave) {
        const configSetting = config_1.config.hotReloadOnSave;
        if (configSetting === "never" || (isAutoSave && configSetting === "manual"))
            return;
        const commandToRun = "dart.hotReload";
        const args = {
            onlyDart: true,
            reason: constants_1.restartReasonSave,
        };
        // Debounce to avoid reloading multiple times during multi-file-save (Save All).
        // Hopefully we can improve in future: https://github.com/microsoft/vscode/issues/86087
        if (this.dartHotReloadDelayTimer) {
            clearTimeout(this.dartHotReloadDelayTimer);
        }
        this.dartHotReloadDelayTimer = setTimeout(() => {
            this.dartHotReloadDelayTimer = undefined;
            vscode_1.commands.executeCommand(commandToRun, args);
        }, 200);
    }
    reloadFlutter(isAutoSave) {
        const configSetting = config_1.config.flutterHotReloadOnSave;
        if (configSetting === "never" || (isAutoSave && configSetting === "manual"))
            return;
        const shouldHotReload = this.debugCommands.vmServices.serviceIsRegistered(enums_1.VmService.HotReload);
        const shouldHotRestart = !this.debugCommands.vmServices.serviceIsRegistered(enums_1.VmService.HotReload)
            && this.debugCommands.vmServices.serviceIsRegistered(enums_1.VmService.HotRestart)
            && config_1.config.flutterHotRestartOnSave;
        // Don't do if there are no debug sessions that support it.
        if (!shouldHotReload && !shouldHotRestart)
            return;
        const commandToRun = shouldHotReload ? "dart.hotReload" : "flutter.hotRestart";
        const args = {
            debounce: this.flutterCapabilities.supportsRestartDebounce,
            onlyFlutter: true,
            reason: constants_1.restartReasonSave,
        };
        if (this.flutterCapabilities.supportsRestartDebounce) {
            vscode_1.commands.executeCommand(commandToRun, args);
        }
        else {
            // Debounce to avoid reloading multiple times during multi-file-save (Save All).
            // Hopefully we can improve in future: https://github.com/microsoft/vscode/issues/86087
            if (this.flutterHotReloadDelayTimer) {
                clearTimeout(this.flutterHotReloadDelayTimer);
            }
            this.flutterHotReloadDelayTimer = setTimeout(() => {
                this.flutterHotReloadDelayTimer = undefined;
                vscode_1.commands.executeCommand(commandToRun, args);
            }, 200);
        }
    }
    dispose() {
        if (this.dartHotReloadDelayTimer)
            clearTimeout(this.dartHotReloadDelayTimer);
        if (this.flutterHotReloadDelayTimer)
            clearTimeout(this.flutterHotReloadDelayTimer);
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.HotReloadOnSaveHandler = HotReloadOnSaveHandler;


/***/ }),

/***/ 1326:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClosingLabelsDecorations = exports.validLastCharacters = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(8779);
exports.validLastCharacters = [")", "]"];
class ClosingLabelsDecorations {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.subscriptions = [];
        this.decorationType = vs.window.createTextEditorDecorationType({
            after: {
                color: new vs.ThemeColor("dart.closingLabels"),
                margin: "2px",
            },
            rangeBehavior: vs.DecorationRangeBehavior.ClosedOpen,
        });
        this.subscriptions.push(this.analyzer.registerForAnalysisClosingLabels((n) => {
            if (this.activeEditor && n.file === (0, fs_1.fsPath)(this.activeEditor.document.uri)) {
                this.closingLabels = n;
                this.update();
            }
        }));
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
        if (vs.window.activeTextEditor)
            this.setTrackingFile(vs.window.activeTextEditor);
    }
    update() {
        if (!this.closingLabels || !this.activeEditor || this.closingLabels.file !== (0, fs_1.fsPath)(this.activeEditor.document.uri))
            return;
        const decorations = [];
        for (const r of this.closingLabels.labels) {
            // Ensure the label we got looks like a sensible range, otherwise the outline info
            // might be stale (eg. we sent two updates, and the outline from in between them just
            // arrived). In this case, we'll just bail and do nothing, assuming a future update will
            // have the correct info.
            const finalCharacterPosition = this.activeEditor.document.positionAt(r.offset + r.length);
            if (finalCharacterPosition.character < 1)
                return;
            const finalCharacterRange = new vs.Range(finalCharacterPosition.translate({ characterDelta: -1 }), finalCharacterPosition);
            const finalCharacterText = this.activeEditor.document.getText(finalCharacterRange);
            if (exports.validLastCharacters.indexOf(finalCharacterText) === -1)
                return;
            // Get the end of the line where we'll show the labels.
            const endOfLine = this.activeEditor.document.lineAt(finalCharacterPosition).range.end;
            const existingDecorationForLine = decorations[endOfLine.line];
            if (existingDecorationForLine) {
                existingDecorationForLine.renderOptions.after.contentText = " // " + r.label + " " + existingDecorationForLine.renderOptions.after.contentText;
            }
            else {
                const dec = {
                    range: new vs.Range(this.activeEditor.document.positionAt(r.offset), endOfLine),
                    renderOptions: { after: { contentText: " // " + r.label } },
                };
                decorations[endOfLine.line] = dec;
            }
        }
        this.activeEditor.setDecorations(this.decorationType, Object.keys(decorations).map((k) => parseInt(k, 10)).map((k) => decorations[k]));
    }
    setTrackingFile(editor) {
        var _a;
        if (!editor || !(0, utils_2.isAnalyzable)(editor.document))
            return;
        if (editor !== this.activeEditor)
            (_a = this.activeEditor) === null || _a === void 0 ? void 0 : _a.setDecorations(this.decorationType, []);
        if (editor) {
            this.activeEditor = editor;
            this.closingLabels = undefined;
            this.analyzer.forceNotificationsFor((0, fs_1.fsPath)(editor.document.uri));
        }
        else {
            this.activeEditor = undefined;
            this.closingLabels = undefined;
        }
    }
    dispose() {
        var _a;
        (_a = this.activeEditor) === null || _a === void 0 ? void 0 : _a.setDecorations(this.decorationType, []);
        this.activeEditor = undefined;
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.ClosingLabelsDecorations = ClosingLabelsDecorations;


/***/ }),

/***/ 1739:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterColorDecorations = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const color_range_computer_1 = __webpack_require__(1197);
const utils_2 = __webpack_require__(8779);
class FlutterColorDecorations {
    constructor(logger, imageStoragePath) {
        this.logger = logger;
        this.imageStoragePath = imageStoragePath;
        this.subscriptions = [];
        this.decorationTypes = {};
        this.computer = new color_range_computer_1.ColorRangeComputer();
        this.subscriptions.push(vs.workspace.onDidChangeTextDocument((e) => {
            if (this.activeEditor && e.document === this.activeEditor.document) {
                // Delay this so if we're getting lots of updates we don't flicker.
                if (this.updateTimeout)
                    clearTimeout(this.updateTimeout);
                this.updateTimeout = setTimeout(() => this.update(), 1000);
            }
        }));
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => {
            this.setTrackingFile(e);
            this.update();
        }));
        if (vs.window.activeTextEditor) {
            this.setTrackingFile(vs.window.activeTextEditor);
            this.update();
        }
    }
    update() {
        if (!this.activeEditor)
            return;
        const results = this.computer.compute(this.activeEditor.document);
        // Each color needs to be its own decoration, so here we update our main list
        // with any new ones we hadn't previously created.
        for (const colorHex of Object.keys(results)) {
            const filePath = this.createImageFile(colorHex);
            if (filePath && !this.decorationTypes[colorHex])
                this.decorationTypes[colorHex] = vs.window.createTextEditorDecorationType({
                    gutterIconPath: vs.Uri.file(filePath),
                    gutterIconSize: "50%",
                });
        }
        for (const colorHex of Object.keys(this.decorationTypes)) {
            this.activeEditor.setDecorations(this.decorationTypes[colorHex], results[colorHex] || []);
        }
    }
    setTrackingFile(editor) {
        if (editor && (0, utils_2.isAnalyzable)(editor.document)) {
            this.activeEditor = editor;
        }
        else
            this.activeEditor = undefined;
    }
    createImageFile(hex) {
        // Add a version number to the folder in case we need to change these
        // and invalidate the old ones.
        const imageFolder = path.join(this.imageStoragePath, "v1");
        (0, fs_1.mkDirRecursive)(imageFolder);
        const file = path.join(imageFolder, `${hex}.svg`);
        if (fs.existsSync(file))
            return file;
        try {
            const hex6 = hex.substr(2);
            const opacity = parseInt(hex.substr(0, 2), 16) / 255;
            const imageContents = svgContents
                .replace("{HEX-6}", hex6)
                .replace("{OPACITY}", opacity.toString());
            fs.writeFileSync(file, imageContents);
            return file;
        }
        catch (e) {
            this.logger.warn(e);
        }
    }
    dispose() {
        if (this.activeEditor) {
            for (const colorHex of Object.keys(this.decorationTypes))
                this.activeEditor.setDecorations(this.decorationTypes[colorHex], []);
        }
        this.activeEditor = undefined;
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.FlutterColorDecorations = FlutterColorDecorations;
const svgContents = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16">
	<rect fill="#{HEX-6}" x="0" y="0" width="16" height="16" fill-opacity="{OPACITY}" />
</svg>
`;


/***/ }),

/***/ 4478:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterIconDecorations = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const extension_utils_1 = __webpack_require__(6143);
const utils_2 = __webpack_require__(8779);
class FlutterIconDecorations {
    constructor(logger) {
        this.logger = logger;
        this.subscriptions = [];
        this.decorationTypes = {};
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => {
            this.setTrackingFile(e);
            this.update();
        }));
        setImmediate(() => {
            this.setTrackingFile(vs.window.activeTextEditor);
            this.update();
        });
    }
    render(results) {
        if (!this.activeEditor)
            return;
        // Each icon type needs to be its own decoration, so here we update our main list
        // with any new ones we hadn't previously created.
        for (const iconName of Object.keys(results)) {
            if (!this.decorationTypes[iconName])
                this.decorationTypes[iconName] = vs.window.createTextEditorDecorationType({
                    gutterIconPath: vs.Uri.parse(extension_utils_1.docsIconPathFormat.replace("$1", iconName)),
                    gutterIconSize: "75%",
                });
        }
        for (const iconName of Object.keys(this.decorationTypes)) {
            this.activeEditor.setDecorations(this.decorationTypes[iconName], results[iconName] || []);
        }
    }
    setTrackingFile(editor) {
        if (editor && (0, utils_2.isAnalyzable)(editor.document))
            this.activeEditor = editor;
        else
            this.activeEditor = undefined;
    }
    dispose() {
        this.activeEditor = undefined;
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.FlutterIconDecorations = FlutterIconDecorations;


/***/ }),

/***/ 91:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterIconDecorationsDas = void 0;
const fs_1 = __webpack_require__(300);
const icon_range_computer_1 = __webpack_require__(7731);
const flutter_icon_decorations_1 = __webpack_require__(4478);
class FlutterIconDecorationsDas extends flutter_icon_decorations_1.FlutterIconDecorations {
    constructor(logger, analyzer) {
        super(logger);
        this.analyzer = analyzer;
        this.computer = new icon_range_computer_1.IconRangeComputer(logger);
        this.subscriptions.push(this.analyzer.client.registerForFlutterOutline((n) => __awaiter(this, void 0, void 0, function* () {
            if (this.activeEditor && (0, fs_1.fsPath)(this.activeEditor.document.uri) === n.file) {
                this.update(n.outline);
            }
        })));
    }
    update(outline) {
        if (!this.activeEditor)
            return;
        if (!outline)
            outline = this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri);
        if (!outline)
            return;
        const results = this.computer.compute(this.activeEditor.document, outline);
        this.render(results);
    }
}
exports.FlutterIconDecorationsDas = FlutterIconDecorationsDas;


/***/ }),

/***/ 789:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterIconDecorationsLsp = void 0;
const vs = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const icon_range_computer_1 = __webpack_require__(7731);
const flutter_icon_decorations_1 = __webpack_require__(4478);
class FlutterIconDecorationsLsp extends flutter_icon_decorations_1.FlutterIconDecorations {
    constructor(logger, analyzer) {
        super(logger);
        this.analyzer = analyzer;
        this.computer = new icon_range_computer_1.IconRangeComputerLsp(logger);
        this.subscriptions.push(this.analyzer.fileTracker.onFlutterOutline.listen((op) => __awaiter(this, void 0, void 0, function* () {
            if (this.activeEditor && (0, fs_1.fsPath)(this.activeEditor.document.uri) === (0, fs_1.fsPath)(vs.Uri.parse(op.uri))) {
                this.update(op.outline);
            }
        })));
    }
    update(outline) {
        if (!this.activeEditor)
            return;
        if (!outline)
            outline = this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri);
        if (!outline)
            return;
        const results = this.computer.compute(outline);
        this.render(results);
    }
}
exports.FlutterIconDecorationsLsp = FlutterIconDecorationsLsp;


/***/ }),

/***/ 8681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetGuide = exports.FlutterUiGuideDecorations = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const trackers_1 = __webpack_require__(4191);
const config_1 = __webpack_require__(4165);
const nonBreakingSpace = "\xa0";
const verticalLine = "";
const horizontalLine = "";
const bottomCorner = "";
const middleCorner = "";
class FlutterUiGuideDecorations {
    constructor() {
        this.disposables = [];
        this.borderDecoration = vs.window.createTextEditorDecorationType({
            rangeBehavior: vs.DecorationRangeBehavior.OpenOpen,
        });
        // Update any editor that becomes active.
        this.disposables.push(vs.window.onDidChangeActiveTextEditor((e) => this.buildForTextEditor(e)));
        if (config_1.config.previewFlutterUiGuidesCustomTracking) {
            this.tracker = new WidgetGuideTracker();
            this.disposables.push(this.tracker);
            // Subscribe to updates from the tracker so we can update on keypress without
            // waiting for new Outlines.
            this.tracker.onGuidesChanged(([doc, guides]) => this.buildFromUpdatedGuides(doc, guides));
        }
        // Update the current visible editor when we were registered.
        setImmediate(() => this.buildForTextEditor(vs.window.activeTextEditor));
    }
    buildFromUpdatedGuides(doc, guides) {
        if (vs.window.activeTextEditor && vs.window.activeTextEditor.document === doc)
            this.renderGuides(vs.window.activeTextEditor, guides);
    }
    renderGuides(editor, guides) {
        const color = new vs.ThemeColor("dart.flutterUiGuides");
        const guidesByLine = {};
        for (const guide of guides) {
            for (let line = guide.start.line; line <= guide.end.line; line++) {
                guidesByLine[line] = guidesByLine[line] || [];
                guidesByLine[line].push(guide);
            }
        }
        const decorations = this.buildDecorations(editor.document, editor.options.tabSize, guidesByLine, color);
        editor.setDecorations(this.borderDecoration, decorations);
    }
    buildDecorations(doc, tabSize, guidesByLine, color) {
        const decorations = [];
        for (const line of Object.keys(guidesByLine).map((k) => parseInt(k, 10))) {
            const lineInfo = doc.lineAt(line);
            const firstGuideChar = Math.min(...guidesByLine[line].map((g) => Math.min(g.start.character, g.end.character)));
            const lastGuideChar = Math.max(...guidesByLine[line].map((g) => Math.max(g.start.character, g.end.character)));
            const lastLineCharacter = lineInfo.range.end.character;
            const anchorPoint = Math.max(lastLineCharacter < firstGuideChar ? 0 : firstGuideChar, 0);
            const decorationString = new Array(lastGuideChar).fill(nonBreakingSpace);
            for (const guide of guidesByLine[line]) {
                if (line !== guide.end.line) {
                    // Only put a vertical line in if we haven't already o
                    if (decorationString[guide.start.character] === nonBreakingSpace)
                        decorationString[guide.start.character] = verticalLine;
                    else if (decorationString[guide.start.character] === bottomCorner)
                        decorationString[guide.start.character] = middleCorner;
                }
                else {
                    for (let c = guide.start.character; c <= guide.end.character; c++) {
                        if (c === guide.start.character) {
                            decorationString[c] = bottomCorner;
                        }
                        else {
                            decorationString[c] = horizontalLine;
                        }
                    }
                }
            }
            // For any characters that have users text in them, we should not
            // render any guides.
            decorationString.fill(nonBreakingSpace, lineInfo.firstNonWhitespaceCharacterIndex, lineInfo.range.end.character);
            decorationString.splice(0, anchorPoint);
            // For any tabs in the document string, we need to multiply up the characters
            // by the tab width, since everything up to this point is based on the text line
            // character indexes, but rendering needs to obey tab size.
            const tabAdjustedDecorationString = [];
            for (let i = 0; i < decorationString.length; i++) {
                tabAdjustedDecorationString.push(decorationString[i]);
                if (lineInfo.text[anchorPoint + i] === "\t") {
                    const padCharacter = decorationString[i] === horizontalLine || decorationString[i] === bottomCorner || decorationString[i] === middleCorner
                        ? horizontalLine
                        : nonBreakingSpace;
                    for (let c = 0; c < tabSize - 1; c++)
                        tabAdjustedDecorationString.push(padCharacter);
                }
            }
            decorations.push({
                range: new vs.Range(new vs.Position(line, anchorPoint), new vs.Position(line, anchorPoint)),
                renderOptions: {
                    before: {
                        color,
                        contentText: tabAdjustedDecorationString.join(""),
                        fontStyle: "normal",
                        margin: "0 1px 0 -1px",
                        width: "0",
                    },
                },
            });
        }
        return decorations;
    }
    firstNonWhitespace(document, lineNumber) {
        return new vs.Position(lineNumber, document.lineAt(lineNumber).firstNonWhitespaceCharacterIndex);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FlutterUiGuideDecorations = FlutterUiGuideDecorations;
class WidgetGuide {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
}
exports.WidgetGuide = WidgetGuide;
class WidgetGuideTracker {
    constructor() {
        this.disposables = [];
        this.tracker = new trackers_1.DocumentPositionTracker();
        this.guideMap = new Map();
        this.onGuidesChangedEmitter = new vs.EventEmitter();
        this.onGuidesChanged = this.onGuidesChangedEmitter.event;
        this.disposables.push(this.tracker);
        this.tracker.onPositionsChanged(([doc, positions]) => {
            // Map all our original positions onto new positions based on their
            // new offsets.
            const newGuides = [];
            for (const guide of this.guideMap.keys()) {
                const data = this.guideMap.get(guide);
                const currentStartPos = data[0];
                const currentEndPos = data[1];
                const newStartPos = positions.get(currentStartPos);
                const newEndPos = positions.get(currentEndPos);
                if (newStartPos && newEndPos)
                    newGuides.push(new WidgetGuide(newStartPos, newEndPos));
            }
            this.onGuidesChangedEmitter.fire([doc, newGuides]);
        });
    }
    clear() {
        this.guideMap.clear();
        this.tracker.clear();
    }
    trackDoc(document, guides) {
        // Stash all guides as tuples containing their positions.
        this.guideMap.clear();
        for (const guide of guides)
            this.guideMap.set(guide, [guide.start, guide.end]);
        // Extract a flat list of positions to track.
        const positions = (0, utils_1.flatMap)([...this.guideMap.values()], (g) => [g[0], g[1]]);
        this.tracker.trackDoc(document, positions);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}


/***/ }),

/***/ 7900:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterUiGuideDecorationsDas = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const flutter_ui_guides_decorations_1 = __webpack_require__(8681);
class FlutterUiGuideDecorationsDas extends flutter_ui_guides_decorations_1.FlutterUiGuideDecorations {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        // Whenever we get a new Flutter Outline, if it's for the active document,
        // update that too.
        this.disposables.push(this.analyzer.client.registerForFlutterOutline((on) => {
            const editor = vs.window.activeTextEditor;
            if (editor && editor.document && (0, fs_1.fsPath)(editor.document.uri) === on.file)
                this.buildFromOutline(editor, on.outline);
        }));
    }
    buildForTextEditor(editor) {
        if (editor && editor.document)
            this.buildFromOutline(editor, this.analyzer.fileTracker.getFlutterOutlineFor(editor.document.uri));
    }
    buildFromOutline(editor, outline) {
        if (this.tracker)
            this.tracker.clear();
        if (!editor || !editor.document || !outline)
            return;
        // Check that the outline we got looks like it still matches the document.
        // If the lengths are different, just bail without doing anything since
        // there have probably been new edits and we'll get a new outline soon.
        if (editor.document.getText().length !== outline.length)
            return;
        const guides = this.extractGuides(editor.document, outline);
        if (this.tracker)
            this.tracker.trackDoc(editor.document, guides);
        this.renderGuides(editor, guides);
    }
    extractGuides(document, node) {
        let guides = [];
        if (node.kind === "NEW_INSTANCE") {
            const parentLine = document.positionAt(node.offset).line;
            const childLines = node.children && node.children
                .map((c) => document.positionAt(c.offset).line)
                .filter((cl) => cl > parentLine);
            if (childLines) {
                const startPos = this
                    .firstNonWhitespace(document, parentLine);
                childLines.forEach((childLine, i) => {
                    const firstCodeChar = this.firstNonWhitespace(document, childLine);
                    guides.push(new flutter_ui_guides_decorations_1.WidgetGuide(startPos, firstCodeChar));
                });
            }
        }
        // Recurse down the tree to include childrens (and they'll include their
        // childrens, etc.).
        if (node.children)
            guides = guides.concat((0, utils_1.flatMap)(node.children, (c) => this.extractGuides(document, c)));
        return guides;
    }
}
exports.FlutterUiGuideDecorationsDas = FlutterUiGuideDecorationsDas;


/***/ }),

/***/ 1397:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterUiGuideDecorationsLsp = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const flutter_ui_guides_decorations_1 = __webpack_require__(8681);
class FlutterUiGuideDecorationsLsp extends flutter_ui_guides_decorations_1.FlutterUiGuideDecorations {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        // Whenever we get a new Flutter Outline, if it's for the active document,
        // update that too.
        this.disposables.push(this.analyzer.fileTracker.onFlutterOutline.listen((op) => {
            const editor = vs.window.activeTextEditor;
            if (editor && editor.document && (0, fs_1.fsPath)(editor.document.uri) === (0, fs_1.fsPath)(vs.Uri.parse(op.uri)))
                this.buildFromOutline(editor, op.outline);
        }));
    }
    buildForTextEditor(editor) {
        if (editor && editor.document)
            this.buildFromOutline(editor, this.analyzer.fileTracker.getFlutterOutlineFor(editor.document.uri));
    }
    buildFromOutline(editor, outline) {
        if (this.tracker)
            this.tracker.clear();
        if (!editor || !editor.document || !outline)
            return;
        // Check that the outline we got looks like it still matches the document.
        // If the lengths are different, just bail without doing anything since
        // there have probably been new edits and we'll get a new outline soon.
        const outlineLength = editor.document.offsetAt((0, utils_2.lspToPosition)(outline.range.end));
        if (editor.document.getText().length !== outlineLength)
            return;
        const guides = this.extractGuides(editor.document, outline);
        if (this.tracker)
            this.tracker.trackDoc(editor.document, guides);
        this.renderGuides(editor, guides);
    }
    extractGuides(document, node) {
        let guides = [];
        if (node.kind === "NEW_INSTANCE") {
            const parentLine = node.codeRange.start.line;
            const childLines = node.children && node.children
                .map((c) => c.codeRange.start.line)
                .filter((cl) => cl > parentLine);
            if (childLines) {
                const startPos = this
                    .firstNonWhitespace(document, parentLine);
                childLines.forEach((childLine, i) => {
                    const firstCodeChar = this.firstNonWhitespace(document, childLine);
                    guides.push(new flutter_ui_guides_decorations_1.WidgetGuide(startPos, firstCodeChar));
                });
            }
        }
        // Recurse down the tree to include childrens (and they'll include their
        // childrens, etc.).
        if (node.children)
            guides = guides.concat((0, utils_1.flatMap)(node.children, (c) => this.extractGuides(document, c)));
        return guides;
    }
}
exports.FlutterUiGuideDecorationsLsp = FlutterUiGuideDecorationsLsp;


/***/ }),

/***/ 8805:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getActiveDartEditor = exports.isDartDocument = void 0;
const vs = __webpack_require__(9496);
function isDartDocument(document) {
    return document && document.languageId === "dart";
}
exports.isDartDocument = isDartDocument;
function getActiveDartEditor() {
    const editor = vs.window.activeTextEditor;
    if (!editor || editor.document.languageId !== "dart")
        return undefined;
    return editor;
}
exports.getActiveDartEditor = getActiveDartEditor;


/***/ }),

/***/ 1824:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExperiments = void 0;
const fs_1 = __webpack_require__(300);
// Used for testing. DO NOT COMMIT AS TRUE.
const clearAllExperiments = false;
function getExperiments(logger, workspaceContext, context) {
    return {
    // example: new ExampleExperiement(logger, workspaceContext, context),
    };
}
exports.getExperiments = getExperiments;
// class ExampleExperiement extends Experiment {
// 	constructor(logger: Logger, workspaceContext: WorkspaceContext, context: Context) {
// 		super(logger, workspaceContext, context, "example", 10);
// 	}
// }
class Experiment {
    constructor(logger, workspaceContext, context, id, currentPercent) {
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.context = context;
        this.id = id;
        this.currentPercent = currentPercent;
        // If this is the first time we've seen this experiment, generate a random number
        // from 1-100.
        const contextKey = `experiement-${id}`;
        const contextHasActivatedKey = `${contextKey}-hasActivated`;
        if (clearAllExperiments) {
            context.update(contextKey, undefined);
            context.update(contextHasActivatedKey, undefined);
        }
        this.randomNumber = context.get(contextKey);
        if (!this.randomNumber) {
            this.randomNumber = (0, fs_1.getRandomInt)(1, 100);
            context.update(contextKey, this.randomNumber);
            logger.info(`Generated random number ${this.randomNumber} for new experiement '${id}'. Experiment is enabled for <= ${this.currentPercent}`);
        }
        else {
            logger.info(`Experiment random number is ${this.randomNumber} for experiement '${id}'. Experiment is enabled for <= ${this.currentPercent}`);
        }
        if (this.applies) {
            const isFirst = !context.get(contextHasActivatedKey);
            context.update(contextHasActivatedKey, true);
            logger.info(`Experiment '${id}' is activating (${isFirst ? "first time" : "not first time"})`);
            this.activate(isFirst)
                // Activate is allowed to return false if it skipped activating (eg. not relevant) so
                // first activation can re-run in future.
                .then((v) => {
                if (v === false) {
                    logger.info(`Experiment '${id}' aborted. Clearing hasActivated flag`);
                    context.update(contextHasActivatedKey, undefined);
                }
            });
        }
    }
    get applies() { return this.randomNumber <= this.currentPercent; }
    /// Activates the experiment. If returns false, resets the hasActivated flag so it
    /// is not considered to have run.
    activate(isFirstActivation) {
        return __awaiter(this, void 0, void 0, function* () { return; });
    }
}


/***/ }),

/***/ 1892:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deactivate = exports.activate = exports.ringLog = exports.SERVICE_CONTEXT_PREFIX = exports.SERVICE_EXTENSION_CONTEXT_PREFIX = exports.FLUTTER_SUPPORTS_ATTACH = exports.DART_MODE = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const dart_1 = __webpack_require__(7355);
const flutter_1 = __webpack_require__(4790);
const vscode_1 = __webpack_require__(7068);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const fetch_1 = __webpack_require__(2183);
const logging_1 = __webpack_require__(8323);
const api_1 = __webpack_require__(8316);
const symbols_1 = __webpack_require__(9055);
const coordinator_1 = __webpack_require__(9602);
const test_model_1 = __webpack_require__(1159);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const device_manager_1 = __webpack_require__(6711);
const extension_utils_1 = __webpack_require__(6143);
const uri_handler_1 = __webpack_require__(5652);
const utils_2 = __webpack_require__(7220);
const workspace_1 = __webpack_require__(6105);
const analyzer_das_1 = __webpack_require__(2061);
const analyzer_lsp_1 = __webpack_require__(9165);
const analyzer_status_reporter_1 = __webpack_require__(2975);
const file_change_handler_1 = __webpack_require__(7246);
const file_change_warnings_1 = __webpack_require__(4775);
const analytics_1 = __webpack_require__(3189);
const api_2 = __webpack_require__(8237);
const flutter_dartpad_samples_1 = __webpack_require__(7525);
const flutter_dartpad_samples_lsp_1 = __webpack_require__(6212);
const main_code_lens_provider_1 = __webpack_require__(7927);
const main_code_lens_provider_lsp_1 = __webpack_require__(5543);
const test_code_lens_provider_1 = __webpack_require__(6993);
const test_code_lens_provider_lsp_1 = __webpack_require__(3005);
const add_dependency_1 = __webpack_require__(4954);
const analyzer_1 = __webpack_require__(8932);
const channels_1 = __webpack_require__(1026);
const dart_2 = __webpack_require__(5836);
const debug_1 = __webpack_require__(4635);
const edit_1 = __webpack_require__(7244);
const edit_das_1 = __webpack_require__(7511);
const edit_lsp_1 = __webpack_require__(6039);
const flutter_2 = __webpack_require__(2364);
const flutter_outline_1 = __webpack_require__(9021);
const go_to_super_1 = __webpack_require__(1471);
const logging_2 = __webpack_require__(9475);
const open_in_other_editors_1 = __webpack_require__(7809);
const packages_1 = __webpack_require__(8128);
const refactor_1 = __webpack_require__(883);
const sdk_1 = __webpack_require__(997);
const test_1 = __webpack_require__(6003);
const type_hierarchy_1 = __webpack_require__(4593);
const config_1 = __webpack_require__(4165);
const dart_task_provider_1 = __webpack_require__(4530);
const hot_reload_save_handler_1 = __webpack_require__(3424);
const closing_labels_decorations_1 = __webpack_require__(1326);
const flutter_color_decorations_1 = __webpack_require__(1739);
const flutter_icon_decorations_das_1 = __webpack_require__(91);
const flutter_icon_decorations_lsp_1 = __webpack_require__(789);
const flutter_ui_guides_decorations_das_1 = __webpack_require__(7900);
const flutter_ui_guides_decorations_lsp_1 = __webpack_require__(1397);
const experiments_1 = __webpack_require__(1824);
const daemon_message_handler_1 = __webpack_require__(5086);
const flutter_daemon_1 = __webpack_require__(5887);
const flutter_outline_view_1 = __webpack_require__(4942);
const flutter_task_provider_1 = __webpack_require__(9476);
const analyzer_status_reporter_2 = __webpack_require__(7428);
const closing_labels_decorations_2 = __webpack_require__(3088);
const go_to_super_2 = __webpack_require__(9982);
const test_discoverer_1 = __webpack_require__(3747);
const add_dependency_code_action_provider_1 = __webpack_require__(1983);
const assist_code_action_provider_1 = __webpack_require__(9679);
const dart_completion_item_provider_1 = __webpack_require__(6974);
const dart_diagnostic_provider_1 = __webpack_require__(5453);
const dart_document_symbol_provider_1 = __webpack_require__(6663);
const dart_folding_provider_1 = __webpack_require__(3299);
const dart_formatting_edit_provider_1 = __webpack_require__(7099);
const dart_highlighting_provider_1 = __webpack_require__(9917);
const dart_hover_provider_1 = __webpack_require__(988);
const dart_implementation_provider_1 = __webpack_require__(9715);
const dart_language_configuration_1 = __webpack_require__(1122);
const dart_reference_provider_1 = __webpack_require__(8517);
const dart_rename_provider_1 = __webpack_require__(6252);
const dart_signature_help_provider_1 = __webpack_require__(4258);
const dart_workspace_symbol_provider_1 = __webpack_require__(5188);
const debug_adapter_descriptor_factory_1 = __webpack_require__(8109);
const debug_adapter_logger_factory_1 = __webpack_require__(4319);
const debug_config_provider_1 = __webpack_require__(233);
const fix_code_action_provider_1 = __webpack_require__(5587);
const legacy_dart_workspace_symbol_provider_1 = __webpack_require__(23);
const ranking_code_action_provider_1 = __webpack_require__(7702);
const refactor_code_action_provider_1 = __webpack_require__(3797);
const snippet_completion_item_provider_1 = __webpack_require__(2252);
const source_code_action_provider_1 = __webpack_require__(4508);
const global_1 = __webpack_require__(334);
const status_bar_version_tracker_1 = __webpack_require__(9032);
const update_check_1 = __webpack_require__(8949);
const utils_3 = __webpack_require__(8461);
const link_provider_1 = __webpack_require__(6355);
const vs_test_controller_1 = __webpack_require__(2601);
const user_prompts_1 = __webpack_require__(4741);
const util = __webpack_require__(8779);
const log_1 = __webpack_require__(8202);
const processes_1 = __webpack_require__(5430);
const packages_view_1 = __webpack_require__(5663);
exports.DART_MODE = { language: "dart", scheme: "file" };
const HTML_MODE = { language: "html", scheme: "file" };
const PROJECT_LOADED = "dart-code:anyProjectLoaded";
const DART_PROJECT_LOADED = "dart-code:anyStandardDartProjectLoaded";
// TODO: Define what this means better. Some commands a general Flutter (eg. Hot
// Reload) and some are more specific (eg. Attach).
const FLUTTER_PROJECT_LOADED = "dart-code:anyFlutterProjectLoaded";
const FLUTTER_MOBILE_PROJECT_LOADED = "dart-code:flutterMobileProjectLoaded";
const WEB_PROJECT_LOADED = "dart-code:WebProjectLoaded";
exports.FLUTTER_SUPPORTS_ATTACH = "dart-code:flutterSupportsAttach";
const DART_PLATFORM_NAME = "dart-code:dartPlatformName";
exports.SERVICE_EXTENSION_CONTEXT_PREFIX = "dart-code:serviceExtension.";
exports.SERVICE_CONTEXT_PREFIX = "dart-code:service.";
let analyzer;
let flutterDaemon;
let deviceManager;
const dartCapabilities = dart_1.DartCapabilities.empty;
const flutterCapabilities = flutter_1.FlutterCapabilities.empty;
let analysisRoots = [];
let analytics;
let showTodos;
let previousSettings;
let analyzerShutdown;
let experiments;
const loggers = [];
let ringLogger;
const logger = new logging_1.EmittingLogger();
// Keep a running in-memory buffer of last 200 log events we can give to the
// user when something crashed even if they don't have disk-logging enabled.
exports.ringLog = new logging_1.RingLog(200);
function activate(context, isRestart = false) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        // Ring logger is only set up once and presist over silent restarts.
        if (!ringLogger)
            ringLogger = logger.onLog((message) => exports.ringLog.log(message.toLine(500)));
        if (extension_utils_1.isDevExtension)
            context.subscriptions.push((0, logging_1.logToConsole)(logger));
        vs.commands.executeCommand("setContext", constants_1.IS_RUNNING_LOCALLY_CONTEXT, utils_2.isRunningLocally);
        buildLogHeaders();
        setupLog((0, log_1.getExtensionLogPath)(), enums_1.LogCategory.General);
        const extContext = workspace_1.Context.for(context);
        const webClient = new fetch_1.WebClient(extension_utils_1.extensionVersion);
        util.logTime("Code called activate");
        // Wire up a reload command that will re-initialise everything.
        context.subscriptions.push(vs.commands.registerCommand("_dart.reloadExtension", () => __awaiter(this, void 0, void 0, function* () {
            logger.info("Performing silent extension reload...");
            yield deactivate(true);
            (0, utils_1.disposeAll)(context.subscriptions);
            yield activate(context, true);
            logger.info("Done!");
        })));
        showTodos = config_1.config.showTodos;
        previousSettings = getSettingsThatRequireRestart();
        const extensionStartTime = new Date();
        util.logTime();
        const sdkUtils = new utils_3.SdkUtils(logger);
        const workspaceContextUnverified = yield sdkUtils.scanWorkspace();
        util.logTime("initWorkspace");
        // Set up log files.
        setupLog(config_1.config.analyzerLogFile, enums_1.LogCategory.Analyzer);
        setupLog(config_1.config.flutterDaemonLogFile, enums_1.LogCategory.FlutterDaemon);
        setupLog(config_1.config.dapLogFile, enums_1.LogCategory.DAP);
        setupLog(config_1.config.devToolsLogFile, enums_1.LogCategory.DevTools);
        analytics = new analytics_1.Analytics(logger, workspaceContextUnverified);
        if (!workspaceContextUnverified.sdks.dart || (workspaceContextUnverified.hasAnyFlutterProjects && !workspaceContextUnverified.sdks.flutter)) {
            // Don't set anything else up; we can't work like this!
            return sdkUtils.handleMissingSdks(context, analytics, workspaceContextUnverified);
        }
        const workspaceContext = workspaceContextUnverified;
        const sdks = workspaceContext.sdks;
        const writableConfig = workspaceContext.config;
        // TODO: Move these capabilities into WorkspaceContext.
        if (sdks.dartVersion) {
            dartCapabilities.version = sdks.dartVersion;
            analytics.sdkVersion = sdks.dartVersion;
            // tslint:disable-next-line: no-floating-promises
            (0, update_check_1.checkForStandardDartSdkUpdates)(logger, workspaceContext);
        }
        if (sdks.flutterVersion) {
            flutterCapabilities.version = sdks.flutterVersion;
            analytics.flutterSdkVersion = sdks.flutterVersion;
            // If we're going to pass the DevTools URL to Flutter, we need to eagerly start it
            // so it's already running.
            if (workspaceContext.hasAnyFlutterProjects && config_1.config.shareDevToolsWithFlutter && flutterCapabilities.supportsDevToolsServerAddress) {
                writableConfig.startDevToolsServerEagerly = true;
            }
        }
        try {
            if (!experiments)
                experiments = (0, experiments_1.getExperiments)(logger, workspaceContext, extContext);
        }
        catch (e) {
            logger.error(e);
        }
        const isVirtualWorkspace = vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.every((f) => f.uri.scheme !== "file");
        function shouldUseLsp() {
            // Never use LSP if the LSP client would reject the current VS Code version or the Dart SDK doesn't support it.
            if (!vscode_1.vsCodeVersion.supportsLatestLspClient || !dartCapabilities.canDefaultLsp)
                return false;
            // If DART_CODE_FORCE_LSP is set to true/false it always overrides.
            if (process.env.DART_CODE_FORCE_LSP === "true")
                return true;
            if (process.env.DART_CODE_FORCE_LSP === "false")
                return false;
            // In virtual workspaces, we always use LSP because it will have non-file resources
            // and we only handle them properly in LSP.
            if (isVirtualWorkspace)
                return true;
            return config_1.config.useLsp;
        }
        const isUsingLsp = shouldUseLsp();
        writableConfig.useLsp = isUsingLsp;
        vs.commands.executeCommand("setContext", constants_1.IS_LSP_CONTEXT, isUsingLsp);
        // Build log headers now we know analyzer type.
        buildLogHeaders(logger, workspaceContextUnverified);
        // Show the SDK version in the status bar.
        if (sdks.dartVersion)
            context.subscriptions.push(new status_bar_version_tracker_1.StatusBarVersionTracker(workspaceContext, isUsingLsp));
        if (isVirtualWorkspace && !dartCapabilities.supportsNonFileSchemeWorkspaces) {
            vs.window.showWarningMessage("Please upgrade to the latest Dart/Flutter SDK to prevent errors in workspaces with virtual folders");
        }
        vs.commands.executeCommand("setContext", constants_1.PUB_OUTDATED_SUPPORTED_CONTEXT, dartCapabilities.supportsPubOutdated);
        // Fire up Flutter daemon if required.
        if (workspaceContext.hasAnyFlutterMobileProjects && sdks.flutter) {
            flutterDaemon = new flutter_daemon_1.FlutterDaemon(logger, workspaceContext, flutterCapabilities);
            deviceManager = new device_manager_1.FlutterDeviceManager(logger, flutterDaemon, config_1.config);
            context.subscriptions.push(deviceManager);
            context.subscriptions.push(flutterDaemon);
            (0, daemon_message_handler_1.setUpDaemonMessageHandler)(logger, context, flutterDaemon);
            context.subscriptions.push(vs.commands.registerCommand("flutter.selectDevice", deviceManager.showDevicePicker, deviceManager));
            context.subscriptions.push(vs.commands.registerCommand("flutter.launchEmulator", deviceManager.promptForAndLaunchEmulator, deviceManager));
        }
        const pubApi = new api_1.PubApi(webClient);
        const pubGlobal = new global_1.PubGlobal(logger, dartCapabilities, extContext, sdks, pubApi);
        const sdkCommands = new sdk_1.SdkCommands(logger, extContext, workspaceContext, dartCapabilities);
        const dartCommands = new dart_2.DartCommands(logger, extContext, workspaceContext, sdkUtils, pubGlobal, dartCapabilities);
        const flutterCommands = new flutter_2.FlutterCommands(logger, extContext, workspaceContext, sdkUtils, dartCapabilities, flutterCapabilities, deviceManager);
        const packageCommands = new packages_1.PackageCommands(logger, extContext, workspaceContext, dartCapabilities);
        const addDependencyCommand = new add_dependency_1.AddDependencyCommand(logger, extContext, workspaceContext, dartCapabilities, pubApi);
        context.subscriptions.push(sdkCommands);
        context.subscriptions.push(dartCommands);
        context.subscriptions.push(flutterCommands);
        context.subscriptions.push(packageCommands);
        context.subscriptions.push(addDependencyCommand);
        const debugCommands = new debug_1.DebugCommands(logger, extContext, workspaceContext, dartCapabilities, flutterCapabilities, analytics, pubGlobal, flutterDaemon);
        context.subscriptions.push(debugCommands);
        // Handle new projects before creating the analyer to avoid a few issues with
        // showing errors while packages are fetched, plus issues like
        // https://github.com/Dart-Code/Dart-Code/issues/2793 which occur if the analyzer
        // is created too early.
        if (!isRestart)
            yield (0, user_prompts_1.handleNewProjects)(logger, extContext);
        // Fire up the analyzer process.
        const analyzerStartTime = new Date();
        analyzer = isUsingLsp ? new analyzer_lsp_1.LspAnalyzer(logger, sdks, dartCapabilities, workspaceContext) : new analyzer_das_1.DasAnalyzer(logger, analytics, sdks, dartCapabilities, workspaceContext);
        const lspAnalyzer = isUsingLsp ? analyzer : undefined;
        const dasAnalyzer = isUsingLsp ? undefined : analyzer;
        const dasClient = dasAnalyzer ? dasAnalyzer.client : undefined;
        const lspClient = dasClient ? undefined : analyzer.client;
        context.subscriptions.push(analyzer);
        // tslint:disable-next-line: no-floating-promises
        analyzer.onReady.then(() => {
            const analyzerEndTime = new Date();
            analytics.logAnalyzerStartupTime(analyzerEndTime.getTime() - analyzerStartTime.getTime());
        });
        // Log analysis server first analysis completion time when it completes.
        let analysisStartTime;
        const analysisCompleteEvents = analyzer.onAnalysisStatusChange.listen((status) => {
            // Analysis started for the first time.
            if (status.isAnalyzing && !analysisStartTime)
                analysisStartTime = new Date();
            // Analysis ends for the first time.
            if (!status.isAnalyzing && analysisStartTime) {
                const analysisEndTime = new Date();
                analytics.logAnalyzerFirstAnalysisTime(analysisEndTime.getTime() - analysisStartTime.getTime());
                analysisCompleteEvents.dispose();
            }
        });
        // Set up providers.
        // TODO: Do we need to push all these to subscriptions?!
        if (lspClient)
            context.subscriptions.push(new closing_labels_decorations_2.LspClosingLabelsDecorations(lspClient));
        const completionItemProvider = isUsingLsp || !dasClient ? undefined : new dart_completion_item_provider_1.DartCompletionItemProvider(logger, dasClient);
        const referenceProvider = isUsingLsp || !dasClient || !dasAnalyzer ? undefined : new dart_reference_provider_1.DartReferenceProvider(dasClient, dasAnalyzer.fileTracker);
        const activeFileFilters = [exports.DART_MODE];
        // Analyze Angular2 templates, requires the angular_analyzer_plugin.
        if (config_1.config.analyzeAngularTemplates) {
            activeFileFilters.push(HTML_MODE);
        }
        // Analyze files supported by plugins.
        for (const ext of (0, utils_1.uniq)(config_1.config.additionalAnalyzerFileExtensions)) {
            // We can't check that these don't overlap with the existing language filters
            // because vs.languages.match() won't take an extension, only a TextDocument.
            // So we'll just manually exclude file names we know for sure overlap with them.
            if (ext === "dart" || (config_1.config.analyzeAngularTemplates && (ext === "htm" || ext === "html")))
                continue;
            activeFileFilters.push({ scheme: "file", pattern: `**/*.${ext}` });
        }
        // This is registered with VS Code further down, so it's metadata can be collected from all
        // registered providers.
        const rankingCodeActionProvider = new ranking_code_action_provider_1.RankingCodeActionProvider();
        rankingCodeActionProvider.registerProvider(new add_dependency_code_action_provider_1.AddDependencyCodeActionProvider(exports.DART_MODE));
        const triggerCharacters = ".(${'\"/\\".split("");
        if (!isUsingLsp && dasClient) {
            context.subscriptions.push(vs.languages.registerHoverProvider(activeFileFilters, new dart_hover_provider_1.DartHoverProvider(logger, dasClient)));
            const formattingEditProvider = new dart_formatting_edit_provider_1.DartFormattingEditProvider(logger, dasClient, extContext);
            context.subscriptions.push(formattingEditProvider);
            formattingEditProvider.registerDocumentFormatter(activeFileFilters);
            // Only for Dart.
            formattingEditProvider.registerTypingFormatter(exports.DART_MODE, "}", ";");
        }
        if (completionItemProvider)
            context.subscriptions.push(vs.languages.registerCompletionItemProvider(activeFileFilters, completionItemProvider, ...triggerCharacters));
        if (referenceProvider) {
            context.subscriptions.push(vs.languages.registerDefinitionProvider(activeFileFilters, referenceProvider));
            context.subscriptions.push(vs.languages.registerReferenceProvider(activeFileFilters, referenceProvider));
        }
        let renameProvider;
        if (!isUsingLsp && dasClient && dasAnalyzer) {
            context.subscriptions.push(vs.languages.registerDocumentHighlightProvider(activeFileFilters, new dart_highlighting_provider_1.DartDocumentHighlightProvider(dasAnalyzer.fileTracker)));
            rankingCodeActionProvider.registerProvider(new assist_code_action_provider_1.AssistCodeActionProvider(logger, activeFileFilters, dasClient));
            rankingCodeActionProvider.registerProvider(new fix_code_action_provider_1.FixCodeActionProvider(logger, activeFileFilters, dasClient));
            rankingCodeActionProvider.registerProvider(new refactor_code_action_provider_1.RefactorCodeActionProvider(activeFileFilters, dasClient));
            renameProvider = new dart_rename_provider_1.DartRenameProvider(dasClient);
            context.subscriptions.push(vs.languages.registerRenameProvider(activeFileFilters, renameProvider));
            // Dart only.
            context.subscriptions.push(vs.languages.registerCodeActionsProvider(exports.DART_MODE, new source_code_action_provider_1.SourceCodeActionProvider(), source_code_action_provider_1.SourceCodeActionProvider.metadata));
            context.subscriptions.push(vs.languages.registerImplementationProvider(exports.DART_MODE, new dart_implementation_provider_1.DartImplementationProvider(dasAnalyzer)));
            if (config_1.config.showMainCodeLens) {
                const codeLensProvider = new main_code_lens_provider_1.MainCodeLensProvider(logger, dasAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(exports.DART_MODE, codeLensProvider));
            }
            if (config_1.config.showTestCodeLens) {
                const codeLensProvider = new test_code_lens_provider_1.TestCodeLensProvider(logger, dasAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(exports.DART_MODE, codeLensProvider));
            }
            if (config_1.config.showDartPadSampleCodeLens && sdks.flutter) {
                const codeLensProvider = new flutter_dartpad_samples_1.FlutterDartPadSamplesCodeLensProvider(logger, dasAnalyzer, sdks);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(exports.DART_MODE, codeLensProvider));
            }
        }
        if (isUsingLsp && lspClient && lspAnalyzer) {
            if (config_1.config.showMainCodeLens) {
                const codeLensProvider = new main_code_lens_provider_lsp_1.LspMainCodeLensProvider(logger, lspAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(exports.DART_MODE, codeLensProvider));
            }
            if (config_1.config.showTestCodeLens) {
                const codeLensProvider = new test_code_lens_provider_lsp_1.LspTestCodeLensProvider(logger, lspAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(exports.DART_MODE, codeLensProvider));
            }
            if (config_1.config.showDartPadSampleCodeLens && sdks.flutter) {
                const codeLensProvider = new flutter_dartpad_samples_lsp_1.LspFlutterDartPadSamplesCodeLensProvider(logger, lspAnalyzer, sdks);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(exports.DART_MODE, codeLensProvider));
            }
        }
        // Register the ranking provider from VS Code now that it has all of its delegates.
        context.subscriptions.push(vs.languages.registerCodeActionsProvider(activeFileFilters, rankingCodeActionProvider, rankingCodeActionProvider.metadata));
        // Task handlers.
        context.subscriptions.push(vs.tasks.registerTaskProvider(dart_task_provider_1.DartTaskProvider.type, new dart_task_provider_1.DartTaskProvider(logger, context, sdks, dartCapabilities)));
        context.subscriptions.push(vs.tasks.registerTaskProvider(flutter_task_provider_1.FlutterTaskProvider.type, new flutter_task_provider_1.FlutterTaskProvider(logger, context, sdks, flutterCapabilities)));
        // Snippets are language-specific
        context.subscriptions.push(vs.languages.registerCompletionItemProvider(exports.DART_MODE, new snippet_completion_item_provider_1.SnippetCompletionItemProvider("snippets/dart.json", () => true)));
        context.subscriptions.push(vs.languages.registerCompletionItemProvider(exports.DART_MODE, new snippet_completion_item_provider_1.SnippetCompletionItemProvider("snippets/flutter.json", (uri) => util.isInsideFlutterProject(uri))));
        context.subscriptions.push(vs.languages.setLanguageConfiguration(exports.DART_MODE.language, new dart_language_configuration_1.DartLanguageConfiguration()));
        // TODO: Push the differences into the Analyzer classes so we can have one reporter.
        if (lspClient)
            // tslint:disable-next-line: no-unused-expression
            new analyzer_status_reporter_2.LspAnalyzerStatusReporter(analyzer);
        if (dasClient)
            // tslint:disable-next-line: no-unused-expression
            new analyzer_status_reporter_1.AnalyzerStatusReporter(logger, dasClient, workspaceContext, analytics);
        context.subscriptions.push(new file_change_warnings_1.FileChangeWarnings());
        // Set up diagnostics.
        if (!isUsingLsp && dasClient) {
            const diagnostics = vs.languages.createDiagnosticCollection("dart");
            context.subscriptions.push(diagnostics);
            const diagnosticsProvider = new dart_diagnostic_provider_1.DartDiagnosticProvider(dasClient, diagnostics);
            // TODO: Currently calculating analysis roots requires the version to check if
            // we need the package workaround. In future if we stop supporting server < 1.20.1 we
            // can unwrap this call so that it'll start sooner.
            const serverConnected = dasClient.registerForServerConnected((sc) => {
                serverConnected.dispose();
                if (vs.workspace.workspaceFolders)
                    recalculateDasAnalysisRoots();
                // Set up a handler to warn the user if they open a Dart file and we
                // never set up the analyzer
                let hasWarnedAboutLooseDartFiles = false;
                const handleOpenFile = (d) => {
                    if (!hasWarnedAboutLooseDartFiles && d.languageId === "dart" && d.uri.scheme === "file" && analysisRoots.length === 0) {
                        hasWarnedAboutLooseDartFiles = true;
                        vs.window.showWarningMessage("For full Dart language support, please open a folder containing your Dart files instead of individual loose files");
                    }
                };
                context.subscriptions.push(vs.workspace.onDidOpenTextDocument((d) => handleOpenFile(d)));
                // Fire for editors already visible at the time this code runs.
                vs.window.visibleTextEditors.forEach((e) => handleOpenFile(e.document));
            });
            // Hook editor changes to send updated contents to analyzer.
            context.subscriptions.push(new file_change_handler_1.FileChangeHandler(dasClient));
        }
        util.logTime("All other stuff before debugger..");
        const testModel = new test_model_1.TestModel(config_1.config, util.isPathInsideFlutterProject);
        const testCoordinator = new coordinator_1.TestSessionCoordinator(logger, testModel, lspAnalyzer === null || lspAnalyzer === void 0 ? void 0 : lspAnalyzer.fileTracker);
        context.subscriptions.push(testCoordinator, vs.debug.onDidReceiveDebugSessionCustomEvent((e) => testCoordinator.handleDebugSessionCustomEvent(e.session.id, e.session.configuration.dartCodeDebugSessionID, e.event, e.body)), vs.debug.onDidTerminateDebugSession((session) => testCoordinator.handleDebugSessionEnd(session.id, session.configuration.dartCodeDebugSessionID)), vs.workspace.onDidChangeConfiguration((e) => testModel.handleConfigChange()));
        const testDiscoverer = lspAnalyzer ? new test_discoverer_1.TestDiscoverer(logger, lspAnalyzer.fileTracker, testModel) : undefined;
        if (testDiscoverer)
            context.subscriptions.push(testDiscoverer);
        const vsCodeTestController = ((_a = vs.tests) === null || _a === void 0 ? void 0 : _a.createTestController) !== undefined // Feature-detect for Theia
            ? new vs_test_controller_1.VsCodeTestController(logger, testModel, testDiscoverer)
            : undefined;
        if (vsCodeTestController)
            context.subscriptions.push(vsCodeTestController);
        const analyzerCommands = new analyzer_1.AnalyzerCommands(context, logger, analyzer, analytics);
        // Set up debug stuff.
        const debugProvider = new debug_config_provider_1.DebugConfigProvider(logger, workspaceContext, analytics, pubGlobal, testModel, flutterDaemon, deviceManager, debugCommands, dartCapabilities, flutterCapabilities);
        context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", debugProvider));
        const debugLogger = new debug_adapter_logger_factory_1.DartDebugAdapterLoggerFactory(logger);
        context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", debugLogger));
        const debugAdapterDescriptorFactory = new debug_adapter_descriptor_factory_1.DartDebugAdapterDescriptorFactory(sdks, logger, extContext);
        context.subscriptions.push(vs.debug.registerDebugAdapterDescriptorFactory("dart", debugAdapterDescriptorFactory));
        // Also the providers for the initial configs.
        if (vs.DebugConfigurationProviderTriggerKind) { // Temporary workaround for GitPod/Theia not having this enum.
            context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", new debug_config_provider_1.InitialLaunchJsonDebugConfigProvider(logger), vs.DebugConfigurationProviderTriggerKind.Initial));
            context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", new debug_config_provider_1.DynamicDebugConfigProvider(logger), vs.DebugConfigurationProviderTriggerKind.Dynamic));
        }
        if (config_1.config.flutterGutterIcons) {
            const colorDecorations = new flutter_color_decorations_1.FlutterColorDecorations(logger, path.join(context.globalStoragePath, "flutterColors"));
            context.subscriptions.push(colorDecorations);
            // If the server registers for colors and we see a request go out, then we should
            // remove our own handler.
            if (lspAnalyzer)
                lspAnalyzer.onDocumentColorsRequested.then(() => colorDecorations.dispose());
        }
        if (!isUsingLsp && dasClient && dasAnalyzer) {
            if (config_1.config.previewFlutterUiGuides)
                context.subscriptions.push(new flutter_ui_guides_decorations_das_1.FlutterUiGuideDecorationsDas(dasAnalyzer));
            if (config_1.config.flutterGutterIcons)
                context.subscriptions.push(new flutter_icon_decorations_das_1.FlutterIconDecorationsDas(logger, dasAnalyzer));
            // Setup that requires server version/capabilities.
            const connectedSetup = dasClient.registerForServerConnected((sc) => __awaiter(this, void 0, void 0, function* () {
                connectedSetup.dispose();
                context.subscriptions.push(new refactor_1.RefactorCommands(logger, context, dasClient));
                if (dasClient.capabilities.supportsClosingLabels && config_1.config.closingLabels) {
                    context.subscriptions.push(new closing_labels_decorations_1.ClosingLabelsDecorations(dasClient));
                }
                if (dasClient.capabilities.supportsGetDeclerations) {
                    context.subscriptions.push(vs.languages.registerWorkspaceSymbolProvider(new dart_workspace_symbol_provider_1.DartWorkspaceSymbolProvider(logger, dasClient)));
                }
                else {
                    context.subscriptions.push(vs.languages.registerWorkspaceSymbolProvider(new legacy_dart_workspace_symbol_provider_1.LegacyDartWorkspaceSymbolProvider(logger, dasClient)));
                }
                if (dasClient.capabilities.supportsCustomFolding && config_1.config.analysisServerFolding)
                    context.subscriptions.push(vs.languages.registerFoldingRangeProvider(activeFileFilters, new dart_folding_provider_1.DartFoldingProvider(dasAnalyzer)));
                if (dasClient.capabilities.supportsGetSignature)
                    context.subscriptions.push(vs.languages.registerSignatureHelpProvider(exports.DART_MODE, new dart_signature_help_provider_1.DartSignatureHelpProvider(dasClient), ...(config_1.config.triggerSignatureHelpAutomatically ? ["(", ","] : [])));
                const documentSymbolProvider = new dart_document_symbol_provider_1.DartDocumentSymbolProvider(logger, dasAnalyzer.fileTracker);
                activeFileFilters.forEach((filter) => {
                    context.subscriptions.push(vs.languages.registerDocumentSymbolProvider(filter, documentSymbolProvider));
                });
                // Set up completions for unimported items.
                if (dasClient.capabilities.supportsAvailableSuggestions && config_1.config.autoImportCompletions) {
                    yield dasClient.completionSetSubscriptions({
                        subscriptions: ["AVAILABLE_SUGGESTION_SETS"],
                    });
                }
            }));
        }
        else if (isUsingLsp && lspClient && lspAnalyzer) {
            if (config_1.config.previewFlutterUiGuides)
                context.subscriptions.push(new flutter_ui_guides_decorations_lsp_1.FlutterUiGuideDecorationsLsp(lspAnalyzer));
            if (config_1.config.flutterGutterIcons)
                context.subscriptions.push(new flutter_icon_decorations_lsp_1.FlutterIconDecorationsLsp(logger, lspAnalyzer));
        }
        // Handle config changes so we can reanalyze if necessary.
        context.subscriptions.push(vs.workspace.onDidChangeConfiguration(() => handleConfigurationChange(sdks)));
        // Wire up handling of Hot Reload on Save.
        context.subscriptions.push(new hot_reload_save_handler_1.HotReloadOnSaveHandler(debugCommands, flutterCapabilities));
        // Register URI handler.
        context.subscriptions.push(vs.window.registerUriHandler(new uri_handler_1.DartUriHandler(flutterCapabilities)));
        context.subscriptions.push(new logging_2.LoggingCommands(logger, context.logPath));
        context.subscriptions.push(new open_in_other_editors_1.OpenInOtherEditorCommands(logger, sdks));
        context.subscriptions.push(new test_1.TestCommands(logger, testModel, workspaceContext, vsCodeTestController, flutterCapabilities));
        if (lspClient && lspAnalyzer) {
            // TODO: LSP equivs of the others...
            // Refactors
            // TypeHierarchyCommand
            context.subscriptions.push(new go_to_super_2.LspGoToSuperCommand(lspAnalyzer));
        }
        // Set up commands for Dart editors.
        context.subscriptions.push(new edit_1.EditCommands());
        if (dasClient && dasAnalyzer) {
            context.subscriptions.push(new edit_das_1.DasEditCommands(logger, context, dasClient));
            context.subscriptions.push(new type_hierarchy_1.TypeHierarchyCommand(logger, dasClient));
            context.subscriptions.push(new go_to_super_1.GoToSuperCommand(dasAnalyzer));
        }
        else if (lspClient && lspAnalyzer) {
            context.subscriptions.push(new edit_lsp_1.LspEditCommands(lspAnalyzer));
        }
        if (vs.window.registerTerminalLinkProvider) // Temporary workaround for GitPod/Theia not having this.
            context.subscriptions.push(vs.window.registerTerminalLinkProvider(new link_provider_1.DartTerminalLinkProvider(logger, workspaceContext)));
        // Register our view providers.
        const dartPackagesProvider = new packages_view_1.DartPackagesProvider(logger, workspaceContext, dartCapabilities);
        context.subscriptions.push(dartPackagesProvider);
        const packagesTreeView = vs.window.createTreeView("dartDependencyTree", { treeDataProvider: dartPackagesProvider });
        context.subscriptions.push(packagesTreeView);
        let flutterOutlineTreeProvider;
        if (config_1.config.flutterOutline) {
            // TODO: Extract this out - it's become messy since TreeView was added in.
            flutterOutlineTreeProvider = dasAnalyzer ? new flutter_outline_view_1.DasFlutterOutlineProvider(dasAnalyzer) : new flutter_outline_view_1.LspFlutterOutlineProvider(lspAnalyzer);
            const tree = vs.window.createTreeView("dartFlutterOutline", { treeDataProvider: flutterOutlineTreeProvider, showCollapseAll: true });
            tree.onDidChangeSelection((e) => __awaiter(this, void 0, void 0, function* () {
                // TODO: This should be in a tree, not the data provider.
                yield flutterOutlineTreeProvider.setContexts(e.selection);
            }));
            context.subscriptions.push(vs.window.onDidChangeTextEditorSelection((e) => {
                if (e.selections && e.selections.length) {
                    const node = flutterOutlineTreeProvider.getNodeAt(e.textEditor.document.uri, e.selections[0].start);
                    if (node && tree.visible)
                        tree.reveal(node, { select: true, focus: false, expand: true });
                }
            }));
            context.subscriptions.push(tree);
            context.subscriptions.push(flutterOutlineTreeProvider);
            // TODO: This doesn't work for LSP!!!
            const flutterOutlineCommands = new flutter_outline_1.FlutterOutlineCommands(tree, context);
        }
        context.subscriptions.push(vs.commands.registerCommand("dart.package.openFile", (filePath) => {
            if (!filePath)
                return;
            vs.workspace.openTextDocument(filePath).then((document) => {
                vs.window.showTextDocument(document, { preview: true });
            }, (error) => logger.error(error));
        }));
        // Warn the user if they've opened a folder with mismatched casing.
        if (vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length) {
            for (const wf of vs.workspace.workspaceFolders) {
                if ((0, utils_2.warnIfPathCaseMismatch)(logger, (0, fs_1.fsPath)(wf.uri), "the open workspace folder", "re-open the folder using the File Open dialog"))
                    break;
            }
        }
        // Prompt user for any special config we might want to set.
        if (!isRestart)
            // tslint:disable-next-line: no-floating-promises
            (0, user_prompts_1.showUserPrompts)(logger, extContext, webClient, workspaceContext);
        // Turn on all the commands.
        setCommandVisiblity(true, workspaceContext);
        vs.commands.executeCommand("setContext", DART_PLATFORM_NAME, constants_1.dartPlatformName);
        // Prompt for pub get if required
        function checkForPackages() {
            // Don't prompt for package updates in the Fuchsia tree/Dart SDK repo.
            if (workspaceContext.config.disableAutomaticPackageGet)
                return;
            // tslint:disable-next-line: no-floating-promises
            packageCommands.fetchPackagesOrPrompt(undefined, { alwaysPrompt: true });
        }
        checkForPackages();
        // Begin activating dependant packages.
        if (workspaceContext.shouldLoadFlutterExtension) {
            const flutterExtension = vs.extensions.getExtension(constants_1.flutterExtensionIdentifier);
            if (flutterExtension) {
                logger.info(`Activating Flutter extension for ${workspaceContext.workspaceTypeDescription} project...`);
                // Do NOT await this.. the Flutter extension needs to wait for the Dart extension to finish activating
                // so that it can call its exported API, therefore we'll deadlock if we wait for the Flutter extension
                // to finish activating.
                flutterExtension.activate()
                    // Then rebuild log because it includes whether we activated Flutter.
                    .then(() => buildLogHeaders(logger, workspaceContextUnverified));
            }
        }
        // Log how long all this startup took.
        const extensionEndTime = new Date();
        if (isRestart) {
            analytics.logExtensionRestart(extensionEndTime.getTime() - extensionStartTime.getTime());
        }
        else {
            analytics.logExtensionStartup(extensionEndTime.getTime() - extensionStartTime.getTime());
        }
        // Handle changes to the workspace.
        // Set the roots, handling project changes that might affect SDKs.
        context.subscriptions.push(vs.workspace.onDidChangeWorkspaceFolders((f) => __awaiter(this, void 0, void 0, function* () {
            // First check if something changed that will affect our SDK, in which case
            // we'll perform a silent restart so that we do new SDK searches.
            const newWorkspaceContext = yield sdkUtils.scanWorkspace();
            if (newWorkspaceContext.hasAnyFlutterProjects !== workspaceContext.hasAnyFlutterProjects
                || newWorkspaceContext.hasProjectsInFuchsiaTree !== workspaceContext.hasProjectsInFuchsiaTree) {
                // tslint:disable-next-line: no-floating-promises
                util.promptToReloadExtension();
                return;
            }
            workspaceContext.events.onPackageMapChange.fire();
            if (!isUsingLsp)
                recalculateDasAnalysisRoots();
            checkForPackages();
        })));
        context.subscriptions.push((0, utils_2.createWatcher)("**/.packages", workspaceContext.events.onPackageMapChange));
        context.subscriptions.push((0, utils_2.createWatcher)("**/.dart_tool/package_config.json", workspaceContext.events.onPackageMapChange));
        workspaceContext.events.onPackageMapChange.fire();
        return Object.assign(Object.assign({}, new api_2.DartExtensionApi()), { [symbols_1.internalApiSymbol]: {
                addDependencyCommand,
                analyzer,
                analyzerCapabilities: dasClient && dasClient.capabilities,
                cancelAllAnalysisRequests: () => dasClient && dasClient.cancelAllRequests(),
                completionItemProvider,
                context: extContext,
                currentAnalysis: () => analyzer.onCurrentAnalysisComplete,
                daemonCapabilities: flutterDaemon ? flutterDaemon.capabilities : flutter_1.DaemonCapabilities.empty,
                dartCapabilities,
                debugAdapterDescriptorFactory,
                debugCommands,
                debugLogger,
                debugProvider,
                debugSessions: debug_1.debugSessions,
                deviceManager,
                envUtils: utils_2.envUtils,
                fileTracker: dasAnalyzer ? dasAnalyzer.fileTracker : (lspAnalyzer ? lspAnalyzer.fileTracker : undefined),
                flutterCapabilities,
                flutterOutlineTreeProvider,
                get isInImplementationFileThatCanHaveTest() { return test_1.isInImplementationFileThatCanHaveTest; },
                get isInTestFileThatHasImplementation() { return test_1.isInTestFileThatHasImplementation; },
                getLogHeader: log_1.getLogHeader,
                getOutputChannel: channels_1.getOutputChannel,
                initialAnalysis: analyzer.onInitialAnalysis,
                isLsp: isUsingLsp,
                logger,
                nextAnalysis: () => analyzer.onNextAnalysisComplete,
                packagesTreeProvider: dartPackagesProvider,
                pubGlobal,
                renameProvider,
                safeToolSpawn: processes_1.safeToolSpawn,
                testController: vsCodeTestController,
                testCoordinator,
                testDiscoverer,
                testModel,
                webClient,
                workspaceContext,
            } });
    });
}
exports.activate = activate;
function setupLog(logFile, category) {
    if (logFile)
        loggers.push((0, logging_1.captureLogs)(logger, logFile, (0, log_1.getLogHeader)(), config_1.config.maxLogLineLength, [category]));
}
function buildLogHeaders(logger, workspaceContext) {
    (0, log_1.clearLogHeader)();
    (0, log_1.addToLogHeader)(() => `!! PLEASE REVIEW THIS LOG FOR SENSITIVE INFORMATION BEFORE SHARING !!`);
    (0, log_1.addToLogHeader)(() => ``);
    (0, log_1.addToLogHeader)(() => `Dart Code extension: ${extension_utils_1.extensionVersion}`);
    (0, log_1.addToLogHeader)(() => {
        const ext = vs.extensions.getExtension(constants_1.flutterExtensionIdentifier);
        return `Flutter extension: ${ext.packageJSON.version} (${ext.isActive ? "" : "not "}activated)`;
    });
    (0, log_1.addToLogHeader)(() => ``);
    (0, log_1.addToLogHeader)(() => `App: ${vs.env.appName}`);
    if (vs.env.remoteName)
        (0, log_1.addToLogHeader)(() => `Remote: ${vs.env.remoteName}`);
    (0, log_1.addToLogHeader)(() => `Version: ${vs.version}`);
    (0, log_1.addToLogHeader)(() => `Platform: ${constants_1.platformDisplayName}`);
    if (workspaceContext) {
        (0, log_1.addToLogHeader)(() => ``);
        (0, log_1.addToLogHeader)(() => `Workspace type: ${workspaceContext.workspaceTypeDescription}`);
        (0, log_1.addToLogHeader)(() => `Analyzer type: ${workspaceContext.config.useLsp ? "LSP" : "DAS"}`);
        (0, log_1.addToLogHeader)(() => `Multi-root?: ${vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length > 1}`);
        const sdks = workspaceContext.sdks;
        (0, log_1.addToLogHeader)(() => ``);
        (0, log_1.addToLogHeader)(() => `Dart SDK:\n    Loc: ${sdks.dart}\n    Ver: ${sdks.dartVersion}`);
        (0, log_1.addToLogHeader)(() => `Flutter SDK:\n    Loc: ${sdks.flutter}\n    Ver: ${sdks.flutterVersion}`);
    }
    (0, log_1.addToLogHeader)(() => ``);
    (0, log_1.addToLogHeader)(() => `HTTP_PROXY: ${process.env.HTTP_PROXY}`);
    (0, log_1.addToLogHeader)(() => `NO_PROXY: ${process.env.NO_PROXY}`);
    // Any time the log headers are rebuilt, we should re-log them.
    logger === null || logger === void 0 ? void 0 : logger.info((0, log_1.getLogHeader)());
}
function recalculateDasAnalysisRoots() {
    const workspaceFolders = (0, utils_2.getDartWorkspaceFolders)();
    analysisRoots = workspaceFolders.map((w) => (0, fs_1.fsPath)(w.uri));
    // Sometimes people open their home directories as the workspace root and
    // have all sorts of performance issues because of PubCache and AppData folders
    // so we will exclude them if the user has opened a parent folder (opening a
    // child of these directly will still work).
    const excludeFolders = [];
    if (constants_1.isWin) {
        const addExcludeIfRequired = (folder) => {
            if (!folder || !path.isAbsolute(folder))
                return;
            const containingRoot = analysisRoots.find((root) => (0, fs_1.isWithinPath)(folder, root));
            if (containingRoot) {
                logger.info(`Excluding folder ${folder} from analysis roots as it is a child of analysis root ${containingRoot} and may cause performance issues.`);
                excludeFolders.push(folder);
            }
        };
        addExcludeIfRequired(process.env.PUB_CACHE);
        addExcludeIfRequired(process.env.APPDATA);
        addExcludeIfRequired(process.env.LOCALAPPDATA);
    }
    // For each workspace, handle excluded folders.
    workspaceFolders.forEach((f) => {
        for (const folder of util.getExcludedFolders(f))
            excludeFolders.push(folder);
    });
    // tslint:disable-next-line: no-floating-promises
    analyzer.client.analysisSetAnalysisRoots({
        excluded: excludeFolders,
        included: analysisRoots,
    });
}
function handleConfigurationChange(sdks) {
    // TODOs
    const newShowTodoSetting = config_1.config.showTodos;
    const todoSettingChanged = showTodos !== newShowTodoSetting;
    showTodos = newShowTodoSetting;
    // SDK
    const newSettings = getSettingsThatRequireRestart();
    const settingsChanged = previousSettings !== newSettings;
    previousSettings = newSettings;
    if (todoSettingChanged && analyzer instanceof analyzer_das_1.DasAnalyzer) {
        // tslint:disable-next-line: no-floating-promises
        analyzer.client.analysisReanalyze();
    }
    if (settingsChanged) {
        // Delay the restart slightly, because the config change may be transmitted to the LSP server
        // and shutting the server down too quickly results in that trying to write to a closed
        // stream.
        setTimeout(util.promptToReloadExtension, 50);
    }
}
function getSettingsThatRequireRestart() {
    var _a, _b;
    // The return value here is used to detect when any config option changes that requires a project reload.
    // It doesn't matter how these are combined; it just gets called on every config change and compared.
    // Usually these are options that affect the analyzer and need a reload, but config options used at
    // activation time will also need to be included.
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    return "CONF-"
        + config_1.config.sdkPath
        + ((_a = config_1.config.sdkPaths) === null || _a === void 0 ? void 0 : _a.length)
        + config_1.config.analyzerPath
        + config_1.config.analyzerDiagnosticsPort
        + config_1.config.analyzerVmServicePort
        + config_1.config.analyzerInstrumentationLogFile
        + config_1.config.extensionLogFile
        + config_1.config.analyzerAdditionalArgs
        + config_1.config.flutterSdkPath
        + ((_b = config_1.config.flutterSdkPaths) === null || _b === void 0 ? void 0 : _b.length)
        + config_1.config.flutterSelectDeviceWhenConnected
        + config_1.config.closingLabels
        + config_1.config.analyzeAngularTemplates
        + config_1.config.analysisServerFolding
        + config_1.config.showMainCodeLens
        + config_1.config.showTestCodeLens
        + config_1.config.updateImportsOnRename
        + config_1.config.previewBazelWorkspaceCustomScripts
        + config_1.config.flutterOutline
        + config_1.config.triggerSignatureHelpAutomatically
        + config_1.config.flutterAdbConnectOnChromeOs;
}
function deactivate(isRestart = false) {
    return __awaiter(this, void 0, void 0, function* () {
        setCommandVisiblity(false);
        analyzer === null || analyzer === void 0 ? void 0 : analyzer.dispose();
        yield (flutterDaemon === null || flutterDaemon === void 0 ? void 0 : flutterDaemon.shutdown());
        if (loggers) {
            yield Promise.all(loggers.map((logger) => logger.dispose()));
            loggers.length = 0;
        }
        vs.commands.executeCommand("setContext", exports.FLUTTER_SUPPORTS_ATTACH, false);
        if (!isRestart) {
            vs.commands.executeCommand("setContext", constants_1.HAS_LAST_DEBUG_CONFIG, false);
            vs.commands.executeCommand("setContext", constants_1.HAS_LAST_TEST_DEBUG_CONFIG, false);
            yield analytics.logExtensionShutdown();
            ringLogger === null || ringLogger === void 0 ? void 0 : ringLogger.dispose();
            logger.dispose();
        }
    });
}
exports.deactivate = deactivate;
function setCommandVisiblity(enable, workspaceContext) {
    vs.commands.executeCommand("setContext", PROJECT_LOADED, enable);
    vs.commands.executeCommand("setContext", DART_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyStandardDartProjects);
    vs.commands.executeCommand("setContext", FLUTTER_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyFlutterProjects);
    vs.commands.executeCommand("setContext", FLUTTER_MOBILE_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyFlutterMobileProjects);
    vs.commands.executeCommand("setContext", WEB_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyWebProjects);
}


/***/ }),

/***/ 5086:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setUpDaemonMessageHandler = void 0;
const vscode_1 = __webpack_require__(9496);
const channels_1 = __webpack_require__(1026);
function setUpDaemonMessageHandler(logger, context, daemon) {
    const channel = (0, channels_1.getOutputChannel)("flutter daemon", true);
    context.subscriptions.push(daemon.registerForDaemonLog((l) => {
        // Don't show, as we get errors from this just when disconnected devices!
        // channel.show(true);
        channel.appendLine(`${l.error ? "[ERR] " : ""}${l.log}`);
    }));
    context.subscriptions.push(daemon.registerForDaemonShowMessage((l) => {
        const title = l.title.trim().endsWith(".") ? l.title.trim() : `${l.title.trim()}.`;
        const message = `${title} ${l.message}`.trim();
        switch (l.level) {
            case "info":
                vscode_1.window.showInformationMessage(message);
                break;
            case "warning":
                vscode_1.window.showWarningMessage(message);
                break;
            case "error":
                vscode_1.window.showErrorMessage(message);
                break;
            default:
                logger.warn(`Unexpected daemon.showMessage type: ${l.level}`);
        }
    }));
}
exports.setUpDaemonMessageHandler = setUpDaemonMessageHandler;


/***/ }),

/***/ 5887:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterDaemon = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const flutter_1 = __webpack_require__(4790);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const stdio_service_1 = __webpack_require__(3058);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const extension_1 = __webpack_require__(1892);
const utils_3 = __webpack_require__(8779);
const misc_1 = __webpack_require__(9106);
const processes_1 = __webpack_require__(5430);
class FlutterDaemon extends stdio_service_1.StdIOService {
    constructor(logger, workspaceContext, flutterCapabilities) {
        var _a;
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.FlutterDaemon), config_1.config.maxLogLineLength, true, true);
        this.workspaceContext = workspaceContext;
        this.hasStarted = false;
        this.hasShownTerminationError = false;
        this.isShuttingDown = false;
        this.daemonStartedCompleter = new utils_1.PromiseCompleter();
        this.capabilities = flutter_1.DaemonCapabilities.empty;
        this.hasShownStartupError = false;
        // Subscription lists.
        this.daemonConnectedSubscriptions = [];
        this.deviceAddedSubscriptions = [];
        this.deviceRemovedSubscriptions = [];
        this.daemonLogMessageSubscriptions = [];
        this.daemonLogSubscriptions = [];
        this.daemonShowMessageSubscriptions = [];
        const folder = workspaceContext.sdks.flutter;
        this.registerForDaemonConnected((e) => {
            this.additionalPidsToTerminate.push(e.pid);
            this.capabilities.version = e.version;
            vs.commands.executeCommand("setContext", extension_1.FLUTTER_SUPPORTS_ATTACH, this.capabilities.canFlutterAttach);
            this.deviceEnable();
        });
        const daemonArgs = [];
        const showWebServer = config_1.config.flutterShowWebServerDevice === "always" || !utils_2.isRunningLocally;
        if (showWebServer && flutterCapabilities.supportsShowWebServerDevice)
            daemonArgs.push("--show-web-server-device");
        const execution = (0, utils_1.usingCustomScript)(path.join(workspaceContext.sdks.flutter, constants_1.flutterPath), ["daemon"].concat(daemonArgs), (_a = workspaceContext.config) === null || _a === void 0 ? void 0 : _a.flutterDaemonScript);
        const flutterAdditionalArgs = config_1.config.for(vs.Uri.file(folder)).flutterAdditionalArgs;
        const args = (0, processes_1.getGlobalFlutterArgs)().concat(flutterAdditionalArgs).concat(execution.args);
        this.createProcess(folder, execution.executable, args, { toolEnv: (0, processes_1.getToolEnv)() });
        if (constants_1.isChromeOS && config_1.config.flutterAdbConnectOnChromeOs) {
            logger.info("Running ADB Connect on Chrome OS");
            const adbConnectProc = (0, processes_1.safeToolSpawn)(undefined, "adb", ["connect", "100.115.92.2:5555"]);
            (0, logging_1.logProcess)(logger, enums_1.LogCategory.General, adbConnectProc);
        }
    }
    handleExit(code, signal) {
        if (code && !this.hasShownTerminationError && !this.isShuttingDown) {
            this.hasShownTerminationError = true;
            const message = this.hasStarted ? "has terminated" : "failed to start";
            // tslint:disable-next-line: no-floating-promises
            (0, utils_3.promptToReloadExtension)(`The Flutter Daemon ${message}.`, undefined, true);
        }
        super.handleExit(code, signal);
    }
    dispose() {
        this.isShuttingDown = true;
        super.dispose();
    }
    sendMessage(json) {
        try {
            super.sendMessage(json);
        }
        catch (e) {
            if (!this.hasShownTerminationError && !this.isShuttingDown) {
                this.hasShownTerminationError = true;
                // tslint:disable-next-line: no-floating-promises
                (0, utils_3.promptToReloadExtension)("The Flutter Daemon has terminated.", undefined, true);
                throw e;
            }
        }
    }
    shouldHandleMessage(message) {
        // Everything in flutter is wrapped in [] so we can tell what to handle.
        if (message.startsWith("[{") && message.endsWith("}]")) {
            // When we get the first message to handle, complete the status notifications.
            if (!this.hasStarted) {
                this.hasStarted = true;
                this.daemonStartedCompleter.resolve();
            }
            return true;
        }
        return false;
    }
    processUnhandledMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            let upgradeMessage;
            const matches = FlutterDaemon.outOfDateWarning.exec(message);
            if (matches && matches.length === 2)
                upgradeMessage = `Your installation of Flutter is ${matches[1]} days old.`;
            else if (message.indexOf(FlutterDaemon.newVersionMessage) !== -1)
                upgradeMessage = "A new version of Flutter is available";
            if (upgradeMessage) {
                if (yield vs.window.showWarningMessage(upgradeMessage, "Upgrade Flutter"))
                    vs.commands.executeCommand("flutter.upgrade");
                return;
            }
            if (!this.hasShownStartupError && message.startsWith("Flutter requires")) {
                this.logger.error(message, enums_1.LogCategory.FlutterDaemon);
                vs.window.showErrorMessage(message);
                this.hasShownStartupError = true;
                return;
            }
            // Show as progress message, this is likely "Building flutter tool" or "downloading Dart SDK" messages.
            if ((message.startsWith("Building ") || message.startsWith("Downloading ") || message.startsWith("Starting ") || message.startsWith("Running "))
                && !message.startsWith("Starting device daemon") // Don't show this one as it happens for normal startups too.
            ) {
                if (!this.hasStarted) {
                    if (this.startupReporter) {
                        this.startupReporter.report({ message });
                    }
                    else {
                        vs.window.withProgress({
                            location: vscode_1.ProgressLocation.Notification,
                            title: "Flutter Setup",
                        }, (progressReporter) => {
                            this.startupReporter = progressReporter;
                            this.startupReporter.report({ message });
                            return this.daemonStartedCompleter.promise;
                        });
                    }
                }
            }
        });
    }
    enablePlatformGlobally(platformType) {
        return __awaiter(this, void 0, void 0, function* () {
            const flutterSdkPath = this.workspaceContext.sdks.flutter;
            const binPath = path.join(flutterSdkPath, constants_1.flutterPath);
            const args = ["config", `--enable-${platformType}`];
            yield (0, processes_1.runToolProcess)(this.logger, flutterSdkPath, binPath, args);
        });
    }
    checkIfPlatformGloballyDisabled(platformType) {
        return __awaiter(this, void 0, void 0, function* () {
            const flutterSdkPath = this.workspaceContext.sdks.flutter;
            const value = yield (0, misc_1.getFlutterConfigValue)(this.logger, flutterSdkPath, flutterSdkPath, `enable-${platformType}`);
            // Only consider it disabled if it's specifically false (if it's not present, don't assume).
            return value === false;
        });
    }
    // TODO: Can we code-gen all this like the analysis server?
    handleNotification(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.event) {
                case "daemon.connected":
                    yield this.notify(this.daemonConnectedSubscriptions, evt.params);
                    break;
                case "device.added":
                    yield this.notify(this.deviceAddedSubscriptions, evt.params);
                    break;
                case "device.removed":
                    yield this.notify(this.deviceRemovedSubscriptions, evt.params);
                    break;
                case "daemon.logMessage":
                    yield this.notify(this.daemonLogMessageSubscriptions, evt.params);
                    break;
                case "daemon.log":
                    yield this.notify(this.daemonLogSubscriptions, evt.params);
                    break;
                case "daemon.showMessage":
                    yield this.notify(this.daemonShowMessageSubscriptions, evt.params);
                    break;
            }
        });
    }
    // Request methods.
    deviceEnable() {
        return this.sendRequest("device.enable");
    }
    getEmulators() {
        return this.sendRequest("emulator.getEmulators");
    }
    launchEmulator(emulatorId, coldBoot) {
        return this.sendRequest("emulator.launch", { emulatorId, coldBoot });
    }
    createEmulator(name) {
        return this.sendRequest("emulator.create", { name });
    }
    getSupportedPlatforms(projectRoot) {
        return this.sendRequest("daemon.getSupportedPlatforms", { projectRoot });
    }
    serveDevTools() {
        return this.sendRequest("devtools.serve");
    }
    shutdown() {
        return this.sendRequest("daemon.shutdown");
    }
    // Subscription methods.
    registerForDaemonConnected(subscriber) {
        return this.subscribe(this.daemonConnectedSubscriptions, subscriber);
    }
    registerForDeviceAdded(subscriber) {
        return this.subscribe(this.deviceAddedSubscriptions, subscriber);
    }
    registerForDeviceRemoved(subscriber) {
        return this.subscribe(this.deviceRemovedSubscriptions, subscriber);
    }
    registerForDaemonLogMessage(subscriber) {
        return this.subscribe(this.daemonLogMessageSubscriptions, subscriber);
    }
    registerForDaemonLog(subscriber) {
        return this.subscribe(this.daemonLogSubscriptions, subscriber);
    }
    registerForDaemonShowMessage(subscriber) {
        return this.subscribe(this.daemonShowMessageSubscriptions, subscriber);
    }
}
exports.FlutterDaemon = FlutterDaemon;
FlutterDaemon.outOfDateWarning = new RegExp("WARNING: .* Flutter is (\\d+) days old");
FlutterDaemon.newVersionMessage = "A new version of Flutter is available";


/***/ }),

/***/ 4942:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterWidgetItem = exports.LspFlutterOutlineProvider = exports.DasFlutterOutlineProvider = exports.FlutterOutlineProvider = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const extension_utils_1 = __webpack_require__(6143);
const mappings_1 = __webpack_require__(3978);
const utils_2 = __webpack_require__(7220);
const analyzer_das_1 = __webpack_require__(2061);
const flutter_outline_1 = __webpack_require__(9021);
const utils_3 = __webpack_require__(8779);
const DART_SHOW_FLUTTER_OUTLINE = "dart-code:showFlutterOutline";
const WIDGET_SELECTED_CONTEXT = "dart-code:isSelectedWidget";
const WIDGET_SUPPORTS_CONTEXT_PREFIX = "dart-code:widgetSupports:";
class FlutterOutlineProvider {
    constructor() {
        this.subscriptions = [];
        this.treeNodesByLine = [];
        this.onDidChangeTreeDataEmitter = new vs.EventEmitter();
        this.onDidChangeTreeData = this.onDidChangeTreeDataEmitter.event;
    }
    setTrackingFile(editor) {
        if (editor && (0, utils_3.isAnalyzable)(editor.document)) {
            this.activeEditor = editor;
            // tslint:disable-next-line: no-floating-promises
            this.loadExistingOutline();
        }
        else if (editor && editor.document.uri.scheme === "file") {
            // HACK: We can't currently reliably tell when editors are changed that are only real
            // text editors (debug window is considered an editor) so we should only hide the tree
            // when we know a file that is not ours is selected.
            // https://github.com/Microsoft/vscode/issues/45188
            this.activeEditor = undefined;
            FlutterOutlineProvider.hideTree();
        }
        else {
            // HACK: If there are no valid open editors, hide the tree.
            // The timeout is because the open editors disappear briefly during a closing
            // of one preview and opening of another :(
            // https://github.com/Microsoft/vscode/issues/45188.
            setTimeout(() => {
                if (!vs.window.visibleTextEditors.filter((e) => (0, utils_3.isAnalyzable)(e.document)).length) {
                    FlutterOutlineProvider.hideTree();
                }
            }, 100);
        }
    }
    setContexts(selection) {
        return __awaiter(this, void 0, void 0, function* () {
            // Unmark the old node as being selected.
            if (this.lastSelectedWidget) {
                this.lastSelectedWidget.contextValue = undefined;
                this.refresh(this.lastSelectedWidget);
            }
            // Clear all contexts that enabled refactors.
            for (const refactor of flutter_outline_1.flutterOutlineCommands) {
                vs.commands.executeCommand("setContext", WIDGET_SUPPORTS_CONTEXT_PREFIX + refactor, false);
            }
            // Set up the new contexts for our node and mark is as current.
            if (this.activeEditor && selection && selection.length === 1 && isWidget(selection[0].outline)) {
                const fixes = (yield getFixes(this.activeEditor, selection[0].outline))
                    .filter((f) => f instanceof vs.CodeAction)
                    .filter((ca) => ca.kind && ca.kind.value && flutter_outline_1.flutterOutlineCommands.indexOf(ca.kind.value) !== -1);
                // Stash the fixes, as we may need to call them later.
                selection[0].fixes = fixes;
                for (const fix of fixes)
                    vs.commands.executeCommand("setContext", WIDGET_SUPPORTS_CONTEXT_PREFIX + (fix.kind ? fix.kind.value : "NOKIND"), true);
                // Used so we can show context menu if you right-click the selected one.
                // We can't support arbitrary context menus, because we can't get the fixes up-front (see
                // https://github.com/dart-lang/sdk/issues/32462) so we fetch when you select an item
                // and then just support it if it's selected.
                selection[0].contextValue = WIDGET_SELECTED_CONTEXT;
                this.lastSelectedWidget = selection[0];
                this.refresh(selection[0]);
            }
        });
    }
    getNodeAt(uri, pos) {
        if (!this.activeEditor || !this.flutterOutline || (0, fs_1.fsPath)(this.activeEditor.document.uri) !== (0, fs_1.fsPath)(uri) || !this.treeNodesByLine[pos.line])
            return;
        const nodes = this.treeNodesByLine[pos.line];
        // We want the last node that started before the position (eg. most specific).
        let currentBest;
        for (const item of nodes) {
            const range = "range" in item.outline
                ? (0, utils_2.lspToRange)(item.outline.range)
                : (0, utils_2.toRange)(this.activeEditor.document, item.outline.offset, item.outline.length);
            if (range.contains(pos))
                currentBest = item;
        }
        if (currentBest === this.rootNode)
            return undefined; // Root node isn't actually in the tree.
        return currentBest;
    }
    refresh(item) {
        this.onDidChangeTreeDataEmitter.fire(item);
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (element)
            return element.children;
        if (this.rootNode)
            return this.rootNode.children;
        return [];
    }
    getParent(element) {
        return element.parent;
    }
    static setTreeVisible(visible) {
        vs.commands.executeCommand("setContext", DART_SHOW_FLUTTER_OUTLINE, visible);
    }
    static showTree() { this.setTreeVisible(true); }
    static hideTree() { this.setTreeVisible(false); }
    dispose() {
        this.activeEditor = undefined;
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.FlutterOutlineProvider = FlutterOutlineProvider;
class DasFlutterOutlineProvider extends FlutterOutlineProvider {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        this.analyzer.client.registerForServerConnected((c) => {
            if (analyzer.client.capabilities.supportsFlutterOutline) {
                this.analyzer.client.registerForFlutterOutline((n) => {
                    if (this.activeEditor && n.file === (0, fs_1.fsPath)(this.activeEditor.document.uri)) {
                        this.flutterOutline = n.outline;
                        this.treeNodesByLine = [];
                        // Delay this so if we're getting lots of updates we don't flicker.
                        if (this.updateTimeout)
                            clearTimeout(this.updateTimeout);
                        if (!this.rootNode)
                            // tslint:disable-next-line: no-floating-promises
                            this.update();
                        else
                            this.updateTimeout = setTimeout(() => this.update(), 200);
                    }
                });
                this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
                if (vs.window.activeTextEditor) {
                    this.setTrackingFile(vs.window.activeTextEditor);
                }
            }
        });
    }
    loadExistingOutline() {
        return __awaiter(this, void 0, void 0, function* () {
            this.flutterOutline = this.activeEditor ? this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri) : undefined;
            if (this.flutterOutline)
                yield this.update();
            else {
                this.rootNode = undefined;
                this.refresh(); // Force update (to nothing) while requests are in-flight.
            }
            if (this.activeEditor)
                this.analyzer.client.forceNotificationsFor((0, fs_1.fsPath)(this.activeEditor.document.uri));
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            // Build the tree from our outline
            if (this.flutterOutline) {
                this.rootNode = yield this.createTreeNode(undefined, this.flutterOutline, this.activeEditor);
                FlutterOutlineProvider.showTree();
            }
            else {
                this.rootNode = undefined;
                FlutterOutlineProvider.hideTree();
            }
            this.refresh();
        });
    }
    createTreeNode(parent, element, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure we're still active editor before trying to use.
            if (editor && editor.document && !editor.document.isClosed && this.activeEditor === editor) {
                const node = new FlutterWidgetItem(parent, element, editor);
                // Add this node to a lookup by line so we can quickly find it as the user moves around the doc.
                const startLine = editor.document.positionAt(element.offset).line;
                const endLine = editor.document.positionAt(element.offset + element.length).line;
                for (let line = startLine; line <= endLine; line++) {
                    if (!this.treeNodesByLine[line]) {
                        this.treeNodesByLine[line] = [];
                    }
                    this.treeNodesByLine[line].push(node);
                }
                if (element.children)
                    node.children = (yield Promise.all(element.children.map((c) => this.createTreeNode(node, c, editor)))).filter((n) => n).map((n) => n);
                return node;
            }
            return undefined;
        });
    }
}
exports.DasFlutterOutlineProvider = DasFlutterOutlineProvider;
class LspFlutterOutlineProvider extends FlutterOutlineProvider {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        this.analyzer.fileTracker.onFlutterOutline.listen((n) => {
            if (this.activeEditor && (0, fs_1.fsPath)(vs.Uri.parse(n.uri)) === (0, fs_1.fsPath)(this.activeEditor.document.uri)) {
                this.flutterOutline = n.outline;
                this.treeNodesByLine = [];
                // Delay this so if we're getting lots of updates we don't flicker.
                if (this.updateTimeout)
                    clearTimeout(this.updateTimeout);
                if (!this.rootNode)
                    // tslint:disable-next-line: no-floating-promises
                    this.update();
                else
                    this.updateTimeout = setTimeout(() => this.update(), 200);
            }
        });
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
        if (vs.window.activeTextEditor) {
            this.setTrackingFile(vs.window.activeTextEditor);
        }
    }
    loadExistingOutline() {
        return __awaiter(this, void 0, void 0, function* () {
            this.flutterOutline = this.activeEditor ? this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri) : undefined;
            if (this.flutterOutline)
                yield this.update();
            else {
                this.rootNode = undefined;
                this.refresh(); // Force update (to nothing) while requests are in-flight.
            }
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            // Build the tree from our outline
            if (this.flutterOutline) {
                this.rootNode = yield this.createTreeNode(undefined, this.flutterOutline, this.activeEditor);
                FlutterOutlineProvider.showTree();
            }
            else {
                this.rootNode = undefined;
                FlutterOutlineProvider.hideTree();
            }
            this.refresh();
        });
    }
    createTreeNode(parent, outline, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure we're still active editor before trying to use.
            if (editor && editor.document && !editor.document.isClosed && this.activeEditor === editor) {
                const node = new FlutterWidgetItem(parent, outline, editor);
                // Add this node to a lookup by line so we can quickly find it as the user moves around the doc.
                const startLine = outline.range.start.line;
                const endLine = outline.range.end.line;
                for (let line = startLine; line <= endLine; line++) {
                    if (!this.treeNodesByLine[line]) {
                        this.treeNodesByLine[line] = [];
                    }
                    this.treeNodesByLine[line].push(node);
                }
                if (outline.children)
                    node.children = (yield Promise.all(outline.children.map((c) => this.createTreeNode(node, c, editor)))).filter((n) => n).map((n) => n);
                return node;
            }
            return undefined;
        });
    }
}
exports.LspFlutterOutlineProvider = LspFlutterOutlineProvider;
function isWidget(outline) {
    return outline.kind !== "DART_ELEMENT";
}
function getFixes(editor, outline) {
    return __awaiter(this, void 0, void 0, function* () {
        const pos = "range" in outline
            ? (0, utils_2.lspToPosition)(outline.range.start)
            : editor.document.positionAt(outline.offset);
        const range = new vs.Range(pos, pos);
        const fixes = yield vs.commands.executeCommand("vscode.executeCodeActionProvider", editor.document.uri, range);
        return fixes || [];
    });
}
class FlutterWidgetItem extends vs.TreeItem {
    constructor(parent, outline, editor) {
        super(FlutterWidgetItem.getLabel(outline), (outline.children && outline.children.length)
            ? vs.TreeItemCollapsibleState.Expanded
            : vs.TreeItemCollapsibleState.None);
        this.parent = parent;
        this.outline = outline;
        this.children = [];
        this.fixes = [];
        this.description = FlutterWidgetItem.getDescription(outline);
        if (isWidget(outline)) {
            this.iconPath = vs.Uri.file(path.join(extension_utils_1.extensionPath, "media/icons/flutter_widget.svg"));
        }
        else if (outline.dartElement) {
            const icon = (0, mappings_1.getIconForSymbolKind)((0, analyzer_das_1.getSymbolKindForElementKind)(logging_1.nullLogger, outline.dartElement.kind));
            this.iconPath = {
                dark: vs.Uri.file(path.join(extension_utils_1.extensionPath, `media/icons/vscode_symbols/${icon}-dark.svg`)),
                light: vs.Uri.file(path.join(extension_utils_1.extensionPath, `media/icons/vscode_symbols/${icon}-light.svg`)),
            };
        }
        const displayRange = "range" in outline
            ? outline.range
            : new vs.Range(editor.document.positionAt(outline.offset), editor.document.positionAt(outline.offset + outline.length));
        const highlightRange = "codeRange" in outline
            ? outline.codeRange
            : new vs.Range(editor.document.positionAt(outline.codeOffset), editor.document.positionAt(outline.codeOffset + outline.codeLength));
        const selectionPos = "range" in outline
            ? outline.dartElement && outline.dartElement.range
                ? (0, utils_2.lspToPosition)(outline.dartElement.range.start)
                : (0, utils_2.lspToPosition)(outline.range.start)
            : outline.dartElement && outline.dartElement.location && outline.dartElement.location.offset
                ? editor.document.positionAt(outline.dartElement.location.offset)
                : editor.document.positionAt(outline.offset);
        this.command = {
            arguments: [
                editor,
                // Code to fit on screen
                displayRange,
                // Code to highlight
                highlightRange,
                // Selection (we just want to move cursor, so it's 0-length)
                new vs.Range(selectionPos, selectionPos),
            ],
            command: "_dart.showCode",
            title: "",
        };
        this.tooltip = (0, utils_2.treeLabel)(this);
        if (outline.attributes && outline.attributes.length) {
            this.tooltip += "\n  " + outline.attributes.map((a) => `${a.name}: ${a.label}`).join("\n   ");
        }
    }
    static getLabel(outline) {
        let label = "";
        if (outline.dartElement) {
            label += " " + outline.dartElement.name;
            if (outline.dartElement.typeParameters)
                label += outline.dartElement.typeParameters;
        }
        if (outline.variableName)
            label += " " + outline.variableName;
        if (outline.className)
            label += " " + outline.className;
        if (outline.label)
            label += " " + outline.label;
        return label.trim();
    }
    static getDescription(outline) {
        var _a, _b;
        let label = "";
        if (outline.dartElement) {
            if (outline.dartElement.parameters)
                label += outline.dartElement.parameters;
            if (outline.dartElement.returnType)
                label += "  " + outline.dartElement.returnType;
        }
        // Prefer an attribute named "data", but otherwise try some others
        // in order that appear useful.
        const attributeToShow = ((_a = outline.attributes) === null || _a === void 0 ? void 0 : _a.find((a) => a.name === "data"))
            || ((_b = outline.attributes) === null || _b === void 0 ? void 0 : _b.find((a) => a.name === "icon" || a.name === "value"));
        if (attributeToShow)
            label += " " + attributeToShow.label;
        return label.trim();
    }
}
exports.FlutterWidgetItem = FlutterWidgetItem;


/***/ }),

/***/ 9476:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterTaskProvider = void 0;
const utils_1 = __webpack_require__(5820);
const utils_2 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
const utils_3 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const dart_task_provider_1 = __webpack_require__(4530);
const utils_4 = __webpack_require__(8779);
class FlutterTaskProvider extends dart_task_provider_1.BaseTaskProvider {
    constructor(logger, context, sdks, flutterCapabilities) {
        super(logger, context, sdks);
        this.flutterCapabilities = flutterCapabilities;
    }
    get type() { return FlutterTaskProvider.type; }
    provideTasks(token) {
        return __awaiter(this, void 0, void 0, function* () {
            const dartProjects = (0, utils_3.getDartWorkspaceFolders)();
            let promises = [];
            dartProjects.forEach((folder) => {
                const isFlutter = (0, utils_4.isFlutterWorkspaceFolder)(folder);
                if (isFlutter) {
                    promises = promises.concat(this.createSharedTasks(folder));
                    promises.push(this.createTask(folder, "flutter", ["build", "apk"]));
                    promises.push(this.createTask(folder, "flutter", ["build", "ios"]));
                    promises.push(this.createTask(folder, "flutter", ["build", "macos"]));
                    promises.push(this.createTask(folder, "flutter", ["build", "web"]));
                    promises.push(this.createTask(folder, "flutter", ["install"]));
                }
            });
            const tasks = (yield Promise.all(promises)).filter(utils_2.notUndefined);
            return tasks;
        });
    }
    createPubTask(folder, args) {
        return this.createTask(folder, "flutter", ["pub", ...args]);
    }
    injectArgs(definition) {
        var _a;
        definition.args = (_a = definition.args) !== null && _a !== void 0 ? _a : [];
        if (definition.command === "flutter") {
            // Inject web-renderer if required.
            const isWebBuild = (0, array_1.arrayStartsWith)(definition.args, ["build", "web"]);
            if (isWebBuild && !definition.args.includes("--web-renderer")) {
                const renderer = (0, utils_1.getFutterWebRenderer)(this.flutterCapabilities, config_1.config.flutterWebRenderer);
                if (renderer) {
                    definition.args.push("--web-renderer");
                    definition.args.push(renderer);
                }
            }
        }
    }
}
exports.FlutterTaskProvider = FlutterTaskProvider;
FlutterTaskProvider.type = "flutter"; // also referenced in package.json


/***/ }),

/***/ 7253:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VmServiceExtensions = exports.timeDilationSlow = exports.timeDilationNormal = exports.IS_INSPECTING_WIDGET_CONTEXT = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(7220);
const debug_1 = __webpack_require__(4635);
const extension_1 = __webpack_require__(1892);
const utils_2 = __webpack_require__(8779);
exports.IS_INSPECTING_WIDGET_CONTEXT = "dart-code:flutter.isInspectingWidget";
const keyTimeDilation = "timeDilation";
const keyEnabled = "enabled";
const keyValue = "value";
/// Service extension values must be wrapped in objects when sent to the VM, eg:
///
///     { timeDilation: x.x }
///     { enabled: true }
///
/// This map tracks the name of the key for a given extension.
const toggleExtensionStateKeys = {
    [enums_1.VmServiceExtension.PlatformOverride]: keyValue,
    [enums_1.VmServiceExtension.DebugBanner]: keyEnabled,
    [enums_1.VmServiceExtension.CheckElevations]: keyEnabled,
    [enums_1.VmServiceExtension.DebugPaint]: keyEnabled,
    [enums_1.VmServiceExtension.PaintBaselines]: keyEnabled,
    [enums_1.VmServiceExtension.InspectorSelectMode]: keyEnabled,
    [enums_1.VmServiceExtension.BrightnessOverride]: keyValue,
    [enums_1.VmServiceExtension.RepaintRainbow]: keyEnabled,
    [enums_1.VmServiceExtension.PerformanceOverlay]: keyEnabled,
    [enums_1.VmServiceExtension.SlowAnimations]: keyTimeDilation,
};
exports.timeDilationNormal = 1.0;
exports.timeDilationSlow = 5.0;
/// Manages state for (mostly Flutter) VM service extensions.
class VmServiceExtensions {
    constructor(logger, debugCommands) {
        this.logger = logger;
        this.debugCommands = debugCommands;
        this.registeredServices = {};
        this.loadedServiceExtensions = [];
        this.loadedServiceExtensionIsolateIds = new Map();
        /// Extension values owned by us. If someone else updates a value, we should
        /// remove it from here.
        this.currentExtensionValues = {};
        this.debugCommands.onWillHotRestart(() => this.markAllServiceExtensionsUnloaded());
    }
    /// Handles an event from the Debugger, such as extension services being loaded and values updated.
    handleDebugEvent(session, e) {
        return __awaiter(this, void 0, void 0, function* () {
            if (e.event === "dart.serviceExtensionAdded") {
                this.handleServiceExtensionLoaded(session, e.body.extensionRPC, e.body.isolateId);
                try {
                    if (e.body.extensionRPC === enums_1.VmServiceExtension.InspectorSetPubRootDirectories) {
                        const projectFolders = yield (0, utils_1.getAllProjectFolders)(this.logger, utils_2.getExcludedFolders, { requirePubspec: true });
                        const params = {
                            // TODO: Is this OK???
                            isolateId: e.body.isolateId,
                        };
                        let argNum = 0;
                        for (const projectFolder of projectFolders) {
                            params[`arg${argNum++}`] = projectFolder;
                            if (constants_1.isWin)
                                params[`arg${argNum++}`] = this.formatPathForPubRootDirectories(projectFolder);
                        }
                        yield this.callServiceExtension(e.session, enums_1.VmServiceExtension.InspectorSetPubRootDirectories, params);
                    }
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
            else if (e.event === "dart.serviceRegistered") {
                this.handleServiceRegistered(e.body.service, e.body.method);
            }
            else if (e.event === "flutter.serviceExtensionStateChanged") {
                this.handleRemoteValueUpdate(e.body.extension, e.body.value);
            }
        });
    }
    // TODO: Remove this function (and the call to it) once the fix has rolled to Flutter beta.
    // https://github.com/flutter/flutter-intellij/issues/2217
    formatPathForPubRootDirectories(path) {
        return constants_1.isWin
            ? path && `file:///${path.replace(/\\/g, "/")}`
            : path;
    }
    overridePlatform() {
        return __awaiter(this, void 0, void 0, function* () {
            const selection = yield vs.window.showQuickPick([
                { label: "Android", platform: "android" },
                { label: "iOS", platform: "iOS" },
                { label: "macOS", platform: "macOS" },
                { label: "Windows", platform: "windows" },
                { label: "Linux", platform: "linux" },
            ]);
            if (!selection)
                return;
            // Pass the same value for both options as we will always set it.
            return this.toggle(enums_1.VmServiceExtension.PlatformOverride, selection.platform, selection.platform);
        });
    }
    /// Toggles between two values. Always picks the value1 if the current value
    /// is not already value1 (eg. if it's neither of those, it'll pick val1).
    toggle(id, val1 = true, val2 = false) {
        return __awaiter(this, void 0, void 0, function* () {
            /// Helper that toggles for one session.
            const toggleForSession = (session) => __awaiter(this, void 0, void 0, function* () {
                const newValue = val1 === val2
                    ? val1
                    : (yield this.getCurrentServiceExtensionValue(session.session, id)) !== val1
                        ? val1
                        : val2;
                this.currentExtensionValues[id] = newValue;
                yield this.sendExtensionValue(session.session, id, newValue);
            });
            yield Promise.all(debug_1.debugSessions.map((session) => toggleForSession(session).catch((e) => this.logger.error(e))));
        });
    }
    getCurrentServiceExtensionValue(session, method) {
        return __awaiter(this, void 0, void 0, function* () {
            const responseBody = yield this.callServiceExtension(session, method);
            return this.extractServiceValue(responseBody[toggleExtensionStateKeys[method]]);
        });
    }
    sendExtensionValue(session, method, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = { [toggleExtensionStateKeys[method]]: value };
            yield this.callServiceExtension(session, method, params);
        });
    }
    callServiceExtension(session, method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(params === null || params === void 0 ? void 0 : params.isolateId)) {
                params = params || {};
                params.isolateId = this.loadedServiceExtensionIsolateIds.get(method);
            }
            return yield session.customRequest("callService", { method, params });
        });
    }
    syncContextStates(id, value) {
        if (id === enums_1.VmServiceExtension.InspectorSelectMode) {
            /// Keep the context in sync so that the "Cancel Inspect Widget" command is enabled/disabled.
            vs.commands.executeCommand("setContext", exports.IS_INSPECTING_WIDGET_CONTEXT, !!value);
        }
    }
    /// Handles updates that come from the VM (eg. were updated by another tool).
    handleRemoteValueUpdate(id, value) {
        this.syncContextStates(id, value);
        // Don't try to process service extension we don't know about.
        if (this.currentExtensionValues[id] === undefined)
            return;
        value = this.extractServiceValue(value);
        // If someone else updated it to something different to the value we're
        // overriding, then remove our override.
        if (this.currentExtensionValues[id] !== value)
            delete this.currentExtensionValues[id];
    }
    extractServiceValue(value) {
        // HACK: Everything comes through as strings, but we need bools/ints and sometimes strings,
        // so attempt to parse it, but keep the original string in the case of failure.
        if (typeof value === "string") {
            try {
                value = JSON.parse(value);
            }
            catch (_a) {
            }
        }
        return value;
    }
    /// Resets all local state to defaults - used when terminating the last debug session (or
    // starting the first) to ensure debug toggles don't "persist" across sessions.
    resetToDefaults() {
        this.currentExtensionValues = {};
    }
    /// Tracks registered services and updates contexts to enable VS Code commands.
    handleServiceRegistered(service, method) {
        this.registeredServices[service] = method;
        vs.commands.executeCommand("setContext", `${extension_1.SERVICE_CONTEXT_PREFIX}${service}`, true);
    }
    /// Tracks loaded service extensions and updates contexts to enable VS Code commands.
    handleServiceExtensionLoaded(session, extensionRPC, isolateId) {
        session.loadedServiceExtensions.push(extensionRPC);
        this.loadedServiceExtensions.push(extensionRPC);
        if (isolateId)
            this.loadedServiceExtensionIsolateIds.set(extensionRPC, isolateId);
        vs.commands.executeCommand("setContext", `${extension_1.SERVICE_EXTENSION_CONTEXT_PREFIX}${extensionRPC}`, true);
        // If this extension is one we have an override value for, then this must be the extension loading
        // for a new isolate (perhaps after a restart), so send its value.
        // Only ever send values for enabled and known extensions.
        const isTogglableService = toggleExtensionStateKeys[extensionRPC] !== undefined;
        const value = this.currentExtensionValues[extensionRPC];
        const hasValue = value !== undefined;
        if (isTogglableService && hasValue)
            this.sendExtensionValue(session.session, extensionRPC, value).catch((e) => this.logger.error(e));
    }
    /// Marks all services as not-loaded (happens after session ends).
    markAllServicesUnloaded() {
        for (const id of Object.keys(this.registeredServices)) {
            vs.commands.executeCommand("setContext", `${extension_1.SERVICE_CONTEXT_PREFIX}${id}`, undefined);
        }
        this.registeredServices = {};
    }
    /// Marks all service extensions as not-loaded (happens after session ends or after hot restart).
    markAllServiceExtensionsUnloaded() {
        for (const id of this.loadedServiceExtensions) {
            vs.commands.executeCommand("setContext", `${extension_1.SERVICE_EXTENSION_CONTEXT_PREFIX}${id}`, undefined);
        }
        this.loadedServiceExtensions.length = 0;
        this.loadedServiceExtensionIsolateIds.clear();
    }
    // TODO: These services should be per-session!
    serviceIsRegistered(service) {
        return !!this.registeredServices[service];
    }
    getServiceMethodName(service) {
        return this.registeredServices[service];
    }
    serviceExtensionIsLoaded(id) {
        return !!this.loadedServiceExtensions.find((loadedID) => loadedID === id);
    }
}
exports.VmServiceExtensions = VmServiceExtensions;


/***/ }),

/***/ 7428:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspAnalyzerStatusReporter = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
// TODO: Remove this class once Flutter Stable has an LSP server that uses $/progress.
class LspAnalyzerStatusReporter {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.analysisInProgress = false;
        analyzer.onAnalysisStatusChange.listen((params) => this.handleServerStatus(params));
    }
    handleServerStatus(params) {
        if (params.suppressProgress) {
            return;
        }
        this.analysisInProgress = params.isAnalyzing;
        if (this.analysisInProgress) {
            // Debounce short analysis times.
            setTimeout(() => {
                // When the timeout fires, we need to check analysisInProgress again in case
                // analysis has already finished.
                if (this.analysisInProgress && !this.analyzingPromise) {
                    vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, title: "Analyzing" }, () => {
                        if (!this.analyzingPromise) // Re-check, since we don't know how long before this callback is called.
                            this.analyzingPromise = new utils_1.PromiseCompleter();
                        return this.analyzingPromise.promise;
                    });
                }
            }, 100);
        }
        else {
            if (this.analyzingPromise) {
                this.analyzingPromise.resolve();
                this.analyzingPromise = undefined;
            }
        }
    }
}
exports.LspAnalyzerStatusReporter = LspAnalyzerStatusReporter;


/***/ }),

/***/ 3088:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspClosingLabelsDecorations = void 0;
const vs = __webpack_require__(9496);
const custom_protocol_1 = __webpack_require__(556);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const closing_labels_decorations_1 = __webpack_require__(1326);
class LspClosingLabelsDecorations {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.subscriptions = [];
        this.closingLabels = {};
        this.editors = {};
        this.decorationType = vs.window.createTextEditorDecorationType({
            after: {
                color: new vs.ThemeColor("dart.closingLabels"),
                margin: "2px",
            },
            rangeBehavior: vs.DecorationRangeBehavior.ClosedOpen,
        });
        // tslint:disable-next-line: no-floating-promises
        analyzer.onReady().then(() => {
            this.analyzer.onNotification(custom_protocol_1.PublishClosingLabelsNotification.type, (n) => {
                const filePath = (0, fs_1.fsPath)(vs.Uri.parse(n.uri));
                this.closingLabels[filePath] = n;
                // Fire an update if it was for the active document.
                if (vs.window.activeTextEditor
                    && vs.window.activeTextEditor.document
                    && filePath === (0, fs_1.fsPath)(vs.window.activeTextEditor.document.uri)) {
                    // Delay this so if we're getting lots of updates we don't flicker.
                    if (this.updateTimeout)
                        clearTimeout(this.updateTimeout);
                    this.updateTimeout = setTimeout(() => this.update(), 500);
                }
            });
        });
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor(() => this.update()));
        this.subscriptions.push(vs.workspace.onDidCloseTextDocument((td) => {
            const filePath = (0, fs_1.fsPath)(td.uri);
            delete this.closingLabels[filePath];
        }));
        if (vs.window.activeTextEditor)
            this.update();
    }
    update() {
        const editor = vs.window.activeTextEditor;
        if (!editor || !editor.document)
            return;
        const filePath = (0, fs_1.fsPath)(editor.document.uri);
        if (!this.closingLabels[filePath])
            return;
        const decorations = [];
        for (const r of this.closingLabels[filePath].labels) {
            const labelRange = this.analyzer.protocol2CodeConverter.asRange(r.range);
            // Ensure the label we got looks like a sensible range, otherwise the outline info
            // might be stale (eg. we sent two updates, and the outline from in between them just
            // arrived). In this case, we'll just bail and do nothing, assuming a future update will
            // have the correct info.
            const finalCharacterPosition = labelRange.end;
            if (finalCharacterPosition.character < 1)
                return;
            const finalCharacterRange = new vs.Range(finalCharacterPosition.translate({ characterDelta: -1 }), finalCharacterPosition);
            const finalCharacterText = editor.document.getText(finalCharacterRange);
            if (closing_labels_decorations_1.validLastCharacters.indexOf(finalCharacterText) === -1)
                return;
            // Get the end of the line where we'll show the labels.
            const endOfLine = editor.document.lineAt(finalCharacterPosition).range.end;
            const existingDecorationForLine = decorations[endOfLine.line];
            if (existingDecorationForLine) {
                existingDecorationForLine.renderOptions.after.contentText = " // " + r.label + " " + existingDecorationForLine.renderOptions.after.contentText;
            }
            else {
                const dec = {
                    range: new vs.Range(labelRange.start, endOfLine),
                    renderOptions: { after: { contentText: " // " + r.label } },
                };
                decorations[endOfLine.line] = dec;
            }
        }
        this.editors[filePath] = editor;
        editor.setDecorations(this.decorationType, Object.keys(decorations).map((k) => parseInt(k, 10)).map((k) => decorations[k]));
    }
    dispose() {
        for (const editor of Object.values(this.editors)) {
            try {
                editor.setDecorations(this.decorationType, []);
            }
            catch (_a) {
                // It's possible the editor was closed, but there
                // doesn't seem to be a way to tell.
            }
        }
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.LspClosingLabelsDecorations = LspClosingLabelsDecorations;


/***/ }),

/***/ 9982:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspGoToSuperCommand = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
const editors = __webpack_require__(8805);
class LspGoToSuperCommand {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.goToSuper", this.goToSuper, this));
    }
    goToSuper() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = editors.getActiveDartEditor();
            if (!editor) {
                vs.window.showWarningMessage("No active Dart editor.");
                return;
            }
            const location = yield this.analyzer.getSuper({
                position: this.analyzer.client.code2ProtocolConverter.asPosition(editor.selection.start),
                textDocument: this.analyzer.client.code2ProtocolConverter.asVersionedTextDocumentIdentifier(editor.document),
            });
            if (!location)
                return;
            const codeLocation = this.analyzer.client.protocol2CodeConverter.asLocation(location);
            const elementDocument = yield vs.workspace.openTextDocument(codeLocation.uri);
            const elementEditor = yield vs.window.showTextDocument(elementDocument);
            (0, utils_2.showCode)(elementEditor, codeLocation.range, codeLocation.range, codeLocation.range);
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspGoToSuperCommand = LspGoToSuperCommand;


/***/ }),

/***/ 3747:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// TODO: Move this to Shared (and remove dependencies on extension/)
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestDiscoverer = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const test_model_1 = __webpack_require__(1159);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const outline_lsp_1 = __webpack_require__(4215);
const test_1 = __webpack_require__(8729);
const utils_2 = __webpack_require__(7220);
const utils_3 = __webpack_require__(8779);
class TestDiscoverer {
    constructor(logger, fileTracker, model) {
        this.logger = logger;
        this.fileTracker = fileTracker;
        this.model = model;
        this.disposables = [];
        this.debounceTimers = {};
        this.debounceDuration = 1500;
        this.disposables.push(fileTracker.onOutline.listen((o) => this.handleOutline(o)));
    }
    beginTestDiscovery() {
        // Set up events for create/rename/delete.
        this.disposables.push(vs.workspace.onDidCreateFiles((e) => {
            e.files.forEach((file) => {
                const filePath = (0, fs_1.fsPath)(file);
                if ((0, utils_3.isTestFile)(filePath))
                    this.model.suiteDiscovered(undefined, filePath);
            });
        }), vs.workspace.onDidRenameFiles((e) => __awaiter(this, void 0, void 0, function* () {
            e.files.forEach((file) => __awaiter(this, void 0, void 0, function* () {
                this.model.clearSuiteOrDirectory((0, fs_1.fsPath)(file.oldUri));
                this.discoverTests((0, fs_1.fsPath)(file.newUri));
            }));
        })), vs.workspace.onDidDeleteFiles((e) => __awaiter(this, void 0, void 0, function* () {
            e.files.forEach((file) => __awaiter(this, void 0, void 0, function* () {
                this.model.clearSuiteOrDirectory((0, fs_1.fsPath)(file));
            }));
        })));
        // Process any existing things in the workspace.
        try {
            const workspaceFolders = (0, utils_2.getDartWorkspaceFolders)();
            const topLevelFolders = workspaceFolders.map((w) => (0, fs_1.fsPath)(w.uri));
            topLevelFolders.forEach((folder) => this.discoverTests(folder));
        }
        catch (e) {
            this.logger.error(`Failed to discover tests: ${e}`);
        }
    }
    discoverTests(fileOrDirectory, isDirectory, level = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            if (level > 5)
                return; // Max levels to discover tests.
            if ((0, utils_3.isTestFile)(fileOrDirectory)) {
                this.model.suiteDiscovered(undefined, fileOrDirectory);
            }
            else if (isDirectory !== false) { // undefined or true are allowed
                try {
                    const children = yield vs.workspace.fs.readDirectory(vs.Uri.file(fileOrDirectory));
                    children
                        .map((item) => ({ name: item[0], type: item[1] }))
                        .filter((item) => !item.name.startsWith("."))
                        .forEach((item) => this.discoverTests(path.join(fileOrDirectory, item.name), item.type === vs.FileType.Directory, level + 1));
                }
                catch (e) {
                    if (e.code !== "FileNotADirectory")
                        this.logger.error(`Failed to discover tests: ${e}`);
                }
            }
        });
    }
    discoverTestsForSuite(node) {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield vs.workspace.openTextDocument(node.suiteData.path);
            yield this.fileTracker.waitForOutline(doc, undefined);
        });
    }
    /// Forces an update for a file based on the last Outline data (if any).
    ///
    /// Used by tests to ensure discovery results are available if the test tree state has
    /// been cleared between test runs.
    forceUpdate(uri) {
        const outline = this.fileTracker.getOutlineFor(uri);
        if (outline)
            this.rebuildFromOutline((0, fs_1.fsPath)(uri), outline);
    }
    handleOutline(outline) {
        const suitePath = (0, fs_1.forceWindowsDriveLetterToUppercase)((0, utils_1.uriToFilePath)(outline.uri));
        const existingTimeout = this.debounceTimers[suitePath];
        if (existingTimeout)
            clearTimeout(existingTimeout);
        // If this is the first outline for a file (eg. we've never had a timeout)
        // we should skip the debounce so things are initially more responsive.
        const debounceDuration = existingTimeout ? this.debounceDuration : 0;
        this.debounceTimers[suitePath] = setTimeout(() => this.rebuildFromOutline(suitePath, outline.outline), debounceDuration);
    }
    rebuildFromOutline(suitePath, outline) {
        if ((0, utils_3.isTestFile)(suitePath)) {
            // Force creation of a node if it's not already there.
            const [suite, _] = this.model.getOrCreateSuite(suitePath);
            // Generate a unique ID for these IDs to be owned by so that they can be looked
            // up independent of any other ongoing runs.
            const dartCodeDebugSessionID = `discovery-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}`;
            // Mark everything in the suite as potentially-deleted so that we can detect anything
            // that was not present in the new list to remove it afterwards.
            this.model.markAllAsPotentiallyDeleted(suite, test_model_1.TestSource.Outline);
            const visitor = new TestDiscoveryVisitor(this.logger, this.model, dartCodeDebugSessionID, suitePath);
            visitor.visit(outline);
            this.model.removeAllPotentiallyDeletedNodes(suite);
            this.model.rebuildSuiteNode(suite);
            this.model.updateNode();
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestDiscoverer = TestDiscoverer;
class TestDiscoveryVisitor extends outline_lsp_1.LspOutlineVisitor {
    constructor(logger, model, dartCodeDebugSessionID, suitePath) {
        super(logger);
        this.model = model;
        this.dartCodeDebugSessionID = dartCodeDebugSessionID;
        this.suitePath = suitePath;
        this.stack = [];
        this.id = 1;
    }
    visitUnitTestTest(outline) {
        this.handleItem(outline, false, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.handleItem(outline, true, super.visitUnitTestGroup);
    }
    handleItem(outline, isGroup, base) {
        const name = (0, test_1.extractTestNameFromOutline)(outline.element.name);
        if (!name || !outline.element.range)
            return;
        const range = outline.codeRange || outline.range || (outline.element ? outline.element.range : undefined);
        const parent = this.stack.length > 0 ? this.stack[this.stack.length - 1] : undefined;
        const fullName = (parent === null || parent === void 0 ? void 0 : parent.name)
            ? `${parent.name} ${name}`
            : name;
        const thisID = this.id++;
        if (isGroup)
            this.model.groupDiscovered(this.dartCodeDebugSessionID, this.suitePath, test_model_1.TestSource.Outline, thisID, fullName, parent === null || parent === void 0 ? void 0 : parent.id, undefined, range);
        else
            this.model.testDiscovered(this.dartCodeDebugSessionID, this.suitePath, test_model_1.TestSource.Outline, thisID, fullName, parent === null || parent === void 0 ? void 0 : parent.id, undefined, range, undefined);
        if (isGroup)
            this.stack.push({ id: thisID, name: fullName });
        try {
            base.bind(this)(outline);
        }
        finally {
            if (isGroup)
                this.stack.pop();
        }
    }
}


/***/ }),

/***/ 3886:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.locateBestProjectRoot = exports.UPGRADE_TO_WORKSPACE_FOLDERS = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(8779);
exports.UPGRADE_TO_WORKSPACE_FOLDERS = "Mark Projects as Workspace Folders";
function locateBestProjectRoot(folder) {
    var _a;
    if (!folder || (!(0, utils_1.isWithinWorkspace)(folder) && ((_a = vscode_1.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a.length)))
        return undefined;
    let dir = folder;
    while (dir !== path.dirname(dir)) {
        if ((0, fs_1.hasPubspec)(dir) || (0, fs_1.hasPackagesFile)(dir))
            return dir;
        dir = path.dirname(dir);
    }
    return undefined;
}
exports.locateBestProjectRoot = locateBestProjectRoot;


/***/ }),

/***/ 1983:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddDependencyCodeActionProvider = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const project_1 = __webpack_require__(3886);
const utils_2 = __webpack_require__(8779);
const applicableErrorCodes = ["uri_does_not_exist", "conditional_uri_does_not_exist"];
const packageUriSourceCodePattern = new RegExp(`r?['"]+package:(.*)\\/`);
class AddDependencyCodeActionProvider {
    constructor(selector) {
        this.selector = selector;
        this.rank = 90;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.QuickFix],
        };
    }
    provideCodeActions(document, range, context, token) {
        if (!(0, utils_2.isAnalyzableAndInWorkspace)(document))
            return;
        // If we were only asked for specific action types and that doesn't include
        // quickfix (which is all we supply), bail out.
        if (context && context.only && !vscode_1.CodeActionKind.QuickFix.contains(context.only))
            return;
        if (!context || !context.diagnostics || !context.diagnostics.length)
            return;
        const projectRoot = (0, project_1.locateBestProjectRoot)((0, fs_1.fsPath)(document.uri));
        if (!projectRoot)
            return;
        let diagnosticsWithPackageNames = context.diagnostics
            .filter((d) => d.range.intersection(range) && d.source === "dart")
            .map((diagnostic) => ({ diagnostic, packageName: this.extractPackageNameForUriNotFoundDiagnostic(document, diagnostic) }))
            .filter((d) => d.packageName);
        if (!diagnosticsWithPackageNames.length)
            return;
        const pubspec = path.join(projectRoot, "pubspec.yaml");
        const pubspecContent = fs.existsSync(pubspec) ? fs.readFileSync(pubspec).toString() : undefined;
        if (!pubspecContent)
            return;
        // Next, filter out any already in pubspec, as that suggests the URI is incorrect
        // for another reason (and we wouldn't want to try to add something that exists).
        diagnosticsWithPackageNames = diagnosticsWithPackageNames
            .filter((obj) => obj.packageName && !pubspecContent.includes(`  ${obj.packageName}`));
        if (!diagnosticsWithPackageNames.length)
            return;
        return (0, utils_1.flatMap)(diagnosticsWithPackageNames, (item) => this.createActions(document, item.diagnostic, item.packageName));
    }
    /// Checks if the diagnostic is a uri_does_not_exist and the URI is a package:
    /// URI and returns the package name.
    extractPackageNameForUriNotFoundDiagnostic(document, diag) {
        const code = diag.code;
        if (!code)
            return;
        const errorCode = typeof code === "string" || typeof code === "number"
            ? code.toString()
            : ("value" in code)
                ? code.value.toString()
                : undefined;
        if (!errorCode)
            return;
        if (!applicableErrorCodes.includes(errorCode))
            return;
        // Finally, ensure the URI is a package: URI and something that exists in the pub cache list
        // we have.
        const uriSourceCode = document.getText(diag.range);
        const match = packageUriSourceCodePattern.exec(uriSourceCode);
        if (!match)
            return;
        return match[1];
    }
    createActions(document, diagnostic, packageName) {
        const createAction = (isDevDependency) => {
            const dependencyTypeName = isDevDependency ? "dev_dependencies" : "dependencies";
            const title = `Add '${packageName}' to ${dependencyTypeName}`;
            const action = new vscode_1.CodeAction(title, vscode_1.CodeActionKind.QuickFix);
            action.command = {
                arguments: [
                    document.uri,
                    packageName,
                    isDevDependency,
                ],
                command: "_dart.addDependency",
                title,
            };
            return action;
        };
        const actions = [createAction(false)];
        // When outside of lib, dev_dependency is an option too.
        if (!document.uri.path.includes("/lib/"))
            actions.push(createAction(true));
        return actions;
    }
}
exports.AddDependencyCodeActionProvider = AddDependencyCodeActionProvider;


/***/ }),

/***/ 9679:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssistCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(8779);
const ranking_code_action_provider_1 = __webpack_require__(7702);
class AssistCodeActionProvider {
    constructor(logger, selector, analyzer) {
        this.logger = logger;
        this.selector = selector;
        this.analyzer = analyzer;
        this.rank = 10;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.Refactor],
        };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_1.isAnalyzableAndInWorkspace)(document))
                return undefined;
            // If we were only asked for specific action types and that doesn't include
            // refactor (which is all we supply), bail out.
            if (context && context.only && !vscode_1.CodeActionKind.Refactor.contains(context.only))
                return undefined;
            try {
                const startOffset = document.offsetAt(range.start);
                const endOffset = document.offsetAt(range.end);
                const assists = yield this.analyzer.editGetAssists({
                    file: (0, fs_1.fsPath)(document.uri),
                    length: endOffset - startOffset,
                    offset: startOffset,
                });
                const allAssists = assists.assists.map((assist) => this.convertResult(document, assist));
                return context.only
                    ? allAssists.filter((ca) => { var _a; return (_a = context.only) === null || _a === void 0 ? void 0 : _a.contains(ca.kind); })
                    : allAssists;
            }
            catch (e) {
                this.logger.error(e);
            }
        });
    }
    convertResult(document, change) {
        const title = change.message;
        const kind = (0, ranking_code_action_provider_1.getKindFor)(change.id, vscode_1.CodeActionKind.Refactor);
        const action = new vscode_1.CodeAction(title, kind);
        action.command = {
            arguments: [document, change],
            command: "_dart.applySourceChange",
            title,
        };
        return action;
    }
}
exports.AssistCodeActionProvider = AssistCodeActionProvider;


/***/ }),

/***/ 6974:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCompletionItemProvider = void 0;
/* eslint-disable no-underscore-dangle */
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(4411);
const extension_utils_1 = __webpack_require__(6143);
const edit_das_1 = __webpack_require__(7511);
const config_1 = __webpack_require__(4165);
// TODO: This code has become messy with the SuggestionSet changes. It could do with some refactoring
// (such as creating a mapping from CompletionSuggestion -> x and SuggestionSet -> x, and then x -> CompletionItem).
class DartCompletionItemProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.cachedCompletions = {};
        this.existingImports = {};
        this.disposables.push(analyzer.registerForCompletionAvailableSuggestions((n) => this.storeCompletionSuggestions(n)));
        this.disposables.push(analyzer.registerForCompletionExistingImports((n) => this.storeExistingImports(n)));
    }
    provideCompletionItems(document, position, token, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const line = document.lineAt(position.line).text.slice(0, position.character);
            const nextCharacter = document.getText(new vscode_1.Range(position, position.translate({ characterDelta: 200 }))).trim().substr(0, 1);
            const conf = config_1.config.for(document.uri);
            const enableCommitCharacters = conf.enableCompletionCommitCharacters;
            const insertArgumentPlaceholders = !enableCommitCharacters && conf.insertArgumentPlaceholders && this.shouldAllowArgPlaceholders(line);
            if (!this.shouldAllowCompletion(line, context))
                return;
            const offset = document.offsetAt(position);
            const resp = yield this.analyzer.completionGetSuggestionsResults({
                file: (0, fs_1.fsPath)(document.uri),
                offset,
            });
            if (token && token.isCancellationRequested) {
                return undefined;
            }
            const includedResults = resp.results.map((r) => this.convertResult(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, resp, r));
            const cachedResults = yield this.getCachedResults(document, token, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, document.offsetAt(position), resp);
            yield promises_1.resolvedPromise;
            if (token && token.isCancellationRequested) {
                return undefined;
            }
            const allResults = [...includedResults, ...cachedResults];
            return new vscode_1.CompletionList(allResults);
        });
    }
    shouldAllowCompletion(line, context) {
        line = line.trim();
        // Filter out auto triggered completions on certain characters based on the previous
        // characters (eg. to allow completion on " if it's part of an import).
        if (context.triggerKind === vscode_1.CompletionTriggerKind.TriggerCharacter) {
            switch (context.triggerCharacter) {
                case "{":
                    return line.endsWith("${");
                case "'":
                    return line.endsWith("import '") || line.endsWith("export '");
                case "\"":
                    return line.endsWith("import \"") || line.endsWith("export \"");
                case "/":
                case "\\":
                    return line.startsWith("import \"") || line.startsWith("export \"")
                        || line.startsWith("import '") || line.startsWith("export '");
            }
        }
        // Otherwise, allow through.
        return true;
    }
    shouldAllowArgPlaceholders(line) {
        line = line.trim();
        // Disallow args on imports/exports since they're likely show/hide and
        // we only want the function name. This doesn't catch all cases (for ex.
        // where a show/hide is split across multiple lines) but it's better than
        // nothing. We'd need more semantic info to handle this better, and probably
        // this will go away if commit characters is fixed properly.
        if (line.startsWith("import \"") || line.startsWith("export \"")
            || line.startsWith("import '") || line.startsWith("export '")) {
            return false;
        }
        return true;
    }
    storeCompletionSuggestions(notification) {
        if (notification.changedLibraries) {
            for (const completionSet of notification.changedLibraries) {
                this.cachedCompletions[completionSet.id] = completionSet;
            }
        }
        if (notification.removedLibraries) {
            for (const completionSetID of notification.removedLibraries) {
                delete this.cachedCompletions[completionSetID];
            }
        }
    }
    storeExistingImports(notification) {
        const existingImports = notification.imports;
        // Map with key "elementName/elementDeclaringLibraryUri"
        // Value is a set of imported URIs that import that element.
        const alreadyImportedSymbols = {};
        for (const existingImport of existingImports.imports) {
            for (const importedElement of existingImport.elements) {
                // This is the symbol name and declaring library. That is, the
                // library that declares the symbol, not the one that was imported.
                // This wil be the same for an element that is re-exported by other
                // libraries, so we can avoid showing the exact duplicate.
                const elementName = existingImports.elements.strings[existingImports.elements.names[importedElement]];
                const elementDeclaringLibraryUri = existingImports.elements.strings[existingImports.elements.uris[importedElement]];
                const importedUri = existingImports.elements.strings[existingImport.uri];
                const key = `${elementName}/${elementDeclaringLibraryUri}`;
                if (!alreadyImportedSymbols[key])
                    alreadyImportedSymbols[key] = {};
                alreadyImportedSymbols[key][importedUri] = true;
            }
        }
        this.existingImports[notification.file] = alreadyImportedSymbols;
    }
    resolveCompletionItem(item, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!item.suggestion) {
                if (!item.documentation && item._documentation) {
                    item.documentation = item._documentation;
                }
                return item;
            }
            const res = yield this.analyzer.completionGetSuggestionDetails({
                file: item.filePath,
                id: item.suggestionSetID,
                label: item.suggestion.label,
                offset: item.offset,
            });
            if (token && token.isCancellationRequested) {
                return;
            }
            // Rebuild the completion using the additional resolved info.
            return this.createCompletionItemFromSuggestion(item.document, item.offset, item.nextCharacter, item.enableCommitCharacters, item.insertArgumentPlaceholders, item.replacementOffset, item.replacementLength, item.autoImportUri, item.relevance, item.suggestion, res);
        });
    }
    createCompletionItemFromSuggestion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, replacementOffset, replacementLength, displayUri, relevance, suggestion, resolvedResult) {
        const completionItem = this.makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, {
            autoImportUri: displayUri,
            completionText: (resolvedResult && resolvedResult.completion) || suggestion.label,
            defaultArgumentListString: suggestion.defaultArgumentListString,
            defaultArgumentListTextRanges: suggestion.defaultArgumentListTextRanges,
            displayText: suggestion.label,
            elementKind: suggestion.element ? suggestion.element.kind : undefined,
            isDeprecated: false,
            kind: undefined,
            parameterNames: suggestion.parameterNames,
            parameterType: undefined,
            parameters: suggestion.element ? suggestion.element.parameters : undefined,
            relevance,
            replacementLength,
            replacementOffset,
            requiredParameterCount: suggestion.requiredParameterCount,
            returnType: suggestion.element ? suggestion.element.returnType : undefined,
            selectionLength: resolvedResult && resolvedResult.change && resolvedResult.change.selection ? 0 : undefined,
            selectionOffset: resolvedResult && resolvedResult.change && resolvedResult.change.selection ? resolvedResult.change.selection.offset : undefined,
        });
        // Additional edits for the imports.
        if (resolvedResult && resolvedResult.change && resolvedResult.change.edits && resolvedResult.change.edits.length) {
            this.appendAdditionalEdits(completionItem, document, resolvedResult.change);
            if (displayUri)
                completionItem.detail = `Auto import from '${displayUri}'` + (completionItem.detail ? `\n\n${completionItem.detail}` : "");
        }
        // Copy the lazy docs over.
        if (resolvedResult && !completionItem.documentation && completionItem._documentation) {
            completionItem.documentation = completionItem._documentation;
        }
        return completionItem;
    }
    getCachedResults(document, token, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, offset, resp) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!resp.includedSuggestionSets || !resp.includedElementKinds)
                return [];
            const existingImports = resp.libraryFile ? this.existingImports[resp.libraryFile] : undefined;
            // Create a fast lookup for which kinds to include.
            const elementKinds = {};
            resp.includedElementKinds.forEach((k) => elementKinds[k] = true);
            // Create a fast lookup for relevance boosts based on tag string.
            const tagBoosts = {};
            if (resp.includedSuggestionRelevanceTags)
                resp.includedSuggestionRelevanceTags.forEach((r) => tagBoosts[r.tag] = r.relevanceBoost);
            const filePath = (0, fs_1.fsPath)(document.uri);
            const suggestionSetResults = [];
            // Keep track of suggestion sets we've seen to avoid included them twice.
            // See https://github.com/dart-lang/sdk/issues/37211.
            const usedSuggestionSets = {};
            // Keep track of items items we've included so we don't show dupes if
            // there are multiple libraries importing the same thing.
            const includedItems = {};
            for (const includedSuggestionSet of resp.includedSuggestionSets) {
                if (usedSuggestionSets[includedSuggestionSet.id])
                    continue;
                // Mark that we've done this one so we don't do it again.
                usedSuggestionSets[includedSuggestionSet.id] = true;
                // Because this work is expensive, we periodically (per suggestion
                // set) yield and check whether cancellation is pending and if so
                // stop and bail out to avoid doing redundant work.
                yield promises_1.resolvedPromise;
                if (token && token.isCancellationRequested) {
                    return [];
                }
                const suggestionSet = this.cachedCompletions[includedSuggestionSet.id];
                if (!suggestionSet) {
                    this.logger.warn(`Suggestion set ${includedSuggestionSet.id} was not available and therefore not included in the completion results`);
                    return [];
                }
                const unresolvedItems = suggestionSet.items
                    .filter((r) => elementKinds[r.element.kind])
                    .filter((suggestion) => {
                    // Check existing imports to ensure we don't already import
                    // this element (note: this exact element from its declaring
                    // library, not just something with the same name). If we do
                    // we'll want to skip it.
                    // Trim back to the . to handle enum values
                    // https://github.com/Dart-Code/Dart-Code/issues/1835
                    const key = `${suggestion.label.split(".")[0]}/${suggestion.declaringLibraryUri}`;
                    const importingUris = existingImports && existingImports[key];
                    // If there are no URIs already importing this, then include it
                    // as an auto-import.
                    if (!importingUris)
                        return true;
                    // Otherwise, it is imported but if it's not by this file, then skip it.
                    if (!importingUris[suggestionSet.uri])
                        return false;
                    // Finally, we're importing a file that has this item, so include
                    // it only if it has not already been included by another imported file.
                    // Unlike the above, we include the Kind here so that things with similar labels
                    // like Constructors+Class are still included.
                    const fullItemKey = `${suggestion.label}/${suggestion.element.kind}/${suggestion.declaringLibraryUri}`;
                    const itemHasAlreadyBeenIncluded = includedItems[fullItemKey];
                    includedItems[fullItemKey] = true;
                    return !itemHasAlreadyBeenIncluded;
                })
                    .map((suggestion) => {
                    // Calculate the relevance for this item.
                    let relevanceBoost = 0;
                    if (suggestion.relevanceTags)
                        suggestion.relevanceTags.forEach((t) => relevanceBoost = Math.max(relevanceBoost, tagBoosts[t] || 0));
                    const completionItem = this.createCompletionItemFromSuggestion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, resp.replacementOffset, resp.replacementLength, undefined, includedSuggestionSet.relevance + relevanceBoost, suggestion, undefined);
                    // Attach additional info that resolve will need.
                    const delayedCompletionItem = Object.assign({ autoImportUri: includedSuggestionSet.displayUri || suggestionSet.uri, document,
                        enableCommitCharacters,
                        filePath,
                        insertArgumentPlaceholders,
                        nextCharacter,
                        offset, relevance: includedSuggestionSet.relevance + relevanceBoost, replacementLength: resp.replacementLength, replacementOffset: resp.replacementOffset, suggestion, suggestionSetID: includedSuggestionSet.id }, completionItem);
                    return delayedCompletionItem;
                });
                suggestionSetResults.push(unresolvedItems);
            }
            return [].concat(...suggestionSetResults);
        });
    }
    convertResult(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, notification, suggestion) {
        return this.makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, {
            completionText: suggestion.completion,
            defaultArgumentListString: suggestion.defaultArgumentListString,
            defaultArgumentListTextRanges: suggestion.defaultArgumentListTextRanges,
            displayText: suggestion.displayText,
            docComplete: suggestion.docComplete,
            elementKind: suggestion.element ? suggestion.element.kind : undefined,
            isDeprecated: suggestion.isDeprecated,
            kind: suggestion.kind,
            parameterNames: suggestion.parameterNames,
            parameterType: suggestion.parameterType,
            parameters: suggestion.element ? suggestion.element.parameters : undefined,
            relevance: suggestion.relevance,
            replacementLength: notification.replacementLength,
            replacementOffset: notification.replacementOffset,
            requiredParameterCount: suggestion.requiredParameterCount,
            returnType: suggestion.returnType || (suggestion.element ? suggestion.element.returnType : undefined),
            selectionLength: suggestion.selectionLength,
            selectionOffset: suggestion.selectionOffset,
        });
    }
    makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, suggestion) {
        const completionItemKind = suggestion.elementKind ? this.getElementKind(suggestion.elementKind) : undefined;
        let label = suggestion.displayText || suggestion.completionText;
        let detail;
        const completionText = new vscode_1.SnippetString();
        let triggerCompletion = false;
        const nextCharacterIsOpenParen = nextCharacter === "(";
        // If element has parameters (METHOD/CONSTRUCTOR/FUNCTION), show its parameters.
        if (suggestion.parameters && completionItemKind !== vscode_1.CompletionItemKind.Property && suggestion.kind !== "OVERRIDE"
            // Don't ever show if there is already a paren! (#969).
            && label.indexOf("(") === -1) {
            label += suggestion.parameters.length === 2 ? "()" : "()";
            detail = suggestion.parameters;
            const hasParams = (suggestion.parameterNames && suggestion.parameterNames.length > 0)
                || (insertArgumentPlaceholders && !!suggestion.defaultArgumentListString);
            // Add placeholders for params to the completion.
            if (insertArgumentPlaceholders && hasParams && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                completionText.appendText("(");
                if (suggestion.defaultArgumentListString) {
                    for (const arg of this.extractTabstopDataForNamedArgs(suggestion.defaultArgumentListString, suggestion.defaultArgumentListTextRanges || [])) {
                        const text = suggestion.defaultArgumentListString.substring(arg.start, arg.end);
                        if (arg.tabStop)
                            completionText.appendPlaceholder(text);
                        else
                            completionText.appendText(text);
                    }
                }
                else
                    completionText.appendTabstop(); // Put a tap stop between parens since there are optional args.
                completionText.appendText(")");
            }
            else if (insertArgumentPlaceholders && hasParams && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                const args = suggestion.parameterNames.slice(0, suggestion.requiredParameterCount);
                completionText.appendText("(");
                if (args.length) {
                    completionText.appendPlaceholder(args[0]);
                    for (const arg of args.slice(1)) {
                        completionText.appendText(", ");
                        completionText.appendPlaceholder(arg);
                    }
                }
                else
                    completionText.appendTabstop(0); // Put a tap stop between parens since there are optional args.
                completionText.appendText(")");
            }
            else if (insertArgumentPlaceholders && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                completionText.appendText("()");
            }
            else {
                completionText.appendText(suggestion.completionText);
            }
        }
        else if (suggestion.selectionOffset) {
            const before = suggestion.completionText.slice(0, suggestion.selectionOffset);
            const selection = suggestion.completionText.slice(suggestion.selectionOffset, suggestion.selectionOffset + (suggestion.selectionLength || 0));
            // If we have a selection offset (eg. a place to put the cursor) but not any text to pre-select then
            // pop open the completion to help the user type the value.
            // Only do this if it ends with a space (argument completion), see #730.
            if (!selection && suggestion.completionText.slice(suggestion.selectionOffset - 1, suggestion.selectionOffset) === " ")
                triggerCompletion = true;
            const after = suggestion.completionText.slice(suggestion.selectionOffset + (suggestion.selectionLength || 0));
            completionText.appendText(before);
            if (selection)
                completionText.appendPlaceholder(selection);
            else
                completionText.appendTabstop(0);
            completionText.appendText(after);
        }
        else {
            completionText.appendText(suggestion.completionText);
        }
        // If we're a property, work out the type.
        if (completionItemKind === vscode_1.CompletionItemKind.Property) {
            // Setters appear as methods with one arg (and cause getters to not appear),
            // so treat them both the same and just display with the properties type.
            detail = suggestion.elementKind === "GETTER"
                ? suggestion.returnType
                // See https://github.com/dart-lang/sdk/issues/27747
                : suggestion.parameters ? suggestion.parameters.substring(1, suggestion.parameters.lastIndexOf(" ")) : "";
            // Otherwise, get return type from method.
        }
        else if (suggestion.returnType) {
            detail =
                detail
                    ? detail + "  " + suggestion.returnType
                    : suggestion.returnType;
        }
        else if (suggestion.parameterType) {
            detail = suggestion.parameterType;
        }
        // If we have trailing commas (flutter) they look weird in the list, so trim the off (for display label only).
        if (label.endsWith(","))
            label = label.substr(0, label.length - 1).trim();
        // If we didnt have a CompletionItemKind from our element, base it on the CompletionSuggestionKind.
        // This covers things like Keywords that don't have elements.
        const kind = completionItemKind || (suggestion.kind ? this.getSuggestionKind(suggestion.kind, label) : undefined);
        const docs = (0, extension_utils_1.cleanDartdoc)(suggestion.docComplete);
        const completion = new vscode_1.CompletionItem(label, kind);
        completion.filterText = label.split("(")[0]; // Don't ever include anything after a ( in filtering.
        if (suggestion.isDeprecated)
            completion.tags = [vs.CompletionItemTag.Deprecated];
        completion.detail = detail;
        completion._documentation = docs ? new vscode_1.MarkdownString(docs) : undefined;
        completion.insertText = completionText;
        completion.keepWhitespace = true;
        completion.range = {
            inserting: new vscode_1.Range(document.positionAt(suggestion.replacementOffset), document.positionAt(Math.min(offset, suggestion.replacementOffset + suggestion.replacementLength))),
            replacing: new vscode_1.Range(document.positionAt(suggestion.replacementOffset), document.positionAt(suggestion.replacementOffset + suggestion.replacementLength)),
        };
        if (enableCommitCharacters)
            completion.commitCharacters = this.getCommitCharacters(suggestion.kind);
        const triggerCompletionsFor = ["import '';"];
        if (triggerCompletionsFor.indexOf(label) !== -1)
            triggerCompletion = true;
        // Handle folders in imports better.
        if (suggestion.kind === "IMPORT" && label.endsWith("/"))
            triggerCompletion = true;
        if (triggerCompletion) {
            completion.command = {
                command: "editor.action.triggerSuggest",
                title: "Suggest",
            };
        }
        // Relevance is a number, highest being best. Code sorts by text, so subtract from a large number so that
        // a text sort will result in the correct order.
        // 555 -> 999455
        //  10 -> 999990
        //   1 -> 999999
        completion.sortText = (1000000 - suggestion.relevance).toString();
        return completion;
    }
    /// Argument info comes through as a stringle string like "a: null, b: null"
    /// and an array of ints that are offset/length pairs. [3,4,12,4] means
    /// characters 3-7 and 12 - 16 are tabstops.
    ///
    /// To process this more easily, we first convert this into an array like:
    ///
    /// ```
    /// [
    ///   { start: 0, end: 3, tabStop: false },
    ///   { start: 3, end: 7, tabStop: true },
    ///   { start: 7, end: 12, tabStop: false },
    ///   { start: 12, end: 16, tabStop: true },
    /// ]
    /// ```
    extractTabstopDataForNamedArgs(argListString, argListTextRanges) {
        const ranges = [];
        let currentIndex = 0;
        // For each range, push anything that comes before it, and it.
        for (const range of this.extractOffsetLengthPairs(argListTextRanges)) {
            ranges.push({ start: currentIndex, end: range[0], tabStop: false });
            ranges.push({ start: range[0], end: range[1], tabStop: true });
            currentIndex = range[1];
        }
        // Then push anything left at the end.
        if (currentIndex < argListString.length)
            ranges.push({ start: currentIndex, end: argListString.length, tabStop: false });
        return ranges;
    }
    extractOffsetLengthPairs(numberPairs) {
        const pairs = [];
        for (let i = 0; i < numberPairs.length - 1; i += 2) {
            pairs.push([numberPairs[i], numberPairs[i] + numberPairs[i + 1]]);
        }
        return pairs;
    }
    getSuggestionKind(kind, label) {
        switch (kind) {
            case "ARGUMENT_LIST":
                return vscode_1.CompletionItemKind.Variable;
            case "IMPORT":
                return label.startsWith("dart:")
                    ? vscode_1.CompletionItemKind.Module
                    : path.extname(label.toLowerCase()) === ".dart"
                        ? vscode_1.CompletionItemKind.File
                        : vscode_1.CompletionItemKind.Folder;
            case "IDENTIFIER":
                return vscode_1.CompletionItemKind.Variable;
            case "INVOCATION":
                return vscode_1.CompletionItemKind.Method;
            case "KEYWORD":
                return vscode_1.CompletionItemKind.Keyword;
            case "NAMED_ARGUMENT":
                return vscode_1.CompletionItemKind.Variable;
            case "OPTIONAL_ARGUMENT":
                return vscode_1.CompletionItemKind.Variable;
            case "PARAMETER":
                return vscode_1.CompletionItemKind.Value;
        }
        return undefined;
    }
    getElementKind(kind) {
        switch (kind) {
            case "CLASS":
            case "CLASS_TYPE_ALIAS":
                return vscode_1.CompletionItemKind.Class;
            case "COMPILATION_UNIT":
                return vscode_1.CompletionItemKind.Module;
            case "CONSTRUCTOR":
            case "CONSTRUCTOR_INVOCATION":
                return vscode_1.CompletionItemKind.Constructor;
            case "ENUM":
                return vscode_1.CompletionItemKind.Enum;
            case "ENUM_CONSTANT":
                return vscode_1.CompletionItemKind.EnumMember;
            case "FIELD":
                return vscode_1.CompletionItemKind.Field;
            case "FILE":
                return vscode_1.CompletionItemKind.File;
            case "FUNCTION":
            case "FUNCTION_TYPE_ALIAS":
                return vscode_1.CompletionItemKind.Function;
            case "GETTER":
                return vscode_1.CompletionItemKind.Property;
            case "LABEL":
            case "LIBRARY":
                return vscode_1.CompletionItemKind.Module;
            case "LOCAL_VARIABLE":
                return vscode_1.CompletionItemKind.Variable;
            case "METHOD":
                return vscode_1.CompletionItemKind.Method;
            case "PARAMETER":
            case "PREFIX":
                return vscode_1.CompletionItemKind.Variable;
            case "SETTER":
                return vscode_1.CompletionItemKind.Property;
            case "TOP_LEVEL_VARIABLE":
            case "TYPE_PARAMETER":
                return vscode_1.CompletionItemKind.Variable;
            case "UNIT_TEST_GROUP":
                return vscode_1.CompletionItemKind.Module;
            case "UNIT_TEST_TEST":
                return vscode_1.CompletionItemKind.Method;
            case "UNKNOWN":
                return vscode_1.CompletionItemKind.Value;
        }
        return undefined;
    }
    getCommitCharacters(kind) {
        switch (kind) {
            case "IDENTIFIER":
            case "INVOCATION":
                return [".", ",", "(", "["];
        }
        return undefined;
    }
    appendAdditionalEdits(completionItem, document, change) {
        if (!change)
            return undefined;
        // VS Code expects offsets to be based on the original document, but the analysis server provides
        // them assuming all previous edits have already been made. This means if the server provides us a
        // set of edits where any edits offset is *equal to or greater than* a previous edit, it will do the wrong thing.
        // If this happens; we will fall back to sequential edits and write a warning.
        const hasProblematicEdits = (0, edit_das_1.hasOverlappingEdits)(change);
        if (hasProblematicEdits) {
            this.logger.error("Unable to insert imports because of overlapping edits from the server.");
            vs.window.showErrorMessage(`Unable to insert imports because of overlapping edits from the server`);
            return undefined;
        }
        const filePath = (0, fs_1.fsPath)(document.uri);
        const thisFilesEdits = change.edits.filter((e) => e.file === filePath);
        const otherFilesEdits = change.edits.filter((e) => e.file !== filePath);
        if (thisFilesEdits.length) {
            completionItem.additionalTextEdits = (0, utils_1.flatMap)(thisFilesEdits, (edit) => edit.edits.map((edit) => {
                const range = new vs.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length));
                return new vs.TextEdit(range, edit.replacement);
            }));
        }
        if (otherFilesEdits.length) {
            const filteredSourceChange = {
                edits: otherFilesEdits,
                id: change.id,
                linkedEditGroups: [],
                message: change.message,
                selection: change.selection,
            };
            completionItem.command = {
                arguments: [document, filteredSourceChange],
                command: "_dart.applySourceChange",
                title: "Automatically add imports",
            };
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DartCompletionItemProvider = DartCompletionItemProvider;


/***/ }),

/***/ 5453:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDiagnostic = exports.DartDiagnosticProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
// TODO: This is not a provider?
class DartDiagnosticProvider {
    constructor(analyzer, diagnostics) {
        this.analyzer = analyzer;
        this.diagnostics = diagnostics;
        this.analyzer.registerForAnalysisErrors((es) => this.handleErrors(es));
        // Fired when files are deleted
        this.analyzer.registerForAnalysisFlushResults((es) => this.flushResults(es));
    }
    handleErrors(notification) {
        const notificationJson = JSON.stringify(notification);
        // As a workaround for https://github.com/Dart-Code/Dart-Code/issues/1678, if
        // the errors we got are exactly the same as the previous set, do not give
        // them to VS Code. This avoids a potential loop of refreshing the error view
        // which triggers a request for Code Actions, which could result in analysis
        // of the file (which triggers errors to be sent, which triggers a refresh
        // of the error view... etc.!).
        if (this.lastErrorJson === notificationJson) {
            // TODO: Come up with a better fix than this!
            // log("Skipping error notification as it was the same as the previous one");
            return;
        }
        let errors = notification.errors;
        if (!config_1.config.showTodos)
            errors = errors.filter((error) => error.type !== "TODO");
        this.diagnostics.set(vscode_1.Uri.file(notification.file), errors.map((e) => DartDiagnosticProvider.createDiagnostic(e)));
        this.lastErrorJson = notificationJson;
    }
    static createDiagnostic(error) {
        const diag = new DartDiagnostic((0, utils_1.toRangeOnLine)(error.location), error.message, DartDiagnosticProvider.getSeverity(error.severity, error.type), error.type);
        diag.code = error.url ? { value: error.code, target: vscode_1.Uri.parse(error.url) } : error.code;
        diag.source = "dart";
        diag.tags = DartDiagnosticProvider.getTags(error);
        if (error.correction)
            diag.message += `\n${error.correction}`;
        if (error.contextMessages && error.contextMessages.length)
            diag.relatedInformation = error.contextMessages.map(DartDiagnosticProvider.createRelatedInformation);
        return diag;
    }
    static createRelatedInformation(related) {
        return new vscode_1.DiagnosticRelatedInformation(new vscode_1.Location(vscode_1.Uri.file(related.location.file), (0, utils_1.toRangeOnLine)(related.location)), related.message);
    }
    static getSeverity(severity, type) {
        switch (severity) {
            case "ERROR":
                return vscode_1.DiagnosticSeverity.Error;
            case "WARNING":
                return vscode_1.DiagnosticSeverity.Warning;
            case "INFO":
                switch (type) {
                    case "TODO":
                        return vscode_1.DiagnosticSeverity.Information; // https://github.com/Microsoft/vscode/issues/48376
                    default:
                        return vscode_1.DiagnosticSeverity.Information;
                }
            default:
                throw new Error(`Unknown severity type: ${severity}`);
        }
    }
    static getTags(error) {
        const tags = [];
        if (error.code === "dead_code" || error.code === "unused_local_variable" || error.code === "unused_import")
            tags.push(vscode_1.DiagnosticTag.Unnecessary);
        if (error.code === "deprecated_member_use" || error.code === "deprecated_member_use_from_same_package")
            tags.push(vscode_1.DiagnosticTag.Deprecated);
        return tags;
    }
    flushResults(notification) {
        this.lastErrorJson = undefined;
        const entries = notification.files.map((file) => [vscode_1.Uri.file(file), undefined]);
        this.diagnostics.set(entries);
    }
}
exports.DartDiagnosticProvider = DartDiagnosticProvider;
class DartDiagnostic extends vscode_1.Diagnostic {
    constructor(range, message, severity, type) {
        super(range, message, severity);
        this.type = type;
    }
}
exports.DartDiagnostic = DartDiagnostic;


/***/ }),

/***/ 6663:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDocumentSymbolProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const promises_1 = __webpack_require__(4411);
const utils_1 = __webpack_require__(7220);
const analyzer_das_1 = __webpack_require__(2061);
class DartDocumentSymbolProvider {
    constructor(logger, fileTracker) {
        this.logger = logger;
        this.fileTracker = fileTracker;
    }
    provideDocumentSymbols(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const outline = yield (0, promises_1.waitFor)(() => this.fileTracker.getOutlineFor(document.uri), 500, 60000, token);
            if (token.isCancellationRequested || !outline || !outline.children || !outline.children.length)
                return;
            return outline.children.map((r) => this.convertResult(document, r));
        });
    }
    convertResult(document, outline) {
        const name = outline.element.name
            ? outline.element.name
            : (outline.element.kind === "EXTENSION" ? "<unnamed extension>" : "<unnamed>");
        const location = outline.element.location || outline;
        const symbol = new vscode_1.DocumentSymbol(name, this.getDetail(outline.element), (0, analyzer_das_1.getSymbolKindForElementKind)(this.logger, outline.element.kind), this.getCodeOffset(document, outline), (0, utils_1.toRange)(document, location.offset, location.length));
        // eslint-disable-next-line no-bitwise
        if (outline.element.flags & 0x20)
            symbol.tags = [vscode_1.SymbolTag.Deprecated];
        if (outline.children && outline.children.length) {
            symbol.children = outline.children.filter(this.shouldShow).map((r) => this.convertResult(document, r));
        }
        return symbol;
    }
    shouldShow(outline) {
        // Don't show these (#656).
        if (outline.element.kind === "CONSTRUCTOR_INVOCATION" || outline.element.kind === "FUNCTION_INVOCATION")
            return false;
        return true;
    }
    getDetail(element) {
        let label = "";
        if (element.parameters)
            label += element.parameters;
        if (element.returnType)
            label += "  " + element.returnType;
        return label.trim();
    }
    getCodeOffset(document, outline) {
        return (0, utils_1.toRange)(document, outline.codeOffset || outline.offset, outline.codeLength || outline.length);
    }
}
exports.DartDocumentSymbolProvider = DartDocumentSymbolProvider;


/***/ }),

/***/ 3299:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartFoldingProvider = void 0;
const vscode_1 = __webpack_require__(9496);
class DartFoldingProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideFoldingRanges(document, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Wait for any current analysis to complete (eg. if we've just opened a project it
            // may take a while to get the results).
            yield this.analyzer.client.currentAnalysis;
            if (token && token.isCancellationRequested)
                return;
            // Wait up to another few seconds after analysis completed (it might be that we opened a new
            // file and there was no analysis, in which case we're just waiting for the server to process
            // the newly added subscription and send results).
            let foldingRegions;
            for (let i = 0; i < 5; i++) {
                foldingRegions = this.analyzer.fileTracker.getFoldingRegionsFor(document.uri);
                if (foldingRegions)
                    break;
                yield new Promise((resolve) => setTimeout(resolve, i * 1000).unref());
                if (token && token.isCancellationRequested)
                    return;
            }
            if (token.isCancellationRequested || !foldingRegions)
                return;
            return foldingRegions.map((f) => new vscode_1.FoldingRange(document.positionAt(f.offset).line, document.positionAt(f.offset + f.length).line, this.getKind(f.kind)));
        });
    }
    getKind(kind) {
        switch (kind) {
            case "FILE_HEADER":
            case "DOCUMENTATION_COMMENT":
                return vscode_1.FoldingRangeKind.Comment;
            case "DIRECTIVES":
                return vscode_1.FoldingRangeKind.Imports;
        }
    }
}
exports.DartFoldingProvider = DartFoldingProvider;


/***/ }),

/***/ 7099:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartFormattingEditProvider = void 0;
const minimatch = __webpack_require__(1171);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
class DartFormattingEditProvider {
    constructor(logger, analyzer, context) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.context = context;
        this.registeredFormatters = [];
        this.formatterRegisterFuncs = [];
        vscode_1.workspace.onDidChangeConfiguration((e) => {
            if (e.affectsConfiguration("dart.enableSdkFormatter")) {
                if (config_1.config.enableSdkFormatter)
                    this.registerAllFormatters();
                else
                    this.unregisterAllFormatters();
            }
        });
    }
    registerDocumentFormatter(filter) {
        this.registerFormatter(() => vscode_1.languages.registerDocumentFormattingEditProvider(filter, this));
    }
    registerTypingFormatter(filter, firstTriggerCharacter, ...moreTriggerCharacters) {
        this.registerFormatter(() => vscode_1.languages.registerOnTypeFormattingEditProvider(filter, this, firstTriggerCharacter, ...moreTriggerCharacters));
    }
    registerFormatter(reg) {
        const registerAndTrack = () => this.registeredFormatters.push(reg());
        // Register the formatter immediately if enabled.
        if (config_1.config.enableSdkFormatter)
            registerAndTrack();
        // Add it to our list so we can re-register later..
        this.formatterRegisterFuncs.push(registerAndTrack);
    }
    registerAllFormatters() {
        for (const formatterReg of this.formatterRegisterFuncs) {
            formatterReg();
        }
    }
    unregisterAllFormatters() {
        (0, utils_1.disposeAll)(this.registeredFormatters);
    }
    provideDocumentFormattingEdits(document, options, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.doFormat(document, true); // await is important for catch to work.
            }
            catch (_a) {
                if (!this.context.hasWarnedAboutFormatterSyntaxLimitation) {
                    this.context.hasWarnedAboutFormatterSyntaxLimitation = true;
                    vscode_1.window.showInformationMessage("The Dart formatter will not run if the file has syntax errors");
                }
                return undefined;
            }
        });
    }
    provideOnTypeFormattingEdits(document, position, ch, options, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.doFormat(document, false);
            }
            catch (_a) {
                return undefined;
            }
        });
    }
    doFormat(document, doLogError = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.shouldFormat(document))
                return undefined;
            try {
                const resp = yield this.analyzer.editFormat({
                    file: (0, fs_1.fsPath)(document.uri),
                    lineLength: config_1.config.for(document.uri).lineLength,
                    selectionLength: 0,
                    selectionOffset: 0,
                });
                if (resp.edits.length === 0)
                    return undefined;
                else
                    return resp.edits.map((e) => this.convertData(document, e));
            }
            catch (e) {
                if (doLogError)
                    this.logger.error(e);
                throw e;
            }
        });
    }
    shouldFormat(document) {
        if (!document || !document.uri || document.uri.scheme !== "file")
            return false;
        const resourceConf = config_1.config.for(document.uri);
        const path = (0, fs_1.fsPath)(document.uri);
        return undefined === resourceConf.doNotFormat.find((p) => minimatch(path, p, { dot: true }));
    }
    convertData(document, edit) {
        return new vscode_1.TextEdit(new vscode_1.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length)), edit.replacement);
    }
    dispose() {
        this.unregisterAllFormatters();
    }
}
exports.DartFormattingEditProvider = DartFormattingEditProvider;


/***/ }),

/***/ 9917:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDocumentHighlightProvider = void 0;
const vscode_1 = __webpack_require__(9496);
class DartDocumentHighlightProvider {
    constructor(fileTracker) {
        this.fileTracker = fileTracker;
    }
    provideDocumentHighlights(document, position, token) {
        const offset = document.offsetAt(position);
        const occurrences = this.fileTracker.getOccurrencesFor(document.uri);
        if (!occurrences)
            return;
        for (const occurrence of occurrences) {
            // If an occurence spans our position, then we don't need to look at any others.
            if (occurrence.offsets.find((o) => o <= offset && o + occurrence.length >= offset)) {
                return occurrence.offsets.map((o) => new vscode_1.DocumentHighlight(new vscode_1.Range(document.positionAt(o), document.positionAt(o + occurrence.length))));
            }
        }
    }
}
exports.DartDocumentHighlightProvider = DartDocumentHighlightProvider;


/***/ }),

/***/ 988:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartHoverProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const extension_utils_1 = __webpack_require__(6143);
class DartHoverProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
    }
    provideHover(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resp = yield this.analyzer.analysisGetHover({
                    file: (0, fs_1.fsPath)(document.uri),
                    offset: document.offsetAt(position),
                });
                if (token.isCancellationRequested || resp.hovers.length === 0)
                    return;
                const hover = resp.hovers[0];
                const data = this.getHoverData(document.uri, hover);
                if (!data)
                    return;
                const range = new vscode_1.Range(document.positionAt(hover.offset), document.positionAt(hover.offset + hover.length));
                return new vscode_1.Hover([{ language: "dart", value: data.displayString }, data.documentation || undefined], range.isSingleLine ? range : undefined);
            }
            catch (e) {
                this.logger.error(e);
            }
        });
    }
    getHoverData(documentUri, hover) {
        if (!hover.elementDescription)
            return undefined;
        // Import prefix tooltips are not useful currently.
        // https://github.com/dart-lang/sdk/issues/32735
        if (hover.elementKind === "import prefix")
            return undefined;
        const elementDescription = hover.elementDescription;
        const dartdoc = hover.dartdoc;
        const propagatedType = hover.propagatedType;
        let displayString = "";
        if (elementDescription)
            displayString += (hover.isDeprecated ? "(deprecated) " : "") + `${elementDescription}\n`;
        if (propagatedType)
            displayString += `propogated type: ${propagatedType.trim()}`;
        let documentation = (0, extension_utils_1.cleanDartdoc)(dartdoc);
        const containingLibraryName = hover.containingLibraryName;
        if (containingLibraryName)
            documentation = `*${containingLibraryName}*\n\n` + documentation;
        return {
            displayString: displayString.trim(),
            documentation: documentation.trim(),
        };
    }
}
exports.DartHoverProvider = DartHoverProvider;


/***/ }),

/***/ 9715:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartImplementationProvider = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const outline_1 = __webpack_require__(7104);
class DartImplementationProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideImplementation(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Try to use the Outline data to snap our location to a node.
            // For example in:
            //
            //     void b();
            //
            // The search.getTypeHierarchy call will only work over "b" but by using outline we
            // can support the whole "void b();".
            const outlineNode = (0, outline_1.findNearestOutlineNode)(this.analyzer.fileTracker, document, position, true);
            const offset = outlineNode && outlineNode.element && outlineNode.element.location
                ? outlineNode.element.location.offset
                : document.offsetAt(position);
            const hierarchy = yield this.analyzer.client.searchGetTypeHierarchy({
                file: (0, fs_1.fsPath)(document.uri),
                offset,
            });
            if (token.isCancellationRequested || !hierarchy || !hierarchy.hierarchyItems || !hierarchy.hierarchyItems.length || hierarchy.hierarchyItems.length === 1)
                return;
            // Find the element we started with, since we only want implementations (not super classes).
            const currentItem = hierarchy.hierarchyItems.find((h) => {
                const elm = h.memberElement || h.classElement;
                return elm.location && elm.location.offset <= offset && elm.location.offset + elm.location.length >= offset;
            })
                // If we didn't find the element when we might have been at a call site, so we'll have to start
                // at the root.
                || hierarchy.hierarchyItems[0];
            const isClass = !currentItem.memberElement;
            function getDescendants(item) {
                return [
                    ...item.subclasses.map((i) => hierarchy.hierarchyItems[i]),
                    ...(0, utils_1.flatMap)(item.subclasses, (i) => getDescendants(hierarchy.hierarchyItems[i])),
                ];
            }
            const descendants = getDescendants(currentItem)
                .map((d) => isClass ? d.classElement : d.memberElement)
                .filter(utils_1.notUndefined);
            const locations = [];
            for (const element of descendants) {
                if (!element.location)
                    continue;
                const range = (0, utils_2.toRange)(yield vs.workspace.openTextDocument(element.location.file), element.location.offset, element.location.length);
                locations.push(new vs.Location(vs.Uri.file(element.location.file), range));
            }
            return locations;
        });
    }
}
exports.DartImplementationProvider = DartImplementationProvider;


/***/ }),

/***/ 1122:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartLanguageConfiguration = void 0;
const vscode_1 = __webpack_require__(9496);
const config_1 = __webpack_require__(4165);
class DartLanguageConfiguration {
    constructor() {
        this.doubleSlashRules = [
            {
                // Double-slash with space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "// " },
                beforeText: /^\s*\/\/ /,
            },
            {
                // Double-slash without space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "//" },
                beforeText: /^\s*\/\//,
            },
        ];
        // When double-slash is disabled, we still want to be able to add newlines
        // in existing comments and have them include the comment markers.
        this.betweenDoubleSlashRules = [
            {
                // Double-slash with space when there's already an existing space after
                // so we don't need to insert one.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "//" },
                afterText: / .*$/,
                beforeText: /^\s*\/\//,
            },
            {
                // Double-slash with space when there's not already an existing space after.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "// " },
                afterText: /[^ ]+$/,
                beforeText: /^\s*\/\/ /,
            },
            {
                // Double-slash without space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "//" },
                afterText: /.+$/,
                beforeText: /^\s*\/\//,
            },
        ];
        this.tripleSlashRules = [
            {
                // Triple-slash with space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "/// " },
                beforeText: /^\s*\/\/\/ /,
            },
            {
                // Triple-slash without space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "///" },
                beforeText: /^\s*\/\/\//,
            },
        ];
        this.slashStarRules = [
            {
                // When between "/** | */" this puts a " * " in but also pushes the "*/" down to next line.
                action: { indentAction: vscode_1.IndentAction.IndentOutdent, appendText: " * " },
                afterText: /^\s*\*\/$/,
                beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
            },
            {
                // When after "/**" will put a " * " in (like above, but where there's no "*/" to push down).
                action: { indentAction: vscode_1.IndentAction.None, appendText: " * " },
                beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
            },
            {
                // Continue " * " when on a line already start with this.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "* " },
                beforeText: /^(\t|(\ \ ))*\ \*(\ ([^\*]|\*(?!\/))*)?$/,
            },
            {
                // After "*/" we need to remove the indent.
                action: { indentAction: vscode_1.IndentAction.None, removeText: 1 },
                beforeText: /^(\t|(\ \ ))*\ \*\/\s*$/,
            },
        ];
    }
    get onEnterRules() {
        let rules = [];
        if (config_1.config.automaticCommentSlashes !== "none")
            rules = rules.concat(this.tripleSlashRules);
        if (config_1.config.automaticCommentSlashes === "all")
            rules = rules.concat(this.doubleSlashRules);
        else
            rules = rules.concat(this.betweenDoubleSlashRules);
        rules = rules.concat(this.slashStarRules);
        return rules;
    }
}
exports.DartLanguageConfiguration = DartLanguageConfiguration;


/***/ }),

/***/ 8517:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartReferenceProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
class DartReferenceProvider {
    constructor(analyzer, fileTracker) {
        this.analyzer = analyzer;
        this.fileTracker = fileTracker;
    }
    provideReferences(document, position, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // If we want to include the decleration, kick off a request for that.
            const definitions = context.includeDeclaration
                ? yield this.provideDefinition(document, position, token)
                : undefined;
            const resp = yield this.analyzer.searchFindElementReferencesResults({
                file: (0, fs_1.fsPath)(document.uri),
                includePotential: true,
                offset: document.offsetAt(position),
            });
            if (token && token.isCancellationRequested)
                return;
            const locations = resp.results.map((result) => new vscode_1.Location(vscode_1.Uri.file(result.location.file), (0, utils_2.toRangeOnLine)(result.location)));
            return definitions
                ? locations.concat(definitions.map((dl) => new vscode_1.Location(dl.targetUri, dl.targetRange)))
                : locations;
        });
    }
    provideDefinition(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            let resp1 = this.fileTracker.getNavigationTargets((0, fs_1.fsPath)(document.uri), document.offsetAt(position));
            if (!resp1) {
                resp1 = yield this.analyzer.analysisGetNavigation({
                    file: (0, fs_1.fsPath)(document.uri),
                    length: 0,
                    offset: document.offsetAt(position),
                });
            }
            if (!resp1)
                return undefined;
            const resp = resp1;
            if (token && token.isCancellationRequested)
                return;
            const definitions = (0, utils_1.flatMap)(resp.regions, (region) => region.targets.map((targetIndex) => {
                const target = resp.targets[targetIndex];
                // HACK: We sometimes get a startColumn of 0 (should be 1-based). Just treat this as 1 for now.
                //     See https://github.com/Dart-Code/Dart-Code/issues/200
                if (target.startColumn === 0)
                    target.startColumn = 1;
                return {
                    originSelectionRange: (0, utils_2.toRange)(document, region.offset, region.length),
                    targetRange: (0, utils_2.toRangeOnLine)(target),
                    targetUri: vscode_1.Uri.file(resp.files[target.fileIndex]),
                };
            }));
            // For some locations (for example on the "var" keyword ), we'll get multiple results
            // where some of them are the location we invoked at, or the name of the variable. If
            // there are any results that are on a different line/different file to where we were
            // invoked, return only those. If the only results are on the same line of the same
            // file then just return them all.
            const definitionsOnOtherLines = definitions
                .filter((d) => (0, fs_1.fsPath)(d.targetUri) !== (0, fs_1.fsPath)(document.uri)
                || d.targetRange.start.line !== position.line);
            return definitionsOnOtherLines.length ? definitionsOnOtherLines : definitions;
        });
    }
}
exports.DartReferenceProvider = DartReferenceProvider;


/***/ }),

/***/ 6252:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartRenameProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(7220);
const channels = __webpack_require__(1026);
class DartRenameProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideRenameEdits(document, position, newName, token) {
        return this.doRename(document, position, newName, token);
    }
    prepareRename(document, position, token) {
        return this.getLocation(document, position, token);
    }
    doRename(document, position, newName, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const outputChannel = channels.getOutputChannel("Refactorings");
            outputChannel.appendLine("");
            const resp = yield this.analyzer.editGetRefactoring({
                file: (0, fs_1.fsPath)(document.uri),
                kind: "RENAME",
                length: 1,
                offset: document.offsetAt(position),
                options: {
                    newName,
                },
                validateOnly: false,
            });
            if (token && token.isCancellationRequested) {
                outputChannel.appendLine("[INFO] Rename cancelled.");
                return;
            }
            const workspaceEdit = new vscode_1.WorkspaceEdit();
            if (resp.change && resp.change.message)
                outputChannel.appendLine(`[INFO] ${resp.change.message}`);
            this.handleProblem(resp.initialProblems
                .concat(resp.optionsProblems)
                .concat(resp.finalProblems), outputChannel);
            const promises = [];
            if (resp.change) {
                resp.change.edits.forEach((changeEdit) => {
                    changeEdit.edits.forEach((fileEdit) => {
                        const uri = vscode_1.Uri.file(changeEdit.file);
                        const promise = vscode_1.workspace.openTextDocument(uri);
                        promises.push(promise.then((document) => workspaceEdit.replace(uri, new vscode_1.Range(document.positionAt(fileEdit.offset), document.positionAt(fileEdit.offset + fileEdit.length)), fileEdit.replacement)));
                    });
                });
            }
            // TODO: This class is inconsistent with other refactors (which are silent when they work, for ex).
            // We should review what we can extract share (though note that this method must return the edit whereas
            // the other refactors apply them).
            // Wait all openTextDocument to finish
            yield Promise.all(promises);
            if (token && token.isCancellationRequested) {
                outputChannel.appendLine("[INFO] Rename cancelled.");
                return;
            }
            outputChannel.appendLine("[INFO] Rename successful.");
            return workspaceEdit;
        });
    }
    handleProblem(problems, outputChannel) {
        // Log all in output channel.
        problems.forEach((problem) => outputChannel.appendLine(`[${problem.severity}] ${problem.message}`));
        const errors = problems
            .filter((p) => p.severity !== "INFO" && p.severity !== "WARNING")
            .sort((p1, p2) => p2.severity.localeCompare(p1.severity));
        if (errors.length !== 0) {
            outputChannel.appendLine("[INFO] Rename aborted.");
            throw errors[0].message;
        }
    }
    getLocation(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.analyzer.editGetRefactoring({
                file: (0, fs_1.fsPath)(document.uri),
                kind: "RENAME",
                length: 0,
                offset: document.offsetAt(position),
                validateOnly: true,
            });
            if (token && token.isCancellationRequested)
                return;
            if (!resp.feedback)
                throw new Error("You cannot rename this element.");
            const feedback = resp.feedback;
            // The dart server returns -1 when the old name doesn't exist (for ex. renaming an unprefixed import to add a prefix)
            // so we use a zero-character range at the requested position in this case.
            const range = feedback.offset === -1
                ? new vscode_1.Range(position, position)
                : (0, utils_1.toRange)(document, feedback.offset, feedback.length);
            if (feedback) {
                return {
                    placeholder: feedback.oldName,
                    range,
                };
            }
            else {
                const fatalProblems = resp.initialProblems
                    .concat(resp.optionsProblems)
                    .concat(resp.finalProblems)
                    .filter((p) => p.severity === "FATAL");
                if (fatalProblems && fatalProblems.length) {
                    throw new Error(fatalProblems[0].message);
                }
                else {
                    throw new Error("This rename is not supported.");
                }
            }
        });
    }
}
exports.DartRenameProvider = DartRenameProvider;


/***/ }),

/***/ 4258:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartSignatureHelpProvider = void 0;
const vs = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const extension_utils_1 = __webpack_require__(6143);
class DartSignatureHelpProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideSignatureHelp(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resp = yield this.analyzer.analysisGetSignature({
                    file: (0, fs_1.fsPath)(document.uri),
                    offset: document.offsetAt(position),
                });
                if (token && token.isCancellationRequested)
                    return undefined;
                const sig = new vs.SignatureInformation(this.getSignatureLabel(resp), new vs.MarkdownString((0, extension_utils_1.cleanDartdoc)(resp.dartdoc)));
                sig.parameters = resp.parameters.map((p) => new vs.ParameterInformation(this.getLabel(p)));
                const sigs = new vs.SignatureHelp();
                sigs.signatures = [sig];
                sigs.activeSignature = 0;
                // TODO: This isn't implemented in the server yet.
                sigs.activeParameter = -1; // resp.selectedParameterIndex;
                return sigs;
            }
            catch (_a) {
                return undefined;
            }
        });
    }
    getSignatureLabel(resp) {
        const req = resp.parameters.filter((p) => p.kind === "REQUIRED" || p.kind === "REQUIRED_POSITIONAL");
        const opt = resp.parameters.filter((p) => p.kind === "OPTIONAL" || p.kind === "OPTIONAL_POSITIONAL");
        const named = resp.parameters.filter((p) => p.kind === "NAMED" || p.kind === "OPTIONAL_NAMED" || p.kind === "REQUIRED_NAMED");
        const params = [];
        if (req.length)
            params.push(req.map(this.getLabel).join(", "));
        if (opt.length)
            params.push("[" + opt.map(this.getLabel).join(", ") + "]");
        if (named.length)
            params.push("{" + named.map(this.getLabel).join(", ") + "}");
        return `${resp.name}(${params.join(", ")})`;
    }
    getLabel(p) {
        const def = p.defaultValue
            ? ` = ${p.defaultValue}`
            : "";
        const prefix = p.kind === "REQUIRED_NAMED" ? "required " : "";
        return `${prefix}${p.type} ${p.name}${def}`;
    }
}
exports.DartSignatureHelpProvider = DartSignatureHelpProvider;


/***/ }),

/***/ 5188:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartWorkspaceSymbolProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(7220);
const analyzer_das_1 = __webpack_require__(2061);
class DartWorkspaceSymbolProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.badChars = new RegExp("[^0-9a-z\-]", "gi");
    }
    provideWorkspaceSymbols(query, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (query.length === 0)
                return undefined;
            // Turn query into a case-insensitive fuzzy search.
            const pattern = ".*" + query.replace(this.badChars, "").split("").map((c) => `[${c.toUpperCase()}${c.toLowerCase()}]`).join(".*") + ".*";
            const results = yield this.analyzer.searchGetElementDeclarations({ pattern, maxResults: 500 });
            if (token && token.isCancellationRequested)
                return;
            return results.declarations.map((d) => this.convertWorkspaceResult(d, results.files[d.fileIndex]));
        });
    }
    resolveWorkspaceSymbol(symbol, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(symbol instanceof PartialSymbolInformation))
                return undefined;
            const document = yield vscode_1.workspace.openTextDocument(vscode_1.Uri.file(symbol.locationData.file));
            symbol.location = new vscode_1.Location(document.uri, (0, utils_1.toRange)(document, symbol.locationData.offset, symbol.locationData.length));
            return symbol;
        });
    }
    convertWorkspaceResult(result, file) {
        const nameSuffix = result.parameters ? (result.parameters === "()" ? "()" : "()") : "";
        const symbol = new PartialSymbolInformation(result.name + nameSuffix, (0, analyzer_das_1.getSymbolKindForElementKind)(this.logger, result.kind), result.className || "", 
        // HACK: Work around the incorrect typing in VS Code with !
        // https://github.com/microsoft/vscode/issues/69558
        new vscode_1.Location(vscode_1.Uri.file(file), undefined), {
            file,
            length: result.codeLength,
            // Fall back to offset when the server gives us a bad codeOffset
            // https://github.com/dart-lang/sdk/issues/39192.
            offset: result.codeOffset || result.offset,
        });
        return symbol;
    }
}
exports.DartWorkspaceSymbolProvider = DartWorkspaceSymbolProvider;
class PartialSymbolInformation extends vscode_1.SymbolInformation {
    constructor(name, kind, containerName, location, locationData) {
        super(name, kind, containerName, location);
        this.locationData = locationData;
    }
}


/***/ }),

/***/ 8109:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterDescriptorFactory = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const debug_1 = __webpack_require__(2335);
const config_1 = __webpack_require__(4165);
class DartDebugAdapterDescriptorFactory {
    constructor(sdks, logger, extensionContext) {
        this.sdks = sdks;
        this.logger = logger;
        this.extensionContext = extensionContext;
    }
    createDebugAdapterDescriptor(session, executable) {
        return this.descriptorForType(session.configuration.debuggerType);
    }
    descriptorForType(debuggerType) {
        const debuggerName = (0, debug_1.getDebugAdapterName)(debuggerType);
        this.logger.info(`Using ${debuggerName} debugger for ${enums_1.DebuggerType[debuggerType]}`);
        if (config_1.config.experimentalDartDapPath && (debuggerType === enums_1.DebuggerType.Dart || debuggerType === enums_1.DebuggerType.DartTest)) {
            const args = [config_1.config.experimentalDartDapPath, "debug_adapter"];
            if (debuggerType === enums_1.DebuggerType.DartTest)
                args.push("--test");
            this.logger.info(`Running custom Dart debugger using Dart VM with args ${args.join("    ")}`);
            return new vscode_1.DebugAdapterExecutable(path.join(this.sdks.dart, constants_1.dartVMPath), args);
        }
        else if (config_1.config.experimentalFlutterDapPath && (debuggerType === enums_1.DebuggerType.Flutter || debuggerType === enums_1.DebuggerType.FlutterTest)) {
            const args = [config_1.config.experimentalFlutterDapPath, "debug_adapter"];
            if (debuggerType === enums_1.DebuggerType.FlutterTest)
                args.push("--test");
            this.logger.info(`Running custom Flutter debugger using Dart VM with args ${args.join("    ")}`);
            return new vscode_1.DebugAdapterExecutable(path.join(this.sdks.dart, constants_1.dartVMPath), args);
        }
        if (process.env.DART_CODE_USE_DEBUG_SERVERS) {
            const port = (0, debug_1.getDebugAdapterPort)(debuggerName);
            this.logger.info(`Running debugger in server mode on port ${port} because DART_CODE_USE_DEBUG_SERVERS is set`);
            return new vscode_1.DebugAdapterServer(port);
        }
        const args = [this.extensionContext.asAbsolutePath(constants_1.debugAdapterPath), debuggerName];
        this.logger.info(`Running debugger via node with ${args.join("    ")}`);
        return new vscode_1.DebugAdapterExecutable("node", args);
    }
}
exports.DartDebugAdapterDescriptorFactory = DartDebugAdapterDescriptorFactory;


/***/ }),

/***/ 4319:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterLoggerFactory = void 0;
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
class DartDebugAdapterLoggerFactory {
    constructor(logger) {
        this.logger = new logging_1.CategoryLogger(logger, enums_1.LogCategory.DAP);
    }
    createDebugAdapterTracker(session) {
        return new DartDebugAdapterLogger(this.logger, session);
    }
}
exports.DartDebugAdapterLoggerFactory = DartDebugAdapterLoggerFactory;
class DartDebugAdapterLogger {
    constructor(logger, session) {
        this.logger = logger;
        this.session = session;
    }
    onWillStartSession() {
        this.logger.info(`Starting debug session ${this.session.id}`);
    }
    onWillReceiveMessage(message) {
        this.logger.info(`<== ${JSON.stringify(message)}`);
    }
    onDidSendMessage(message) {
        this.logger.info(`==> ${JSON.stringify(message)}`);
    }
    onWillStopSession() {
        this.logger.info(`Stopping debug session ${this.session.id}`);
    }
    onError(error) {
        // We log this as info, as this isn't the place to handle errors and it seems to fire
        // whenever a debug session stops because the process stream goes away.
        this.logger.info(`Debug session ${this.session.id} errored: ${JSON.stringify(error)}`);
    }
    onExit(code, signal) {
        this.logger.info(`Debug session ${this.session.id} exit: code: ${code}, signal: ${signal}`);
    }
}


/***/ }),

/***/ 233:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDebugConfigProvider = exports.InitialLaunchJsonDebugConfigProvider = exports.DebugConfigProvider = void 0;
/* eslint-disable @typescript-eslint/tslint/config */
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(5820);
const utils_2 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_3 = __webpack_require__(7220);
const debug_1 = __webpack_require__(4635);
const logging_1 = __webpack_require__(9475);
const config_1 = __webpack_require__(4165);
const project_1 = __webpack_require__(3886);
const webdev_1 = __webpack_require__(708);
const utils_4 = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
class DebugConfigProvider {
    constructor(logger, wsContext, analytics, pubGlobal, testModel, daemon, deviceManager, debugCommands, dartCapabilities, flutterCapabilities) {
        this.logger = logger;
        this.wsContext = wsContext;
        this.analytics = analytics;
        this.pubGlobal = pubGlobal;
        this.testModel = testModel;
        this.daemon = daemon;
        this.deviceManager = deviceManager;
        this.debugCommands = debugCommands;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
    }
    resolveDebugConfiguration(folder, debugConfig, token) {
        (0, utils_4.ensureDebugLaunchUniqueId)(debugConfig);
        debugConfig.type = debugConfig.type || "dart";
        debugConfig.request = debugConfig.request || "launch";
        return debugConfig;
    }
    warnOnUnresolvedVariables(property, input) {
        if (!input)
            return false;
        const v = this.getUnresolvedVariable(input);
        if (v) {
            this.logger.error(`Launch config property '${property}' has unresolvable variable ${v}`);
            vscode_1.window.showErrorMessage(`Launch config property '${property}' has unresolvable variable ${v}`);
            return true;
        }
        return false;
    }
    /** Gets the first unresolved variable from the given string. */
    getUnresolvedVariable(input) {
        if (!input)
            return undefined;
        const matches = /\${\w+}/.exec(input);
        return matches ? matches[0] : undefined;
    }
    resolveDebugConfigurationWithSubstitutedVariables(folder, debugConfig, token) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            (0, utils_4.ensureDebugLaunchUniqueId)(debugConfig);
            const isAttachRequest = debugConfig.request === "attach";
            const logger = this.logger;
            const openFile = vscode_1.window.activeTextEditor && vscode_1.window.activeTextEditor.document && vscode_1.window.activeTextEditor.document.uri.scheme === "file"
                ? (0, fs_1.fsPath)(vscode_1.window.activeTextEditor.document.uri)
                : undefined;
            logger.info(`Starting debug session...`);
            if (folder)
                logger.info(`    workspace: ${(0, fs_1.fsPath)(folder.uri)}`);
            if (debugConfig.program)
                logger.info(`    program  : ${debugConfig.program}`);
            if (debugConfig.cwd)
                logger.info(`    cwd      : ${debugConfig.cwd}`);
            if (this.warnOnUnresolvedVariables("program", debugConfig.program) || this.warnOnUnresolvedVariables("cwd", debugConfig.cwd)) {
                // Warning is shown from inside warnOnUnresolvedVariables.
                return null; // null means open launch.json.
            }
            if (openFile && !folder) {
                folder = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(openFile));
                if (folder)
                    logger.info(`Setting workspace based on open file: ${(0, fs_1.fsPath)(folder.uri)}`);
            }
            else if (!folder && vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length === 1) {
                folder = vs.workspace.workspaceFolders[0];
                if (folder)
                    logger.info(`Setting workspace based on single open workspace: ${(0, fs_1.fsPath)(folder.uri)}`);
            }
            this.configureProgramAndCwd(debugConfig, folder, openFile);
            // If we still don't have an entry point, the user will have to provide it.
            if (!isAttachRequest && !debugConfig.program) {
                this.logger.warn("No program was set in launch config");
                const exampleEntryPoint = this.wsContext.hasAnyFlutterProjects ? "lib/main.dart" : "bin/main.dart";
                vscode_1.window.showInformationMessage(`Set the 'program' value in your launch config (eg '${exampleEntryPoint}') then launch again`);
                return null; // null means open launch.json.
            }
            const debugType = this.selectDebuggerType(debugConfig, logger);
            const isFlutter = debugType === enums_1.DebuggerType.Flutter || debugType === enums_1.DebuggerType.FlutterTest;
            const isTest = (0, utils_4.isTestFileOrFolder)(debugConfig.program);
            const isIntegrationTest = debugConfig.program && (0, utils_4.isInsideFolderNamed)(debugConfig.program, "integration_test");
            const argsHaveTestNameFilter = (0, utils_4.hasTestNameFilter)(debugConfig.toolArgs, debugConfig.args);
            // Handle test_driver tests that can be pointed at an existing running instrumented app.
            if (debugType === enums_1.DebuggerType.FlutterTest && (0, utils_4.isInsideFolderNamed)(debugConfig.program, "test_driver") && !((_a = debugConfig.env) === null || _a === void 0 ? void 0 : _a.VM_SERVICE_URL)) {
                const runningInstrumentedApps = debug_1.debugSessions.filter((s) => s.loadedServiceExtensions.indexOf(enums_1.VmServiceExtension.Driver) !== -1);
                if (runningInstrumentedApps.length === 0) {
                    return this.errorWithoutOpeningLaunchConfig("Could not find a running Flutter app that was instrumented with enableFlutterDriverExtension. Run your instrumented app before running driver tests.");
                }
                else if (runningInstrumentedApps.length > 1) {
                    return this.errorWithoutOpeningLaunchConfig("More than one Flutter app instrumented with enableFlutterDriverExtension is running. Please run only one app before running driver tests.");
                }
                else {
                    const app = runningInstrumentedApps[0];
                    // This shouldn't really be possible as we wouldn't find an instrumented app without having its VM Service connection.
                    if (!app.vmServiceUri)
                        return this.errorWithoutOpeningLaunchConfig("The Flutter app instrumented with enableFlutterDriverExtension is not fully initialised yet.");
                    // Restart the app for clean state before the test run.
                    yield app.session.customRequest("hotRestart");
                    debugConfig.env = debugConfig.env || {};
                    debugConfig.env.VM_SERVICE_URL = app.vmServiceUri;
                }
            }
            if (debugType === enums_1.DebuggerType.WebTest) {
                // TODO: IMPORTANT! When removing this if statement, add WebTest to
                // the call to TestResultsProvider.flagSuiteStart below!
                logger.error("Tests in web projects are not currently supported");
                vscode_1.window.showErrorMessage("Tests in web projects are not currently supported");
                return undefined; // undefined means silent (don't open launch.json).
            }
            if (debugType === enums_1.DebuggerType.FlutterTest && (0, utils_4.isTestFolder)(debugConfig.program) && !debugConfig.noDebug) {
                // When running `flutter test (folder)`, multiple debug sessions are created - one for each file. This is
                // different to how `pub run test (folder)` works (one debug session, which each file in an isolate). The
                // debugger does not currently support multiple VM service sessions so we have to downgrade this to noDebug.
                logger.warn("Setting noDebug=true for Flutter test run because it's a folder");
                debugConfig.noDebug = true;
            }
            // If we're attaching to Dart, ensure we get a VM service URI.
            if (isAttachRequest && !debugConfig.vmServiceInfoFile) {
                // For attaching, the VM service address must be specified. If it's not provided already, prompt for it.
                if (!isFlutter) { // TEMP Condition because there's no point asking yet as the user doesn't know how to get this..
                    debugConfig.vmServiceUri = yield this.getFullVmServiceUri(debugConfig.vmServiceUri || debugConfig.observatoryUri);
                }
                if (!debugConfig.vmServiceUri && !isFlutter) {
                    logger.warn("No VM service URI/port was provided");
                    vscode_1.window.showInformationMessage("You must provide a VM service URI/port to attach a debugger");
                    return undefined; // undefined means silent (don't open launch.json).
                }
            }
            if (token && token.isCancellationRequested)
                return;
            // Ensure we have a device if required.
            let deviceToLaunchOn = ((_b = this.deviceManager) === null || _b === void 0 ? void 0 : _b.getDevice(debugConfig.deviceId)) || ((_c = this.deviceManager) === null || _c === void 0 ? void 0 : _c.currentDevice);
            const requiresDevice = (debugType === enums_1.DebuggerType.Flutter && !isAttachRequest)
                || (enums_1.DebuggerType.FlutterTest && isIntegrationTest && this.flutterCapabilities.supportsRunningIntegrationTests);
            if (requiresDevice) {
                deviceToLaunchOn = ((_d = this.deviceManager) === null || _d === void 0 ? void 0 : _d.getDevice(debugConfig.deviceId)) || ((_e = this.deviceManager) === null || _e === void 0 ? void 0 : _e.currentDevice);
                if (this.deviceManager && this.daemon && debugConfig.deviceId !== "flutter-tester") {
                    let supportedPlatforms = this.daemon.capabilities.providesPlatformTypes && debugConfig.cwd
                        ? (yield this.daemon.getSupportedPlatforms(debugConfig.cwd)).platforms
                        : [];
                    // If the current device is not valid, prompt the user.
                    if (!this.deviceManager.isSupported(supportedPlatforms, deviceToLaunchOn))
                        deviceToLaunchOn = yield this.deviceManager.showDevicePicker(supportedPlatforms);
                    // Refresh the supported platforms, as the we may have enabled new platforms during
                    // the call to showDevicePicker.
                    supportedPlatforms = this.daemon.capabilities.providesPlatformTypes && debugConfig.cwd
                        ? (yield this.daemon.getSupportedPlatforms(debugConfig.cwd)).platforms
                        : [];
                    // If we still don't have a valid device, show an error.
                    if (!this.deviceManager.isSupported(supportedPlatforms, deviceToLaunchOn)) {
                        if (deviceToLaunchOn) {
                            logger.warn(`Unable to launch because ${deviceToLaunchOn.id} is not valid for this project (${deviceToLaunchOn.platformType} is not allowed according to [${supportedPlatforms.join(", ")}])`);
                            vscode_1.window.showInformationMessage("Cannot launch without a valid device for this project");
                        }
                        else {
                            logger.warn("Unable to launch due to no active device");
                            vscode_1.window.showInformationMessage("Cannot launch without an active device");
                        }
                        return undefined; // undefined means silent (don't open launch.json).
                    }
                }
            }
            if (token && token.isCancellationRequested)
                return;
            // Ensure we have any require dependencies.
            if (!(yield this.installDependencies(debugType, this.pubGlobal))) {
                return undefined;
            }
            if (token && token.isCancellationRequested)
                return;
            // TODO: This cast feels nasty?
            yield this.setupDebugConfig(folder, debugConfig, debugType, isFlutter, isAttachRequest, isTest, deviceToLaunchOn, this.deviceManager);
            // Debugger always uses uppercase drive letters to ensure our paths have them regardless of where they came from.
            debugConfig.program = (0, fs_1.forceWindowsDriveLetterToUppercase)(debugConfig.program);
            debugConfig.cwd = (0, fs_1.forceWindowsDriveLetterToUppercase)(debugConfig.cwd);
            // If we're launching (not attaching) then check there are no errors before we launch.
            if (!isAttachRequest && debugConfig.cwd && config_1.config.promptToRunIfErrors && !debugConfig.suppressPromptOnErrors) {
                if (yield this.checkIfProjectHasErrors(debugConfig))
                    return undefined; // undefined means silent (don't open launch.json).
            }
            if (token && token.isCancellationRequested)
                return;
            const didWarnAboutCwd = debugConfig.cwd && path.isAbsolute(debugConfig.cwd)
                ? (0, utils_3.warnIfPathCaseMismatch)(logger, debugConfig.cwd, "the launch script working directory", "check the 'cwd' field in your launch configuration file (.vscode/launch.json)")
                : false;
            if (!didWarnAboutCwd && debugConfig.program && path.isAbsolute(debugConfig.program))
                (0, utils_3.warnIfPathCaseMismatch)(logger, debugConfig.program, "the launch script", "check the 'program' field in your launch configuration file (.vscode/launch.json)");
            this.analytics.logDebuggerStart(folder && folder.uri, enums_1.DebuggerType[debugType], debugConfig.noDebug ? "Run" : "Debug");
            if (debugType === enums_1.DebuggerType.FlutterTest /* || debugType === DebuggerType.WebTest */ || debugType === enums_1.DebuggerType.DartTest) {
                const suitePaths = (0, utils_4.isTestFolder)(debugConfig.program)
                    ? Object.values(this.testModel.suites)
                        .map((suite) => suite.path)
                        .filter((p) => p.startsWith(debugConfig.program))
                    : [debugConfig.program];
                for (const suitePath of suitePaths)
                    this.testModel.flagSuiteStart(suitePath, !argsHaveTestNameFilter);
            }
            debugConfig.debuggerType = debugType;
            logger.info(`Debug session starting...\n    ${JSON.stringify(debugConfig, undefined, 4).replace(/\n/g, "\n    ")}`);
            // Stash the config to support the "rerun last debug session" command.
            debug_1.LastDebugSession.workspaceFolder = folder;
            debug_1.LastDebugSession.debugConfig = Object.assign({}, debugConfig);
            vs.commands.executeCommand("setContext", constants_1.HAS_LAST_DEBUG_CONFIG, true);
            // Stash the config to support the "rerun last test(s)" command.
            if (isTest) {
                debug_1.LastTestDebugSession.workspaceFolder = folder;
                debug_1.LastTestDebugSession.debugConfig = Object.assign({}, debugConfig);
                vs.commands.executeCommand("setContext", constants_1.HAS_LAST_TEST_DEBUG_CONFIG, true);
            }
            return debugConfig;
        });
    }
    checkIfProjectHasErrors(debugConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = this.logger;
            logger.info("Checking for errors before launching");
            const isDartError = (d) => d.source === "dart" && d.severity === vs.DiagnosticSeverity.Error;
            const dartErrors = vs.languages
                .getDiagnostics()
                .filter((file) => file[1].find(isDartError));
            // Check if any are inside our CWD.
            const firstRelevantDiagnostic = dartErrors.find((fd) => {
                const file = (0, fs_1.fsPath)(fd[0]);
                return (0, fs_1.isWithinPath)(file, debugConfig.cwd)
                    // Ignore errors in test folder unless it's the file we're running.
                    && ((!(0, utils_4.isInsideFolderNamed)(file, "test") && !(0, utils_4.isInsideFolderNamed)(file, "integration_test")) || file === debugConfig.program);
            });
            if (firstRelevantDiagnostic) {
                logger.warn("Project has errors, prompting user");
                const firstRelevantError = firstRelevantDiagnostic[1].find(isDartError);
                const range = firstRelevantError.range;
                logger.warn(`    ${(0, fs_1.fsPath)(firstRelevantDiagnostic[0])}:${range.start.line}:${range.start.character}`);
                logger.warn(`    ${firstRelevantError.message.split("\n")[0].trim()}`);
                const action = yield vscode_1.window.showErrorMessage("Build errors exist in your project.", { modal: true }, constants_1.debugAnywayAction, constants_1.showErrorsAction);
                if (action === constants_1.debugAnywayAction) {
                    logger.info("Debugging anyway!");
                    // Do nothing, we'll just carry on.
                }
                else {
                    logger.info("Aborting!");
                    if (action === constants_1.showErrorsAction)
                        vs.commands.executeCommand("workbench.action.showErrorsWarnings");
                    return true;
                }
            }
            return false;
        });
    }
    selectDebuggerType(debugConfig, logger) {
        const isTest = (0, utils_4.isTestFileOrFolder)(debugConfig.program);
        const isIntegrationTest = debugConfig.program && (0, utils_4.isInsideFolderNamed)(debugConfig.program, "integration_test");
        // TODO: Remove argsHaveTestNameFilter now that "flutter test" supports running tests on device (integration tests).
        const argsHaveTestNameFilter = (0, utils_4.hasTestNameFilter)(debugConfig.toolArgs, debugConfig.args);
        let debugType = enums_1.DebuggerType.Dart;
        if (debugConfig.cwd
            // TODO: This isInsideFolderNamed often fails when we found a better project root above.
            && !(0, utils_4.isInsideFolderNamed)(debugConfig.program, "bin")
            && !(0, utils_4.isInsideFolderNamed)(debugConfig.program, "tool")
            && !(0, utils_4.isInsideFolderNamed)(debugConfig.program, ".dart_tool")) {
            // Check if we're a Flutter or Web project.
            if ((0, utils_4.isFlutterProjectFolder)(debugConfig.cwd) || this.wsContext.config.forceFlutterDebug) {
                debugType = enums_1.DebuggerType.Flutter;
            }
            else if ((0, utils_4.isInsideFolderNamed)(debugConfig.program, "web") && !(0, utils_4.isInsideFolderNamed)(debugConfig.program, "test"))
                debugType = enums_1.DebuggerType.Web;
            else
                logger.info(`Project (${debugConfig.program}) not recognised as Flutter or Web, will use Dart debugger`);
        }
        logger.info(`Detected launch project as ${enums_1.DebuggerType[debugType]}`);
        if (isTest)
            logger.info(`Detected launch project as a Test project`);
        const canPubRunTest = isTest && debugConfig.cwd && (0, utils_4.projectShouldUsePubForTests)(debugConfig.cwd, this.wsContext.config);
        if (isTest && !canPubRunTest)
            logger.info(`Project does not appear to support 'pub run test', will use VM directly`);
        if (isTest) {
            switch (debugType) {
                case enums_1.DebuggerType.Dart:
                    if (canPubRunTest)
                        debugType = enums_1.DebuggerType.DartTest;
                    break;
                case enums_1.DebuggerType.Flutter:
                    if (isIntegrationTest) {
                        // Integration tests always use "flutter test".
                        debugType = enums_1.DebuggerType.FlutterTest;
                    }
                    else if (debugConfig.runTestsOnDevice && argsHaveTestNameFilter) {
                        // Non-integration tests set to run on device but have a test name filter will also have
                        // to run with "flutter test".
                        vs.window.showWarningMessage("Running with 'flutter test' as 'runTestsOnDevice' is not supported for individual tests.");
                        logger.info(`runTestsOnDevice is set but args have test filter so will still use Flutter`);
                        debugType = enums_1.DebuggerType.FlutterTest;
                    }
                    else if (debugConfig.runTestsOnDevice) {
                        // Anything else (eg. Non-integration tests without a test name filter) is allowed to
                        // run on a device if specified.
                        logger.info(`runTestsOnDevice is set, so will use Flutter instead of FlutterTest`);
                    }
                    else {
                        // Otherwise, default is to use "flutter test".
                        debugType = enums_1.DebuggerType.FlutterTest;
                    }
                    break;
                case enums_1.DebuggerType.Web:
                    debugType = enums_1.DebuggerType.WebTest;
                    break;
                default:
                    logger.info("Unknown debugType, unable to switch to test debugger");
            }
        }
        logger.info(`Using ${enums_1.DebuggerType[debugType]} debug adapter for this session`);
        return debugType;
    }
    configureProgramAndCwd(debugConfig, folder, openFile) {
        const isAttachRequest = debugConfig.request === "attach";
        // Convert to an absolute paths (if possible).
        if (debugConfig.cwd && !path.isAbsolute(debugConfig.cwd) && folder) {
            debugConfig.cwd = path.join((0, fs_1.fsPath)(folder.uri), debugConfig.cwd);
            this.logger.info(`Converted cwd to absolute path: ${debugConfig.cwd}`);
        }
        if (debugConfig.program && !path.isAbsolute(debugConfig.program) && (debugConfig.cwd || folder)) {
            debugConfig.program = path.join(debugConfig.cwd || (0, fs_1.fsPath)(folder.uri), debugConfig.program);
            this.logger.info(`Converted program to absolute path: ${debugConfig.program}`);
        }
        if (!isAttachRequest) {
            // If there's no program set, try to guess one.
            if (!debugConfig.program) {
                const preferredFolder = debugConfig.cwd
                    ? debugConfig.cwd
                    : folder
                        ? (0, fs_1.fsPath)(folder.uri)
                        : undefined;
                // If we have a folder specified, we should only consider open files if it's inside it.
                const preferredFile = !preferredFolder || (!!openFile && (0, fs_1.isWithinPath)(openFile, preferredFolder)) ? openFile : undefined;
                debugConfig.program = debugConfig.program || this.guessBestEntryPoint(preferredFile, preferredFolder);
            }
        }
        // If we don't have a cwd then find the best one from the project root.
        if (!debugConfig.cwd && folder) {
            debugConfig.cwd = (0, fs_1.fsPath)(folder.uri);
            this.logger.info(`Using workspace as cwd: ${debugConfig.cwd}`);
            // If we have an entry point, see if we can make this more specific by finding a .packages file
            if (debugConfig.program) {
                const bestProjectRoot = (0, project_1.locateBestProjectRoot)(debugConfig.program);
                if (bestProjectRoot && (0, fs_1.isWithinPath)(bestProjectRoot, (0, fs_1.fsPath)(folder.uri))) {
                    debugConfig.cwd = bestProjectRoot;
                    this.logger.info(`Found better project root to use as cwd: ${debugConfig.cwd}`);
                }
            }
        }
        // Ensure we have a full path.
        if (debugConfig.program && debugConfig.cwd && !path.isAbsolute(debugConfig.program))
            debugConfig.program = path.join(debugConfig.cwd, debugConfig.program);
        if (debugConfig.program && path.isAbsolute(debugConfig.program) && !fs.existsSync(debugConfig.program)) {
            this.logger.warn(`Launch config references non-existant file ${debugConfig.program}`);
            vscode_1.window.showWarningMessage(`Your launch config references a program that does not exist. If you have problems launching, check the "program" field in your ".vscode/launch.json" file.`);
        }
    }
    errorWithoutOpeningLaunchConfig(message) {
        this.logger.error(message);
        vscode_1.window.showErrorMessage(message);
        return undefined; // undefined means silent (don't open launch.json).
    }
    installDependencies(debugType, pubGlobal) {
        return debugType === enums_1.DebuggerType.Web
            ? new webdev_1.WebDev(pubGlobal).installIfRequired()
            : true;
    }
    guessBestEntryPoint(openFile, folder) {
        var _a;
        // For certain open files, assume the user wants to run them.
        if ((0, utils_4.isValidEntryFile)(openFile)) {
            this.logger.info(`Using open file as entry point: ${openFile}`);
            return openFile;
        }
        // Use the open file as a clue to find the best project root, then search from there.
        const projectRoot = (openFile && (0, project_1.locateBestProjectRoot)(openFile)) || folder;
        if (projectRoot) {
            const commonLaunchPaths = [
                path.join(projectRoot, "lib", "main.dart"),
                path.join(projectRoot, "bin", "main.dart"),
            ];
            for (const launchPath of commonLaunchPaths) {
                if (fs.existsSync(launchPath)) {
                    this.logger.info(`Using found common entry point: ${launchPath}`);
                    return launchPath;
                }
            }
            // If we don't have a bin folder, or a lib/main.dart, or a web folder, then
            // see if we have an example and try that.
            if (!fs.existsSync(path.join(projectRoot, "bin"))
                && !fs.existsSync(path.join(projectRoot, "web"))
                && fs.existsSync(path.join(projectRoot, "example")))
                return this.guessBestEntryPoint(undefined, path.join(projectRoot, "example"));
        }
        // Finally, if we don't have any workspace folder open, assume the user just wants to
        // run this file.
        if (!((_a = vscode_1.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a.length))
            return openFile;
    }
    getFullVmServiceUri(vmServiceUriOrPort) {
        return __awaiter(this, void 0, void 0, function* () {
            vmServiceUriOrPort = vmServiceUriOrPort || (yield vs.commands.executeCommand("dart.promptForVmService"));
            vmServiceUriOrPort = vmServiceUriOrPort && vmServiceUriOrPort.trim();
            // If the input is just a number, treat is as a localhost port.
            if (vmServiceUriOrPort && /^[0-9]+$/.exec(vmServiceUriOrPort)) {
                vmServiceUriOrPort = `http://127.0.0.1:${vmServiceUriOrPort}`;
            }
            return vmServiceUriOrPort;
        });
    }
    setupDebugConfig(folder, debugConfig, debugType, isFlutter, isAttach, isTest, device, deviceManager) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const conf = config_1.config.for(folder && folder.uri);
            // Attach any properties that weren't explicitly set.
            if (!debugConfig.name) {
                if (isFlutter && debugConfig.deviceId) {
                    debugConfig.name = `Flutter (${debugConfig.deviceId})`;
                }
                else if (isFlutter && device) {
                    debugConfig.name = `Flutter (${deviceManager ? deviceManager.labelForDevice(device) : device.name})`;
                }
                else if (isFlutter) {
                    debugConfig.name = "Flutter";
                }
                else {
                    debugConfig.name = "Dart";
                }
            }
            // Some properties depend ont he device, so infer that first if required.
            if (isFlutter && !debugConfig.deviceId && device) {
                debugConfig.deviceId = device.id;
                debugConfig.deviceName = `${deviceManager ? deviceManager.labelForDevice(device) : device.name} (${device.platform})`;
            }
            debugConfig.toolEnv = (0, processes_1.getToolEnv)();
            debugConfig.sendLogsToClient = true;
            debugConfig.cwd = debugConfig.cwd || (folder && (0, fs_1.fsPath)(folder.uri));
            debugConfig.additionalProjectPaths = debugConfig.additionalProjectPaths || ((_a = vs.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a.map((wf) => (0, fs_1.fsPath)(wf.uri)));
            debugConfig.args = debugConfig.args || [];
            debugConfig.vmAdditionalArgs = debugConfig.vmAdditionalArgs || conf.vmAdditionalArgs;
            debugConfig.toolArgs = yield this.buildToolArgs(debugType, debugConfig, conf);
            debugConfig.vmServicePort = (_b = debugConfig.vmServicePort) !== null && _b !== void 0 ? _b : 0;
            debugConfig.dartSdkPath = this.wsContext.sdks.dart;
            debugConfig.vmServiceLogFile = this.insertSessionName(debugConfig, debugConfig.vmServiceLogFile || conf.vmServiceLogFile);
            debugConfig.webDaemonLogFile = this.insertSessionName(debugConfig, debugConfig.webDaemonLogFile || conf.webDaemonLogFile);
            debugConfig.maxLogLineLength = debugConfig.maxLogLineLength || config_1.config.maxLogLineLength;
            debugConfig.dartTestLogFile = this.insertSessionName(debugConfig, debugConfig.dartTestLogFile || conf.dartTestLogFile);
            debugConfig.debugSdkLibraries = debugConfig.debugSdkLibraries !== undefined && debugConfig.debugSdkLibraries !== null
                ? debugConfig.debugSdkLibraries
                : !!config_1.config.debugSdkLibraries;
            debugConfig.debugExternalPackageLibraries = debugConfig.debugExternalPackageLibraries !== undefined && debugConfig.debugExternalPackageLibraries !== null
                ? debugConfig.debugExternalPackageLibraries
                : config_1.config.debugExternalPackageLibraries;
            debugConfig.showDartDeveloperLogs = conf.showDartDeveloperLogs;
            debugConfig.evaluateGettersInDebugViews = debugConfig.evaluateGettersInDebugViews || conf.evaluateGettersInDebugViews;
            debugConfig.evaluateToStringInDebugViews = debugConfig.evaluateToStringInDebugViews || config_1.config.evaluateToStringInDebugViews;
            if (!isFlutter && !isAttach && !isTest && debugConfig.console === undefined && config_1.config.cliConsole !== undefined)
                debugConfig.console = config_1.config.cliConsole;
            if (isFlutter && this.wsContext.sdks.flutter) {
                debugConfig.flutterSdkPath = this.wsContext.sdks.flutter;
                debugConfig.omitTargetFlag = this.wsContext.config.omitTargetFlag;
                debugConfig.useInspectorNotificationsForWidgetErrors = config_1.config.showInspectorNotificationsForWidgetErrors;
                if (!isAttach) {
                    const customScript = isTest
                        ? this.wsContext.config.flutterTestScript
                        : this.wsContext.config.flutterRunScript;
                    debugConfig.customTool = customScript === null || customScript === void 0 ? void 0 : customScript.script;
                    debugConfig.customToolReplacesArgs = customScript === null || customScript === void 0 ? void 0 : customScript.replacesArgs;
                }
                debugConfig.flutterRunLogFile = this.insertSessionName(debugConfig, debugConfig.flutterRunLogFile || conf.flutterRunLogFile);
                debugConfig.flutterTestLogFile = this.insertSessionName(debugConfig, debugConfig.flutterTestLogFile || conf.flutterTestLogFile);
                debugConfig.showMemoryUsage =
                    debugConfig.showMemoryUsage || debugConfig.showMemoryUsage === false
                        ? debugConfig.showMemoryUsage
                        : debugConfig.flutterMode === "profile";
            }
        });
    }
    /// Builds arguments to be passed to tools (Dart VM or Flutter tool) for a given launch config.
    ///
    /// Arguments included here are usually based on convenience flags that are supported in launch.json, and are
    /// just mapped to standard arguments in an array.
    ///
    /// All arguments built here should be things that user the recognises based on the app they are trying to launch
    /// or settings they have configured. It should not include things that are specifically required by the debugger
    /// (for example, enabling the VM Service or starting paused). Those items should be handled inside the Debug Adapter.
    buildToolArgs(debugType, debugConfig, conf) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let args = [];
            args = args.concat((_a = debugConfig.toolArgs) !== null && _a !== void 0 ? _a : []);
            switch (debugType) {
                case enums_1.DebuggerType.Dart:
                    args = args.concat(yield this.buildDartToolArgs(debugConfig, conf));
                    break;
                case enums_1.DebuggerType.DartTest:
                    args = args.concat(yield this.buildDartTestToolArgs(debugConfig, conf));
                    break;
                case enums_1.DebuggerType.Flutter:
                    args = args.concat(yield this.buildFlutterToolArgs(debugConfig, conf));
                    break;
                case enums_1.DebuggerType.FlutterTest:
                    args = args.concat(yield this.buildFlutterTestToolArgs(debugConfig, conf));
                    break;
            }
            return args;
        });
    }
    buildDartToolArgs(debugConfig, conf) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [];
            const isDebug = debugConfig.noDebug !== true;
            this.addArgsIfNotExist(args, ...conf.cliAdditionalArgs);
            if (isDebug && debugConfig.enableAsserts !== false) // undefined = on
                this.addArgsIfNotExist(args, "--enable-asserts");
            return args;
        });
    }
    buildDartTestToolArgs(debugConfig, conf) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [];
            this.addArgsIfNotExist(args, ...conf.testAdditionalArgs);
            if (conf.suppressTestTimeouts === "always" || (conf.suppressTestTimeouts === "debug" && !debugConfig.noDebug))
                this.addArgsIfNotExist(args, "--timeout", "1d");
            return args;
        });
    }
    buildFlutterToolArgs(debugConfig, conf) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const args = [];
            const isDebug = debugConfig.noDebug !== true;
            const isAttach = debugConfig.request === "attach";
            const isWeb = (0, utils_2.isWebDevice)(debugConfig.deviceId);
            this.addArgsIfNotExist(args, ...(0, processes_1.getGlobalFlutterArgs)());
            this.addArgsIfNotExist(args, ...conf.flutterAdditionalArgs);
            if (isAttach)
                this.addArgsIfNotExist(args, ...conf.flutterAttachAdditionalArgs);
            else
                this.addArgsIfNotExist(args, ...conf.flutterRunAdditionalArgs);
            if (debugConfig.deviceId)
                this.addArgsIfNotExist(args, "-d", debugConfig.deviceId);
            if (!isAttach) {
                switch (debugConfig.flutterMode) {
                    case "profile":
                    case "release":
                        this.addArgsIfNotExist(args, `--${debugConfig.flutterMode}`);
                        break;
                    default: // Debug mode.
                        if (debugConfig.vmServicePort && isDebug)
                            this.addArgsIfNotExist(args, "--observatory-port", debugConfig.vmServicePort.toString());
                        if (!conf.flutterTrackWidgetCreation && !args.includes("--no-track-widget-creation"))
                            this.addArgsIfNotExist(args, "--no-track-widget-creation");
                        if (conf.flutterStructuredErrors && this.flutterCapabilities.supportsDartDefine)
                            this.addArgsIfNotExist(args, "--dart-define=flutter.inspector.structuredErrors=true");
                }
                if (debugConfig.flutterPlatform && debugConfig.flutterPlatform !== "default")
                    this.addArgsIfNotExist(args, "--target-platform", debugConfig.flutterPlatform);
                if (debugConfig.deviceId === "web-server") {
                    if (this.flutterCapabilities.supportsWsVmService && !args.includes("--web-server-debug-protocol"))
                        this.addArgsIfNotExist(args, "--web-server-debug-protocol", "ws");
                    if (config_1.config.debugExtensionBackendProtocol && this.flutterCapabilities.supportsWsDebugBackend)
                        this.addArgsIfNotExist(args, "--web-server-debug-backend-protocol", config_1.config.debugExtensionBackendProtocol);
                    if (config_1.config.debugExtensionBackendProtocol && this.flutterCapabilities.supportsWsInjectedClient)
                        this.addArgsIfNotExist(args, "--web-server-debug-injected-client-protocol", config_1.config.debugExtensionBackendProtocol);
                }
                if (this.flutterCapabilities.supportsExposeUrl)
                    this.addArgsIfNotExist(args, "--web-allow-expose-url");
                if (isWeb) {
                    const renderer = (0, utils_1.getFutterWebRenderer)(this.flutterCapabilities, config_1.config.flutterWebRenderer);
                    if (renderer)
                        this.addArgsIfNotExist(args, "--web-renderer", renderer);
                }
            }
            if (config_1.config.shareDevToolsWithFlutter && this.flutterCapabilities.supportsDevToolsServerAddress && !args.includes("--devtools-server-address")) {
                this.logger.info("Getting DevTools server address to pass to Flutter...");
                try {
                    const devtoolsUrl = yield ((_a = this.debugCommands.devTools) === null || _a === void 0 ? void 0 : _a.devtoolsUrl);
                    if (devtoolsUrl)
                        this.addArgsIfNotExist(args, "--devtools-server-address", devtoolsUrl.toString());
                    else
                        this.logger.warn("DevTools server unavailable, not sending --devtools-server-address!");
                }
                catch (e) {
                    this.logger.error(`Failed to get DevTools server address ${e}`);
                }
            }
            if (logging_1.isLogging && !args.includes("--verbose"))
                this.addArgsIfNotExist(args, "-v");
            return args;
        });
    }
    buildFlutterTestToolArgs(debugConfig, conf) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [];
            this.addArgsIfNotExist(args, ...(0, processes_1.getGlobalFlutterArgs)());
            this.addArgsIfNotExist(args, ...conf.flutterAdditionalArgs);
            this.addArgsIfNotExist(args, ...conf.flutterTestAdditionalArgs);
            if (debugConfig.deviceId)
                this.addArgsIfNotExist(args, "-d", debugConfig.deviceId);
            if (conf.suppressTestTimeouts === "always" || (conf.suppressTestTimeouts === "debug" && !debugConfig.noDebug))
                this.addArgsIfNotExist(args, "--timeout", "1d");
            return args;
        });
    }
    addArgsIfNotExist(args, ...toAdd) {
        if (!args.includes(toAdd[0])) {
            toAdd.forEach((s) => args.push(s));
        }
    }
    insertSessionName(args, logPath) {
        return logPath
            ? logPath.replace(/\${name}/, (0, utils_2.filenameSafe)(args.name || "unnamed-session"))
            : logPath;
    }
}
exports.DebugConfigProvider = DebugConfigProvider;
class InitialLaunchJsonDebugConfigProvider {
    constructor(logger) {
        this.logger = logger;
    }
    provideDebugConfigurations(folder, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const rootFolder = folder ? (0, fs_1.fsPath)(folder.uri) : undefined;
            const projectFolders = rootFolder ? yield (0, fs_1.findProjectFolders)(this.logger, [rootFolder], (0, utils_4.getExcludedFolders)(folder), { requirePubspec: true }) : [];
            if (projectFolders.length) {
                for (const projectFolder of projectFolders) {
                    const isFlutter = (0, utils_4.isFlutterProjectFolder)(projectFolder);
                    const name = path.basename(projectFolder);
                    // Compute cwd, using undefined instead of empty if rootFolder === projectFolder
                    const cwd = rootFolder ? path.relative(rootFolder, projectFolder) || undefined : undefined;
                    if (isFlutter) {
                        results.push({
                            name,
                            cwd,
                            request: "launch",
                            type: "dart",
                        });
                        results.push({
                            name: `${name} (profile mode)`,
                            cwd,
                            request: "launch",
                            type: "dart",
                            flutterMode: "profile",
                        });
                    }
                    else {
                        results.push({
                            name,
                            cwd,
                            request: "launch",
                            type: "dart",
                        });
                    }
                }
            }
            else {
                results.push({
                    name: "Dart & Flutter",
                    request: "launch",
                    type: "dart",
                });
            }
            return results;
        });
    }
}
exports.InitialLaunchJsonDebugConfigProvider = InitialLaunchJsonDebugConfigProvider;
class DynamicDebugConfigProvider {
    constructor(logger) {
        this.logger = logger;
    }
    provideDebugConfigurations(folder, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const rootFolder = folder ? (0, fs_1.fsPath)(folder.uri) : undefined;
            const projectFolders = rootFolder ? yield (0, fs_1.findProjectFolders)(this.logger, [rootFolder], (0, utils_4.getExcludedFolders)(folder), { requirePubspec: true }) : [];
            for (const projectFolder of projectFolders) {
                const isFlutter = (0, utils_4.isFlutterProjectFolder)(projectFolder);
                const name = path.basename(projectFolder);
                // Compute cwd, using undefined instead of empty if rootFolder === projectFolder
                const cwd = rootFolder ? path.relative(rootFolder, projectFolder) || undefined : undefined;
                const exists = (p) => folder && fs.existsSync(path.join(projectFolder, p));
                if (isFlutter && exists("lib/main.dart")) {
                    results.push({
                        name: `Flutter`,
                        program: "lib/main.dart",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                    results.push({
                        name: `Flutter (profile mode)`,
                        program: "lib/main.dart",
                        cwd,
                        request: "launch",
                        type: "dart",
                        flutterMode: "profile",
                    });
                }
                if (!isFlutter && exists("web")) {
                    results.push({
                        name: `Dart Web`,
                        program: "web",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
                if (exists("bin/main.dart")) {
                    results.push({
                        name: `Dart`,
                        program: "bin/main.dart",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
                if (exists("test")) {
                    results.push({
                        name: `${isFlutter ? "Flutter" : "Dart"} Tests`,
                        program: "test",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
                if (isFlutter && exists("integration_test")) {
                    results.push({
                        name: `${isFlutter ? "Flutter" : "Dart"} Integration Tests`,
                        program: "integration_test",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
            }
            return results;
        });
    }
}
exports.DynamicDebugConfigProvider = DynamicDebugConfigProvider;


/***/ }),

/***/ 5587:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(8779);
const dart_diagnostic_provider_1 = __webpack_require__(5453);
const ranking_code_action_provider_1 = __webpack_require__(7702);
class FixCodeActionProvider {
    constructor(logger, selector, analyzer) {
        this.logger = logger;
        this.selector = selector;
        this.analyzer = analyzer;
        this.rank = 1;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.QuickFix],
        };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_1.isAnalyzableAndInWorkspace)(document))
                return undefined;
            // If we were only asked for specific action types and that doesn't include
            // quickfix (which is all we supply), bail out.
            if (context && context.only && !vscode_1.CodeActionKind.QuickFix.contains(context.only))
                return undefined;
            try {
                const pos = "active" in range ? range.active : range.start;
                const result = yield this.analyzer.editGetFixes({
                    file: (0, fs_1.fsPath)(document.uri),
                    offset: document.offsetAt(pos),
                });
                if (token && token.isCancellationRequested)
                    return;
                // Because fixes may be the same for multiple errors, we'll de-dupe them based on their edit.
                const allActions = {};
                for (const errorFix of result.fixes) {
                    for (const fix of errorFix.fixes) {
                        allActions[JSON.stringify(fix.edits)] = this.convertResult(document, fix, errorFix.error);
                    }
                }
                const allFixes = Object.keys(allActions).map((a) => allActions[a]);
                return context.only
                    ? allFixes.filter((f) => { var _a; return (_a = context.only) === null || _a === void 0 ? void 0 : _a.contains(f.kind); })
                    : allFixes;
            }
            catch (e) {
                this.logger.error(e);
                throw e;
            }
        });
    }
    convertResult(document, change, error) {
        const title = change.message;
        const diagnostics = error ? [dart_diagnostic_provider_1.DartDiagnosticProvider.createDiagnostic(error)] : undefined;
        const kind = (0, ranking_code_action_provider_1.getKindFor)(change.id, vscode_1.CodeActionKind.QuickFix);
        const action = new vscode_1.CodeAction(title, kind);
        action.command = {
            arguments: [document, change],
            command: "_dart.applySourceChange",
            title,
        };
        action.diagnostics = diagnostics;
        return action;
    }
}
exports.FixCodeActionProvider = FixCodeActionProvider;


/***/ }),

/***/ 2862:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IgnoreLintCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const config_1 = __webpack_require__(4165);
const utils_1 = __webpack_require__(8779);
const dart_diagnostic_provider_1 = __webpack_require__(5453);
class IgnoreLintCodeActionProvider {
    constructor(selector) {
        this.selector = selector;
        this.rank = 100;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.QuickFix],
        };
    }
    provideCodeActions(document, range, context, token) {
        if (!(0, utils_1.isAnalyzableAndInWorkspace)(document))
            return;
        // If we were only asked for specific action types and that doesn't include
        // quickfix (which is all we supply), bail out.
        if (context && context.only && !vscode_1.CodeActionKind.QuickFix.contains(context.only))
            return;
        if (!config_1.config.showIgnoreQuickFixes || !context || !context.diagnostics || !context.diagnostics.length)
            return;
        const lintErrors = context.diagnostics.filter((d) => d.range.intersection(range)
            && (
            // Non-LSP:
            (d instanceof dart_diagnostic_provider_1.DartDiagnostic && (d.type === "LINT" || d.type === "HINT")
                // LSP:
                || (d.source === "dart" && d.severity === vscode_1.DiagnosticSeverity.Information))));
        if (!lintErrors.length)
            return;
        return lintErrors.map((diagnostic) => this.convertResult(document, diagnostic));
    }
    convertResult(document, diagnostic) {
        const type = diagnostic instanceof dart_diagnostic_provider_1.DartDiagnostic ? `${diagnostic.type.toLowerCase()} ` : "";
        const dCode = diagnostic.code || "";
        const code = typeof dCode === "string" ? dCode : dCode.value;
        const edit = new vscode_1.WorkspaceEdit();
        const line = document.lineAt(diagnostic.range.start.line);
        edit.insert(document.uri, line.range.start, `${" ".repeat(line.firstNonWhitespaceCharacterIndex)}// ignore: ${code}\n`);
        const title = `Ignore ${type}'${code}' for this line`;
        const action = new vscode_1.CodeAction(title, vscode_1.CodeActionKind.QuickFix);
        action.edit = edit;
        return action;
    }
}
exports.IgnoreLintCodeActionProvider = IgnoreLintCodeActionProvider;


/***/ }),

/***/ 23:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyDartWorkspaceSymbolProvider = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(7220);
const analyzer_das_1 = __webpack_require__(2061);
const utils_2 = __webpack_require__(8779);
class LegacyDartWorkspaceSymbolProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
    }
    provideWorkspaceSymbols(query, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (query.length === 0)
                return undefined;
            query = this.sanitizeUserQuery(query);
            const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
            const results = yield Promise.all([
                this.analyzer.searchFindTopLevelDeclarationsResults({ pattern }),
                this.analyzer.searchFindMemberDeclarationsResults({ name: pattern }),
            ]);
            return this.combineResults(results);
        });
    }
    combineResults(results) {
        return results[0].results.concat(results[1].results)
            .filter((r) => this.shouldIncludeResult(r))
            .map((r) => this.convertResult(r));
    }
    searchTopLevelSymbols(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
            const resp = yield this.analyzer.searchFindTopLevelDeclarationsResults({ pattern });
            return resp.results;
        });
    }
    searchMemberDeclarations(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
            const resp = yield this.analyzer.searchFindMemberDeclarationsResults({ name: pattern });
            return resp.results;
        });
    }
    sanitizeUserQuery(query) {
        let chars = Array.from(query);
        // Filter out special chars that will break regex.
        // searchFindTopLevelDeclarations supports regex, but we build the pattern with the output of this.
        // searchMemberDeclarations is not intended to support regex but does.
        chars = chars.filter((c) => "[](){}\\|./<>?+".indexOf(c) === -1);
        return chars.join("");
    }
    makeCaseInsensitiveFuzzyRegex(query) {
        let chars = Array.from(query);
        chars = chars.map((c) => {
            if (c.toUpperCase() === c.toLowerCase())
                return c;
            return `[${c.toUpperCase()}${c.toLowerCase()}]`;
        });
        const pattern = chars.join(".*");
        return `.*${pattern}.*`;
    }
    shouldIncludeResult(result) {
        // Must be either:
        //   1. Public (not start with an underscore).
        //   2. In our project.
        const isPrivate = result.path[0].name.startsWith("_") || result.path[1].name.startsWith("_");
        return (0, utils_2.isWithinWorkspace)(result.location.file) || !isPrivate;
    }
    convertResult(result) {
        // Rewrite the filename for best display.
        const containerName = this.createDisplayPath(result.location.file);
        // Remove the library and compilation unit parent elements; concatenate names.
        let elementPathDescription = result.path
            .slice(0, result.path.length - 2)
            .reverse()
            .map((e) => e.name)
            .join(".");
        // For properties, show if get/set.
        if (result.path[0].kind === "SETTER")
            elementPathDescription += " set";
        if (result.path[0].kind === "GETTER")
            elementPathDescription += " get";
        const parameters = result.path[0].parameters && result.path[0].kind !== "SETTER"
            ? result.path[0].parameters
            : "";
        return new vscode_1.SymbolInformation(elementPathDescription + parameters, (0, analyzer_das_1.getSymbolKindForElementKind)(this.logger, result.path[0].kind), containerName || "", new vscode_1.Location(vscode_1.Uri.file(result.location.file), (0, utils_1.toRangeOnLine)(result.location)));
    }
    createDisplayPath(inputPath) {
        if (!inputPath)
            return undefined;
        // HACK: The AS returns paths to the PUB_CACHE folder, which Code can't
        // convert to relative paths (so they look terrible). If the file exists in
        // workspace.rootPath we rewrite the path to there which gives us a nice
        // relative path.
        // Currently I only do this for "hosted\pub.dartlang.org" as I'm not sure of the
        // rules for these paths!
        const pubCachePath = "hosted" + path.sep + "pub.dartlang.org";
        const pubCachePathIndex = inputPath.indexOf(pubCachePath);
        if (pubCachePathIndex > -1) {
            const relativePath = inputPath.substring(pubCachePathIndex + pubCachePath.length + 1);
            // Packages in pubcache are versioned so trim the "-x.x.x" off the end of the foldername.
            const pathComponents = relativePath.split(path.sep);
            pathComponents[0] = pathComponents[0].split("-")[0];
            // Symlink goes into the lib folder, so strip that out of the path.
            if (pathComponents[1] === "lib")
                pathComponents.splice(1, 1);
            // Return 'package:foo/bar.dart'.
            inputPath = `package:${pathComponents[0]}/${pathComponents.slice(1).join("/")}`;
        }
        else {
            const root = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(inputPath));
            inputPath = root && path.relative((0, fs_1.fsPath)(root.uri), inputPath);
        }
        return inputPath;
    }
}
exports.LegacyDartWorkspaceSymbolProvider = LegacyDartWorkspaceSymbolProvider;


/***/ }),

/***/ 7702:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getKindFor = exports.RankingCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
class RankingCodeActionProvider {
    constructor() {
        this.codeActionProviders = [];
    }
    registerProvider(provider) {
        this.codeActionProviders.push(provider);
        (0, array_1.sortBy)(this.codeActionProviders, (p) => p.rank);
    }
    get metadata() {
        const allKinds = (0, utils_1.flatMap)(this.codeActionProviders, (p) => p.metadata.providedCodeActionKinds || []);
        return { providedCodeActionKinds: (0, utils_1.uniq)(allKinds) };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Sort the providers, because then their results will be sorted (flatMap doesn't change the order, and
            // Promise.all preserves order).
            const applicableProviders = this.codeActionProviders.filter((p) => vscode_1.languages.match(p.selector, document));
            const promises = applicableProviders.map((p) => p.provideCodeActions(document, range, context, token));
            const allResults = yield Promise.all(promises);
            const flatResults = (0, utils_1.flatMap)(allResults, (x) => x || []);
            return flatResults;
        });
    }
}
exports.RankingCodeActionProvider = RankingCodeActionProvider;
function getKindFor(id, base) {
    if (!id)
        return base;
    const newID = id
        .replace("dart.assist.", "")
        .replace("dart.fix.", "")
        .replace("analysisOptions.assist.", "")
        .replace("analysisOptions.fix.", "");
    return base.append(newID);
}
exports.getKindFor = getKindFor;


/***/ }),

/***/ 3797:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RefactorCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(8779);
const supportedRefactors = {
    CONVERT_METHOD_TO_GETTER: "Convert Method to Getter",
    EXTRACT_LOCAL_VARIABLE: "Extract Local Variable",
    EXTRACT_METHOD: "Extract Method",
    EXTRACT_WIDGET: "Extract Widget",
};
class RefactorCodeActionProvider {
    constructor(selector, analyzer) {
        this.selector = selector;
        this.analyzer = analyzer;
        this.rank = 50;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.Refactor],
        };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_2.isAnalyzableAndInWorkspace)(document))
                return undefined;
            // If we were only asked for specific action types and that doesn't include
            // refactor (which is all we supply), bail out.
            if (context && context.only && !vscode_1.CodeActionKind.Refactor.contains(context.only))
                return undefined;
            try {
                const startOffset = document.offsetAt(range.start);
                const endOffset = document.offsetAt(range.end);
                const result = yield this.analyzer.editGetAvailableRefactorings({
                    file: (0, fs_1.fsPath)(document.uri),
                    length: endOffset - startOffset,
                    offset: startOffset,
                });
                if (token && token.isCancellationRequested)
                    return;
                const allRefactors = result.kinds.map((k) => this.getSupportedRefactorForKind(document, range, k)).filter(utils_1.notUndefined);
                return context.only
                    ? allRefactors.filter((r) => { var _a; return (_a = context.only) === null || _a === void 0 ? void 0 : _a.contains(r.kind); })
                    : allRefactors;
            }
            catch (e) {
                // TODO: Swap this back to logError/throw when https://github.com/dart-lang/sdk/issues/33471 is fixed.
                return [];
                // logError(e);
                // reject();
            }
        });
    }
    getSupportedRefactorForKind(document, range, k) {
        if (!supportedRefactors[k])
            return;
        const title = supportedRefactors[k];
        const action = new vscode_1.CodeAction(title, vscode_1.CodeActionKind.Refactor);
        action.command = {
            arguments: [document, range, k],
            command: "_dart.performRefactor",
            title,
        };
        return action;
    }
}
exports.RefactorCodeActionProvider = RefactorCodeActionProvider;


/***/ }),

/***/ 2252:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnippetCompletionItemProvider = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const extension_utils_1 = __webpack_require__(6143);
const config_1 = __webpack_require__(4165);
class SnippetCompletionItemProvider {
    constructor(filename, shouldRender) {
        this.completions = new vscode_1.CompletionList();
        this.shouldRender = shouldRender;
        const snippets = (0, extension_utils_1.readJson)(path.join(extension_utils_1.extensionPath, filename));
        for (const snippetType of Object.keys(snippets)) {
            for (const snippetName of Object.keys(snippets[snippetType])) {
                const snippet = snippets[snippetType][snippetName];
                const completionItem = new vscode_1.CompletionItem(snippetName, vscode_1.CompletionItemKind.Snippet);
                completionItem.filterText = snippet.prefix;
                completionItem.insertText = new vscode_1.SnippetString(Array.isArray(snippet.body)
                    ? snippet.body.join("\n")
                    : snippet.body);
                completionItem.detail = snippet.description;
                completionItem.documentation = new vscode_1.MarkdownString().appendCodeblock(completionItem.insertText.value);
                completionItem.sortText = "zzzzzzzzzzzzzzzzzzzzzz";
                this.completions.items.push(completionItem);
            }
        }
    }
    provideCompletionItems(document, position, token, context) {
        if (!config_1.config.enableSnippets)
            return;
        const line = document.lineAt(position.line).text.slice(0, position.character);
        if (!this.shouldAllowCompletion(line, context))
            return;
        if (!this.shouldRender(document.uri))
            return;
        return this.completions;
    }
    shouldAllowCompletion(line, context) {
        line = line.trim();
        // Don't provide completions after comment markers. This isn't perfect since it'll
        // suppress them for ex if // appears inside strings, but it's a reasonable
        // approximation given we don't have a reliable way to tell that.
        if (line.indexOf("//") !== -1)
            return false;
        // Otherwise, allow through.
        return true;
    }
}
exports.SnippetCompletionItemProvider = SnippetCompletionItemProvider;


/***/ }),

/***/ 4508:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(7220);
const utils_2 = __webpack_require__(8779);
class SourceCodeActionProvider {
    provideCodeActions(document, range, context, token) {
        if (!(0, utils_2.isAnalyzableAndInWorkspace)(document))
            return undefined;
        const actions = [];
        if (!context
            || !context.only
            || context.only.contains(vscode_1.CodeActionKind.Source)
            || context.only.contains(vscode_1.CodeActionKind.SourceOrganizeImports)) {
            actions.push({
                command: {
                    arguments: [document],
                    command: "_dart.organizeImports",
                    title: "Organize Imports",
                },
                kind: vscode_1.CodeActionKind.SourceOrganizeImports,
                title: "Organize Imports",
            });
        }
        if (!context
            || !context.only
            || context.only.contains(vscode_1.CodeActionKind.Source)
            || context.only.contains(utils_1.SourceSortMembersCodeActionKind)) {
            actions.push({
                command: {
                    arguments: [document],
                    command: "dart.sortMembers",
                    title: "Sort Members",
                },
                kind: utils_1.SourceSortMembersCodeActionKind,
                title: "Sort Members",
            });
        }
        return actions;
    }
}
exports.SourceCodeActionProvider = SourceCodeActionProvider;
SourceCodeActionProvider.metadata = {
    providedCodeActionKinds: [vscode_1.CodeActionKind.Source, vscode_1.CodeActionKind.SourceOrganizeImports, utils_1.SourceSortMembersCodeActionKind],
};


/***/ }),

/***/ 334:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PubGlobal = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const processes_1 = __webpack_require__(5837);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
const processes_2 = __webpack_require__(5430);
class PubGlobal {
    constructor(logger, dartCapabilities, context, sdks, pubApi) {
        this.logger = logger;
        this.dartCapabilities = dartCapabilities;
        this.context = context;
        this.sdks = sdks;
        this.pubApi = pubApi;
    }
    installIfRequired(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const packageID = options.packageID;
            const packageName = (_a = options.packageName) !== null && _a !== void 0 ? _a : packageID;
            const moreInfoLink = (_b = options.moreInfoLink) !== null && _b !== void 0 ? _b : constants_1.pubGlobalDocsUrl;
            const requiredVersion = options.requiredVersion;
            const silent = !!options.silent;
            let autoUpdate = !!options.autoUpdate;
            let installedVersion = yield this.getInstalledVersion(packageName, packageID);
            const versionStatus = yield this.checkVersionStatus(packageID, installedVersion, requiredVersion);
            if (versionStatus === enums_1.VersionStatus.Valid)
                return installedVersion;
            if (silent)
                autoUpdate = true;
            const activateForMe = versionStatus === enums_1.VersionStatus.NotInstalled ? `Activate ${packageName}` : `Update ${packageName}`;
            const message = versionStatus === enums_1.VersionStatus.NotInstalled
                ? `${packageName} needs to be installed with 'pub global activate ${packageID}' to use this feature.`
                : (versionStatus === enums_1.VersionStatus.UpdateRequired
                    ? `${packageName} needs to be updated with 'pub global activate ${packageID}' to use this feature.`
                    : `A new version of ${packageName} is available and can be installed with 'pub global activate ${packageID}'.`);
            let action = 
            // If we need an update and we're allowed to auto-update, to the same as if the user
            // clicked the activate button, otherwise prompt them.
            autoUpdate && ((versionStatus === enums_1.VersionStatus.UpdateRequired || versionStatus === enums_1.VersionStatus.UpdateAvailable) || silent)
                ? activateForMe
                : yield vs.window.showWarningMessage(message, activateForMe, constants_1.moreInfoAction);
            if (action === constants_1.moreInfoAction) {
                yield utils_2.envUtils.openInBrowser(moreInfoLink);
                return undefined;
            }
            else if (action === activateForMe) {
                const actionName = versionStatus === enums_1.VersionStatus.NotInstalled ? `Activating ${packageName}` : `Updating ${packageName}`;
                const args = ["global", "activate", packageID];
                try {
                    if (silent)
                        yield this.runCommand(packageName, args);
                    else
                        yield this.runCommandWithProgress(packageName, `${actionName}...`, args);
                    installedVersion = yield this.getInstalledVersion(packageName, packageID);
                    const newVersionStatus = yield this.checkVersionStatus(packageID, installedVersion);
                    if (newVersionStatus !== enums_1.VersionStatus.Valid) {
                        this.logger.warn(`After installing ${packageID}, version status was ${enums_1.VersionStatus[newVersionStatus]} and not Valid!`);
                    }
                    return installedVersion;
                }
                catch (e) {
                    this.logger.error(e);
                    if (!silent) {
                        action = yield vs.window.showErrorMessage(`${actionName} failed. Please try running 'pub global activate ${packageID}' manually.`, constants_1.moreInfoAction);
                        if (action === constants_1.moreInfoAction) {
                            yield utils_2.envUtils.openInBrowser(moreInfoLink);
                        }
                    }
                    return undefined;
                }
            }
            return undefined;
        });
    }
    backgroundActivate(packageName, packageID, silent) {
        return __awaiter(this, void 0, void 0, function* () {
            const actionName = `Activating ${packageName}`;
            const args = ["global", "activate", packageID];
            if (silent)
                yield this.runCommand(packageName, args);
            else
                yield this.runCommandWithProgress(packageName, `${actionName}...`, args);
        });
    }
    uninstall(packageID) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["global", "deactivate", packageID];
            yield this.runCommand(packageID, args);
        });
    }
    checkVersionStatus(packageID, installedVersion, requiredVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!installedVersion) {
                this.logger.info(`${packageID} has no installed version, returning NotInstalled`);
                return enums_1.VersionStatus.NotInstalled;
            }
            // If we need a specific version, check it here.
            if (requiredVersion && !(0, utils_1.pubVersionIsAtLeast)(installedVersion, requiredVersion)) {
                this.logger.info(`${packageID} version ${installedVersion} is not at least ${requiredVersion} so returning UpdateRequired`);
                return enums_1.VersionStatus.UpdateRequired;
            }
            // If we haven't checked in the last 24 hours, check if there's an update available.
            const lastChecked = this.context.getPackageLastCheckedForUpdates(packageID);
            if (!lastChecked || lastChecked <= Date.now() - constants_1.noRepeatPromptThreshold) {
                this.context.setPackageLastCheckedForUpdates(packageID, Date.now());
                try {
                    const pubPackage = yield this.pubApi.getPackage(packageID);
                    if (!(0, utils_1.pubVersionIsAtLeast)(installedVersion, pubPackage.latest.version)) {
                        this.logger.info(`${packageID} version ${installedVersion} is not at least ${pubPackage.latest.version} so returning UpdateAvailable`);
                        return enums_1.VersionStatus.UpdateAvailable;
                    }
                }
                catch (e) {
                    // If we fail to call the API to check for a new version, then we can run
                    // with what we have.
                    this.logger.warn(`Failed to check for new version of ${packageID}: ${e}`, enums_1.LogCategory.CommandProcesses);
                    return enums_1.VersionStatus.Valid;
                }
            }
            // Otherwise, we're installed and have a new enough version.
            this.logger.info(`${packageID} version ${installedVersion} appears to be latest so returning Valid`);
            return enums_1.VersionStatus.Valid;
        });
    }
    getInstalledVersion(packageName, packageID) {
        return __awaiter(this, void 0, void 0, function* () {
            const output = yield this.runCommand(packageName, ["global", "list"]);
            const versionMatch = new RegExp(`^${packageID} (\\d+\\.\\d+\\.\\d+[\\w.\\-+]*)(?: |$)`, "m");
            const match = versionMatch.exec(output);
            const installedVersion = match ? match[1] : undefined;
            return installedVersion;
        });
    }
    runCommandWithProgress(packageName, title, args, customScript) {
        return vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title,
        }, () => this.runCommand(packageName, args));
    }
    runCommand(packageName, args) {
        const pubExecution = (0, processes_1.getPubExecutionInfo)(this.dartCapabilities, this.sdks.dart, args);
        return new Promise((resolve, reject) => {
            this.logger.info(`Spawning ${pubExecution.executable} with args ${JSON.stringify(pubExecution.args)}`);
            const proc = (0, processes_2.safeToolSpawn)(undefined, pubExecution.executable, pubExecution.args);
            (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const stdout = [];
            const stderr = [];
            proc.stdout.on("data", (data) => stdout.push(data.toString()));
            proc.stderr.on("data", (data) => stderr.push(data.toString()));
            proc.on("close", (code) => {
                if (!code) {
                    resolve(stdout.join(""));
                }
                else {
                    reject(`${packageName} exited with code ${code}.\n\n${stdout.join("")}\n\n${stderr.join("")}`);
                }
            });
        });
    }
}
exports.PubGlobal = PubGlobal;


/***/ }),

/***/ 8376:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.promptToRunPubGet = exports.isPubGetProbablyRequired = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const package_map_1 = __webpack_require__(143);
const fs_1 = __webpack_require__(300);
// TODO: Wrap these up into a class.
function isPubGetProbablyRequired(sdks, logger, folderUri) {
    const folder = (0, fs_1.fsPath)(folderUri);
    const pubspecPath = path.join(folder, "pubspec.yaml");
    const packagesPath = path.join(folder, ".packages");
    if (!folder || !fs.existsSync(pubspecPath))
        return false;
    // If we don't appear to have deps listed in pubspec, then no point prompting.
    const regex = new RegExp("dependencies\\s*:", "i");
    if (!regex.test(fs.readFileSync(pubspecPath).toString()))
        return false;
    // If we don't have .packages, we probably need running.
    if (!fs.existsSync(packagesPath))
        return true;
    const pubspecModified = fs.statSync(pubspecPath).mtime;
    const packagesModified = fs.statSync(packagesPath).mtime;
    if (pubspecModified > packagesModified)
        return true;
    // If we're a Flutter project and our SDK doesn't match the one used
    // in the package file, we also need running.
    if (sdks.flutter) {
        const packageMap = package_map_1.PackageMap.loadForProject(logger, folder);
        const flutterPackagePath = packageMap.getPackagePath("flutter");
        if (flutterPackagePath && !(0, fs_1.isWithinPath)(flutterPackagePath, sdks.flutter)) {
            return true;
        }
    }
    return false;
}
exports.isPubGetProbablyRequired = isPubGetProbablyRequired;
function promptToRunPubGet(folders) {
    const label = "Get packages";
    vscode_1.window.showInformationMessage("Some packages are missing or out of date, would you like to get them now?", label).then((clickedButton) => {
        if (clickedButton === label)
            getPackages(folders);
    });
}
exports.promptToRunPubGet = promptToRunPubGet;
function getPackages(folders) {
    let task = vscode_1.commands.executeCommand("dart.getPackages", folders[0]);
    for (let i = 1; i < folders.length; i++) {
        task = task.then((code) => {
            if (code === 0) // Continue with next one only if success
                return vscode_1.commands.executeCommand("dart.getPackages", folders[i]);
        });
    }
}


/***/ }),

/***/ 5958:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stagehand = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const processes_1 = __webpack_require__(5837);
const utils_1 = __webpack_require__(3438);
const processes_2 = __webpack_require__(5430);
const packageName = "Stagehand";
const packageID = "stagehand";
class Stagehand {
    constructor(logger, dartCapabilities, sdks, pubGlobal) {
        this.logger = logger;
        this.dartCapabilities = dartCapabilities;
        this.sdks = sdks;
        this.pubGlobal = pubGlobal;
    }
    installIfRequired() {
        return this.pubGlobal.installIfRequired({ packageName, packageID, moreInfoLink: constants_1.stagehandInstallationInstructionsUrl, requiredVersion: "3.3.0" });
    }
    getTemplates() {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.getTemplateJson();
            return JSON.parse(json);
        });
    }
    getTemplateJson() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, utils_1.cleanPubOutput)(yield this.runCommandWithProgress("Fetching Stagehand templates...", ["global", "run", "stagehand", "--machine"]));
        });
    }
    runCommandWithProgress(title, args) {
        return vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title,
        }, () => this.runCommand(args));
    }
    runCommand(args) {
        const pubExecution = (0, processes_1.getPubExecutionInfo)(this.dartCapabilities, this.sdks.dart, args);
        return new Promise((resolve, reject) => {
            const proc = (0, processes_2.safeToolSpawn)(undefined, pubExecution.executable, pubExecution.args);
            (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const stdout = [];
            const stderr = [];
            proc.stdout.on("data", (data) => stdout.push(data.toString()));
            proc.stderr.on("data", (data) => stderr.push(data.toString()));
            proc.on("close", (code) => {
                if (!code) {
                    resolve(stdout.join(""));
                }
                else {
                    reject(`Stagehand exited with code ${code}.\n\n${stdout.join("")}\n\n${stderr.join("")}`);
                }
            });
        });
    }
}
exports.Stagehand = Stagehand;


/***/ }),

/***/ 708:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebDev = void 0;
const packageName = "webdev";
const packageID = "webdev";
class WebDev {
    constructor(pubGlobal) {
        this.pubGlobal = pubGlobal;
    }
    installIfRequired() {
        return this.pubGlobal.installIfRequired({ packageName, packageID, moreInfoLink: undefined, requiredVersion: "2.5.4" });
    }
}
exports.WebDev = WebDev;


/***/ }),

/***/ 3285:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCreate = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(3438);
const processes_1 = __webpack_require__(5430);
class DartCreate {
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
    }
    installIfRequired() {
        return __awaiter(this, void 0, void 0, function* () { return "0.0.0"; });
    }
    getTemplates() {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.getTemplateJson();
            return JSON.parse(json);
        });
    }
    getTemplateJson() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, utils_1.cleanPubOutput)(yield this.runCommandWithProgress("Fetching project templates...", ["create", "--list-templates"]));
        });
    }
    runCommandWithProgress(title, args) {
        return vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title,
        }, () => this.runCommand(args));
    }
    runCommand(args) {
        const dartSdkPath = this.sdks.dart;
        const dartBinPath = path.join(dartSdkPath, constants_1.dartVMPath);
        return new Promise((resolve, reject) => {
            const proc = (0, processes_1.safeToolSpawn)(undefined, dartBinPath, args);
            (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const stdout = [];
            const stderr = [];
            proc.stdout.on("data", (data) => stdout.push(data.toString()));
            proc.stderr.on("data", (data) => stderr.push(data.toString()));
            proc.on("close", (code) => {
                if (!code) {
                    resolve(stdout.join(""));
                }
                else {
                    reject(`'dart create' exited with code ${code}.\n\n${stdout.join("")}\n\n${stderr.join("")}`);
                }
            });
        });
    }
}
exports.DartCreate = DartCreate;


/***/ }),

/***/ 8397:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DevToolsEmbeddedView = void 0;
const vs = __webpack_require__(9496);
const events_1 = __webpack_require__(3254);
const utils_1 = __webpack_require__(7220);
const pageScript = `
const vscode = acquireVsCodeApi();
window.addEventListener('message', (event) => {
	const message = event.data;
	const devToolsFrame = document.getElementById('devToolsFrame');
	switch (message.command) {
		case "setUrl":
			const theme = document.body.classList.contains('vscode-light') ? 'light': 'dark';
			const background = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-background');
			const foreground = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-foreground');
			let url = \`\${message.url}&them'e=\${theme}&backgroundColor=\${encodeURIComponent(background)}&foregroundColor=\${encodeURIComponent(foreground)}\`;
			const fontSizeWithUnits = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-font-size');
			if (fontSizeWithUnits && fontSizeWithUnits.endsWith('px')) {
				url += \`&fontSize=\${encodeURIComponent(parseFloat(fontSizeWithUnits))}\`;
			}
			if (devToolsFrame.src !== url)
				devToolsFrame.src = url;
			break;
		case "keydown":
			// https://github.com/flutter/devtools/issues/2775
			window.dispatchEvent(new KeyboardEvent('keydown', message.data));
			break;
		case "launchUrl":
			vscode.postMessage({command: 'launchUrl', data: message.data});
			break;
	}
});
`;
const scriptNonce = Buffer.from(pageScript).toString("base64");
const frameCss = "position: absolute; top: 0; left: 0; width: 100%; height: 100%";
const cssNonce = Buffer.from(frameCss).toString("base64");
class DevToolsEmbeddedView {
    constructor(session, devToolsUri, page) {
        this.session = session;
        this.devToolsUri = devToolsUri;
        this.page = page;
        this.onDisposeEmitter = new events_1.EventEmitter();
        this.onDispose = this.onDisposeEmitter.event;
        const column = (0, utils_1.firstNonEditorColumn)() || vs.ViewColumn.Beside;
        this.panel = vs.window.createWebviewPanel("dartDevTools", page.title, column, {
            enableScripts: true,
            localResourceRoots: [],
            retainContextWhenHidden: true,
        });
        this.panel.onDidDispose(() => this.dispose(true));
        this.panel.webview.html = `
			<html>
			<head>
			<meta http-equiv="Content-Security-Policy" content="default-src 'self' 'nonce-${scriptNonce}' 'nonce-${cssNonce}' http://${devToolsUri.authority};">
			<script nonce="${scriptNonce}">${pageScript}</script>
			<style nonce="${cssNonce}">#devToolsFrame { ${frameCss} }</style>
			</head>
			<body><iframe id="devToolsFrame" src="about:blank" frameborder="0"></iframe></body>
			</html>
			`;
        this.messageDisposable = this.panel.webview.onDidReceiveMessage((message) => __awaiter(this, void 0, void 0, function* () {
            if (message.command === "launchUrl") {
                yield utils_1.envUtils.openInBrowser(message.data.url);
            }
        }));
    }
    load(session, uri) {
        this.session = session;
        this.panel.webview.postMessage({ command: "setUrl", url: uri.toString() });
        this.panel.reveal();
    }
    dispose(panelDisposed = false) {
        if (!panelDisposed)
            this.panel.dispose();
        this.onDisposeEmitter.fire();
        this.messageDisposable.dispose();
    }
}
exports.DevToolsEmbeddedView = DevToolsEmbeddedView;


/***/ }),

/***/ 34:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DevToolsManager = void 0;
const fs = __webpack_require__(7147);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const vscode_2 = __webpack_require__(7068);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const processes_1 = __webpack_require__(5837);
const stdio_service_1 = __webpack_require__(3058);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(4411);
const utils_2 = __webpack_require__(7220);
const debug_1 = __webpack_require__(4635);
const config_1 = __webpack_require__(4165);
const processes_2 = __webpack_require__(5430);
const embedded_view_1 = __webpack_require__(8397);
const devtoolsPackageID = "devtools";
const devtoolsPackageName = "Dart DevTools";
// This starts off undefined, which means we'll read from config.devToolsPort and fall back to undefined (use default).
// Once we get a port we'll update this variable so that if we restart (eg. a silent extension restart due to
// SDK change or similar) we will try to use the same port, so if the user has browser windows open they're
// still valid.
let portToBind;
/// Handles launching DevTools in the browser and managing the underlying service.
class DevToolsManager {
    constructor(logger, workspaceContext, debugCommands, analytics, pubGlobal, dartCapabilities, flutterCapabilities, flutterDaemon) {
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.debugCommands = debugCommands;
        this.analytics = analytics;
        this.pubGlobal = pubGlobal;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.flutterDaemon = flutterDaemon;
        this.disposables = [];
        this.devToolsStatusBarItem = vs.window.createStatusBarItem("dartStatusDevTools", vs.StatusBarAlignment.Right, 100);
        this.devToolsEmbeddedViews = {};
        this.devToolsStatusBarItem.name = "Dart/Flutter DevTools";
        this.disposables.push(this.devToolsStatusBarItem);
        this.handleEagerActivationAndStartup(workspaceContext);
    }
    get devToolsActivation() { return this.devToolsActivationPromise; }
    handleEagerActivationAndStartup(workspaceContext) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = workspaceContext.config) === null || _a === void 0 ? void 0 : _a.startDevToolsServerEagerly) {
                try {
                    if ((_b = workspaceContext.config) === null || _b === void 0 ? void 0 : _b.startDevToolsServerEagerly) {
                        yield this.spawnIfRequired(true);
                    }
                }
                catch (e) {
                    this.logger.error("Failed to background start DevTools");
                    this.logger.error(e);
                    vs.window.showErrorMessage(`Failed to start DevTools: ${e}`);
                }
            }
        });
    }
    preActivate(silent) {
        return __awaiter(this, void 0, void 0, function* () {
            this.devToolsActivationPromise = this.pubGlobal.backgroundActivate(devtoolsPackageName, devtoolsPackageID, silent);
            yield this.devToolsActivationPromise;
        });
    }
    routeIdForPage(page) {
        if (!page)
            return undefined;
        if (page.routeId)
            return page.routeId(this.flutterCapabilities.version);
        return page.id;
    }
    spawnIfRequired(silent = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // If we're mid-silent-activation, wait until that's finished.
            yield this.devToolsActivationPromise;
            if (!this.devtoolsUrl) {
                this.devToolsStatusBarItem.hide();
                // Ensure the Pub version of DevTools is installed if we're not launching from the daemon or
                // the version from the Dart SDK.
                if (!this.workspaceContext.config.startDevToolsFromDaemon && !this.dartCapabilities.supportsDartDevTools) {
                    const installedVersion = yield this.pubGlobal.installIfRequired({
                        autoUpdate: true,
                        moreInfoLink: undefined,
                        packageID: devtoolsPackageID,
                        packageName: devtoolsPackageName,
                        requiredVersion: "0.9.6",
                        silent,
                    });
                    // If install failed, we can't start.
                    if (!installedVersion) {
                        return undefined;
                    }
                }
                // Using daemon takes priority over SDK or pub.
                if (this.workspaceContext.config.startDevToolsFromDaemon) {
                    if (!this.flutterDaemon) {
                        throw new Error("Flutter daemon is undefined");
                    }
                    const result = yield this.flutterDaemon.serveDevTools();
                    this.devtoolsUrl = new Promise((resolve, reject) => {
                        if (result.host && result.port) {
                            resolve(`http://${result.host}:${result.port}/`);
                        }
                        else {
                            reject("Unable to serve DevTools");
                        }
                    });
                }
                else if (silent) {
                    this.devtoolsUrl = this.startServer();
                }
                else {
                    this.devtoolsUrl = vs.window.withProgress({
                        location: vs.ProgressLocation.Notification,
                        title: "Starting Dart DevTools...",
                    }, () => __awaiter(this, void 0, void 0, function* () { return this.startServer(); }));
                }
            }
            const url = yield this.devtoolsUrl;
            this.devToolsStatusBarItem.text = "Dart DevTools";
            this.devToolsStatusBarItem.tooltip = `DevTools is running at ${url}`;
            this.devToolsStatusBarItem.command = "dart.openDevTools";
            this.devToolsStatusBarItem.show();
            return url;
        });
    }
    /// Spawns DevTools and returns the full URL to open without a debug session.
    spawnForNoSession() {
        return __awaiter(this, void 0, void 0, function* () {
            this.analytics.logDebuggerOpenDevTools();
            const url = yield this.spawnIfRequired();
            if (!url)
                return;
            try {
                utils_2.envUtils.openInBrowser(url.toString(), this.logger);
            }
            catch (e) {
                this.showError(e);
            }
        });
    }
    /// Spawns DevTools and returns the full URL to open for that session
    ///   eg. http://127.0.0.1:8123/?port=8543
    spawnForSession(session, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.analytics.logDebuggerOpenDevTools();
            const url = yield this.spawnIfRequired();
            if (!url)
                return;
            if (options.embed === undefined)
                options.embed = config_1.config.embedDevTools && vscode_2.vsCodeVersion.supportsEmbeddedDevTools;
            if (options.reuseWindows === undefined)
                options.reuseWindows = config_1.config.devToolsReuseWindows;
            // When we're running embedded and were asked to open without a page, we should prompt for a page (plus give an option
            // to open non-embedded view).
            if (options.embed && !options.page) {
                const choice = options.page === null ? "EXTERNAL" : yield this.promptForDevToolsPage();
                if (!choice) // User cancelled
                    return;
                else if (choice === "EXTERNAL")
                    options.embed = false;
                else
                    options.page = choice.page;
            }
            try {
                yield vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                    title: "Opening DevTools...",
                }, () => __awaiter(this, void 0, void 0, function* () {
                    const canLaunchDevToolsThroughService = utils_2.isRunningLocally
                        && !options.embed
                        && !process.env.DART_CODE_IS_TEST_RUN
                        && config_1.config.devToolsBrowser === "chrome"
                        && (yield (0, promises_1.waitFor)(() => this.debugCommands.vmServices.serviceIsRegistered(enums_1.VmService.LaunchDevTools), 500));
                    yield this.launch(!!canLaunchDevToolsThroughService, session, options);
                }));
                return { url, dispose: () => this.dispose() };
            }
            catch (e) {
                this.showError(e);
            }
        });
    }
    promptForDevToolsPage() {
        return __awaiter(this, void 0, void 0, function* () {
            const choices = [
                ...constants_1.devToolsPages.map((page) => ({
                    label: `Open ${page.title} Page`,
                    page,
                })),
                { label: `Open DevTools in Web Browser`, isExternal: true },
            ];
            const choice = yield vs.window.showQuickPick(choices, { placeHolder: "Which DevTools page?" });
            if (!choice)
                return undefined;
            else if (choice.isExternal)
                return "EXTERNAL";
            else if (choice.page)
                return { page: choice.page };
            else
                return undefined; // Shouldn't get here...
        });
    }
    showError(e) {
        this.logger.error(e);
        vs.window.showErrorMessage(`${e}`);
    }
    /// When a new Debug session starts, we can reconnect any views that are still open
    // in the disconnected state.
    reconnectDisconnectedEmbeddedViews(session) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.devtoolsUrl)
                return;
            for (const pageId of Object.keys(this.devToolsEmbeddedViews)) {
                const page = constants_1.devToolsPages.find((p) => p.id === pageId);
                const panels = this.devToolsEmbeddedViews[pageId];
                if (!panels)
                    continue;
                // If there are disconnected panels for this page, trigger a launch
                // of the page to reuse it.
                const reusablePanel = panels.find((p) => p.session.hasEnded);
                if (reusablePanel) {
                    reusablePanel.session = session;
                    yield this.launch(false, session, { embed: true, page });
                }
            }
        });
    }
    launch(allowLaunchThroughService, session, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this.devtoolsUrl;
            if (!url) {
                this.showError(`DevTools URL not available`);
                return;
            }
            const queryParams = {
                hide: "debugger",
                ide: "VSCode",
                inspectorRef: options.inspectorRef,
                theme: config_1.config.useDevToolsDarkTheme && !options.embed ? "dark" : undefined,
            };
            // Try to launch via service if allowed.
            if (allowLaunchThroughService && (yield this.launchThroughService(session, Object.assign(Object.assign({}, options), { queryParams, page: this.routeIdForPage(options.page) }))))
                return true;
            // Otherwise, fall back to embedded or launching manually.
            if (options.page)
                queryParams.page = this.routeIdForPage(options.page);
            if (options.embed)
                queryParams.embed = "true";
            const fullUrl = yield this.buildDevToolsUrl(queryParams, session, url);
            if (options.embed) {
                const exposedUri = vs.Uri.parse(yield utils_2.envUtils.exposeUrl(fullUrl));
                // TODO: What should we do if we don't have a page?
                this.launchInEmbeddedWebView(exposedUri, session, (_a = options.page) !== null && _a !== void 0 ? _a : constants_1.devToolsPages[0]);
            }
            else {
                yield utils_2.envUtils.openInBrowser(fullUrl.toString(), this.logger);
            }
        });
    }
    buildDevToolsUrl(queryParams, session, url) {
        return __awaiter(this, void 0, void 0, function* () {
            const paramsString = Object.keys(queryParams)
                .filter((key) => queryParams[key] !== undefined)
                .map((key) => { var _a; return `${encodeURIComponent(key)}=${encodeURIComponent((_a = queryParams[key]) !== null && _a !== void 0 ? _a : "")}`; })
                .join("&");
            const vmServiceUri = vs.Uri.parse(session.vmServiceUri);
            const exposedUrl = yield utils_2.envUtils.exposeUrl(vmServiceUri, this.logger);
            return vs.Uri.parse(`${url}?${paramsString}&uri=${encodeURIComponent(exposedUrl)}`);
        });
    }
    launchInEmbeddedWebView(uri, session, page) {
        var _a, _b;
        const pageId = page.id;
        if (!this.devToolsEmbeddedViews[pageId]) {
            this.devToolsEmbeddedViews[pageId] = [];
        }
        // Look through any open DevTools frames for this page, to see if any are already our session, or
        // are for a session that has been stopped.
        let frame = (_a = this.devToolsEmbeddedViews[pageId]) === null || _a === void 0 ? void 0 : _a.find((dtev) => dtev.session === session || dtev.session.hasEnded);
        if (!frame) {
            frame = new embedded_view_1.DevToolsEmbeddedView(session, uri, page);
            frame.onDispose.listen(() => delete this.devToolsEmbeddedViews[pageId]);
            (_b = this.devToolsEmbeddedViews[pageId]) === null || _b === void 0 ? void 0 : _b.push(frame);
        }
        frame === null || frame === void 0 ? void 0 : frame.load(session, uri);
    }
    launchThroughService(session, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield session.session.customRequest("callService", {
                    method: this.debugCommands.vmServices.getServiceMethodName(enums_1.VmService.LaunchDevTools),
                    params,
                });
                return true;
            }
            catch (e) {
                this.logger.error(`DevTools failed to launch Chrome, will launch default browser locally instead: ${e.message}`);
                vs.window.showWarningMessage(`Dart DevTools was unable to launch Chrome so your default browser was launched instead.`, "Show Full Error").then((res) => {
                    if (res) {
                        const fileName = `bug-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`;
                        const tempPath = path.join(os.tmpdir(), fileName);
                        fs.writeFileSync(tempPath, e.message || e);
                        vscode_1.workspace.openTextDocument(tempPath).then((document) => {
                            vscode_1.window.showTextDocument(document);
                        });
                    }
                });
                return false;
            }
        });
    }
    /// Starts the devtools server and returns the URL of the running app.
    startServer(hasReinstalled = false) {
        return new Promise((resolve, reject) => {
            var _a;
            if (this.service) {
                try {
                    this.service.dispose();
                    this.service = undefined;
                    this.devtoolsUrl = undefined;
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
            this.service = new DevToolsService(this.logger, this.workspaceContext, this.dartCapabilities);
            const service = this.service;
            this.disposables.push(service);
            service.registerForServerStarted((n) => {
                // When a new debug session starts, we need to wait for its VM
                // Service, then register it with this server.
                this.disposables.push(this.debugCommands.onDebugSessionVmServiceAvailable((session) => __awaiter(this, void 0, void 0, function* () {
                    if (session.vmServiceUri) {
                        service.vmRegister({ uri: session.vmServiceUri });
                        // Also reconnect any orphaned DevTools views.
                        yield this.reconnectDisconnectedEmbeddedViews(session);
                    }
                })));
                // And send any existing sessions we have.
                for (const session of debug_1.debugSessions) {
                    if (session.vmServiceUri)
                        service.vmRegister({ uri: session.vmServiceUri });
                }
                portToBind = n.port;
                resolve(`http://${n.host}:${n.port}/`);
            });
            (_a = service.process) === null || _a === void 0 ? void 0 : _a.on("close", (code) => __awaiter(this, void 0, void 0, function* () {
                this.devtoolsUrl = undefined;
                this.devToolsStatusBarItem.hide();
                if (code && code !== 0) {
                    // Reset the port to 0 on error in case it was from us trying to reuse the previous port.
                    portToBind = 0;
                    const errorMessage = `${devtoolsPackageName} exited with code ${code}.`;
                    this.logger.error(errorMessage);
                    // If we haven't tried reinstalling, prompt to retry.
                    if (!hasReinstalled) {
                        const resp = yield vs.window.showErrorMessage(`${errorMessage} Would you like to try reactivating DevTools?`, constants_1.reactivateDevToolsAction, constants_1.skipAction);
                        if (resp === constants_1.reactivateDevToolsAction) {
                            try {
                                yield this.preActivate(false);
                                resolve(yield this.startServer(true));
                            }
                            catch (e) {
                                reject(e);
                            }
                            return;
                        }
                    }
                    reject(errorMessage);
                }
            }));
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DevToolsManager = DevToolsManager;
/// Handles running the DevTools process (via pub, or dart).
///
/// This is not used for internal workspaces (see startDevToolsFromDaemon).
class DevToolsService extends stdio_service_1.StdIOService {
    constructor(logger, workspaceContext, dartCapabilities) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.General), config_1.config.maxLogLineLength);
        this.serverStartedSubscriptions = [];
        const devToolsArgs = ["--machine", "--try-ports", "10", "--allow-embedding"];
        const executionInfo = dartCapabilities.supportsDartDevTools
            ? { executable: path.join(workspaceContext.sdks.dart, constants_1.dartVMPath), args: ["devtools"] }
            : (0, processes_1.getPubExecutionInfo)(dartCapabilities, workspaceContext.sdks.dart, ["global", "run", "devtools"]);
        const binPath = executionInfo.executable;
        const binArgs = [...executionInfo.args, ...devToolsArgs];
        // Store the port we'll use for later so we can re-bind to the same port if we restart.
        portToBind = config_1.config.devToolsPort // Always config first
            || portToBind; // Then try the last port we bound this session
        if (portToBind) {
            binArgs.push("--port");
            binArgs.push(portToBind.toString());
        }
        this.registerForServerStarted((n) => this.additionalPidsToTerminate.push(n.pid));
        this.createProcess(undefined, binPath, binArgs, { toolEnv: (0, processes_2.getToolEnv)() });
    }
    shouldHandleMessage(message) {
        return message.startsWith("{") && message.endsWith("}");
    }
    // TODO: Remove this if we fix the DevTools server (and rev min version) to not use method for
    // the server.started event.
    isNotification(msg) { return msg.event || msg.method === "server.started"; }
    handleNotification(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.method || evt.event) {
                case "server.started":
                    yield this.notify(this.serverStartedSubscriptions, evt.params);
                    break;
            }
        });
    }
    registerForServerStarted(subscriber) {
        return this.subscribe(this.serverStartedSubscriptions, subscriber);
    }
    vmRegister(request) {
        return this.sendRequest("vm.register", request);
    }
}


/***/ }),

/***/ 3546:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initializeFlutterSdk = void 0;
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const channels = __webpack_require__(1026);
const extension_1 = __webpack_require__(1892);
const utils_1 = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
function initializeFlutterSdk(logger, flutterScript) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.info(`Flutter is not initialized, running 'flutter doctor' to force...`);
        try {
            yield vscode_1.window.withProgress({
                location: vscode_1.ProgressLocation.Notification,
                title: constants_1.initializingFlutterMessage,
            }, (progress, cancellationToken) => __awaiter(this, void 0, void 0, function* () {
                const proc = (0, processes_1.safeToolSpawn)(undefined, flutterScript, ["doctor", "-v"]);
                // Show the output in an output channel so if it gets stuck the user can see it.
                const channel = channels.getOutputChannel(`flutter doctor`);
                channel.show();
                channels.runProcessInOutputChannel(proc, channel);
                cancellationToken.onCancellationRequested((e) => {
                    logger.info(`User canceled!`);
                    proc.kill();
                });
                // Log this to general as it's startup stuff that can't be captured with
                // Capture Logs so log it to the main log file.
                (0, logging_1.logProcess)(logger, enums_1.LogCategory.General, proc);
                return new Promise((resolve, reject) => proc.on("exit", (code) => {
                    if (code) {
                        const ringLogContents = extension_1.ringLog.toString();
                        logger.error(`Failed to initialize Flutter: Process exited with code ${code}.`);
                        vscode_1.window.showErrorMessage(`Failed to initialize Flutter: Process exited with code ${code}.`, constants_1.showLogAction).then((chosenAction) => {
                            if (chosenAction === constants_1.showLogAction)
                                (0, utils_1.openLogContents)(undefined, ringLogContents);
                        });
                        reject();
                    }
                    else {
                        channel.hide();
                        resolve();
                    }
                }));
            }));
            logger.info(`Flutter initialized!`);
        }
        catch (e) {
            logger.warn(`Flutter initialization failed, proceeding without!`);
        }
    });
}
exports.initializeFlutterSdk = initializeFlutterSdk;


/***/ }),

/***/ 8137:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFlutterSnippets = void 0;
const fs = __webpack_require__(7147);
const https = __webpack_require__(5687);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const fs_1 = __webpack_require__(300);
const processes_1 = __webpack_require__(5430);
function getFlutterSnippets(logger, sdks, capabilities) {
    if (capabilities.supportsFlutterCreateListSamples)
        return getFlutterSnippetsFromSdk(logger, sdks);
    return getFlutterSnippetsFromWeb();
}
exports.getFlutterSnippets = getFlutterSnippets;
function getFlutterSnippetsFromSdk(logger, sdks) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!sdks.flutter)
            throw new Error("Flutter SDK not available");
        const binPath = path.join(sdks.flutter, constants_1.flutterPath);
        const fileName = `flutter-samples-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`;
        const tempPath = path.join(os.tmpdir(), fileName);
        try {
            const res = yield (0, processes_1.runToolProcess)(logger, undefined, binPath, ["create", "--list-samples", tempPath]);
            if (res.exitCode !== 0)
                throw new Error(`Failed to get Flutter samples from SDK (${res.exitCode})\n\n${res.stderr}\n\n${res.stdout}`);
            const json = fs.readFileSync(tempPath, { encoding: "utf8" });
            return JSON.parse(json);
        }
        finally {
            (0, fs_1.tryDeleteFile)(tempPath);
        }
    });
}
function getFlutterSnippetsFromWeb() {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: "api.flutter.dev",
            method: "GET",
            path: "/snippets/index.json",
            port: 443,
        };
        const req = https.request(options, (resp) => {
            if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                reject({ message: `Failed to get Flutter samples ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
            }
            else {
                const chunks = [];
                resp.on("data", (b) => chunks.push(b.toString()));
                resp.on("end", () => {
                    const json = chunks.join("");
                    resolve(JSON.parse(json));
                });
            }
        });
        req.end();
    });
}


/***/ }),

/***/ 3570:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterSdkManager = exports.DartSdkManager = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
class SdkManager {
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
    }
    changeSdk() {
        if (this.sdkPaths)
            this.searchForSdks(this.sdkPaths).catch((e) => console.error(e));
        else
            vs.window.showWarningMessage("Set `${configName}` to enable fast SDK switching.");
    }
    searchForSdks(sdkPaths) {
        return __awaiter(this, void 0, void 0, function* () {
            let allPaths = [];
            for (const sdkPath of sdkPaths.filter(fs.existsSync)) {
                allPaths.push(sdkPath);
                // Add immediate children to support folders-of-SDKs.
                allPaths = allPaths.concat(yield (0, fs_1.getChildFolders)(this.logger, sdkPath));
            }
            // Add in the current path if it's not there.
            if (this.currentSdk && allPaths.indexOf(this.currentSdk) === -1)
                allPaths.push(this.currentSdk);
            const sdkFolders = allPaths
                // We don't need to check isDirectory, since existsSync() will just return false
                // if we join a filename on the end of another.
                // .filter((f) => fs.statSync(f).isDirectory()) // Only directories.
                .filter((f) => fs.existsSync(path.join(f, this.executablePath))); // Only those that look like SDKs.
            const sdkItems = sdkFolders.map((f) => {
                // Resolve synlinks so we look in correct folder for version file.
                const actualBinary = fs.realpathSync(path.join(f, this.executablePath));
                // Then we need to take the executable name and /bin back off
                const actualFolder = path.dirname(path.dirname(actualBinary));
                const version = (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: actualFolder });
                return {
                    description: f === this.currentSdk && this.configuredSdk ? "Current setting" : "",
                    detail: f,
                    folder: f,
                    label: version ? this.getLabel(version) : "Unknown version",
                    version,
                };
            })
                .sort((a, b) => (0, utils_1.versionIsAtLeast)(a.version || "0.0.0", b.version || "0.0.0") ? 1 : -1);
            if (sdkItems.length === 0)
                return;
            const items = [{
                    description: !this.configuredSdk ? "Current setting" : "",
                    detail: !this.configuredSdk ? `Found at ${this.currentSdk}` : undefined,
                    folder: undefined,
                    label: "Auto-detect SDK location",
                    version: undefined,
                }].concat(sdkItems);
            vs.window.showQuickPick(items, { placeHolder: "Select an SDK to use" })
                .then((sdk) => { if (sdk)
                this.setSdk(sdk.folder); });
        });
    }
}
class DartSdkManager extends SdkManager {
    get sdkPaths() { return config_1.config.sdkPaths; }
    get currentSdk() { return this.sdks.dart; }
    get configuredSdk() { return config_1.config.sdkPath; }
    get configName() { return "dart.sdkPaths"; }
    get executablePath() { return constants_1.dartVMPath; }
    getLabel(version) {
        return `Dart SDK ${version}`;
    }
    setSdk(folder) { config_1.config.setSdkPath(folder); }
}
exports.DartSdkManager = DartSdkManager;
class FlutterSdkManager extends SdkManager {
    get sdkPaths() { return config_1.config.flutterSdkPaths; }
    get currentSdk() { return this.sdks.flutter; }
    get configuredSdk() { return config_1.config.flutterSdkPath; }
    get configName() { return "dart.flutterSdkPaths"; }
    get executablePath() { return constants_1.flutterPath; }
    getLabel(version) {
        return `Flutter SDK ${version}`;
    }
    setSdk(folder) { config_1.config.setFlutterSdkPath(folder); }
}
exports.FlutterSdkManager = FlutterSdkManager;


/***/ }),

/***/ 9032:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBarVersionTracker = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const config_1 = __webpack_require__(4165);
const utils_2 = __webpack_require__(8779);
class StatusBarVersionTracker {
    constructor(workspaceContext, isLsp) {
        this.subscriptions = [];
        const dartIsFromFlutter = workspaceContext.sdks.dartSdkIsFromFlutter;
        // Which switcher we show is based on whether we're in a Flutter project or not.
        const switchSdkCommand = workspaceContext.hasAnyFlutterProjects
            ? (config_1.config.flutterSdkPaths && config_1.config.flutterSdkPaths.length > 0 ? "dart.changeFlutterSdk" : undefined)
            : (config_1.config.sdkPaths && config_1.config.sdkPaths.length > 0 ? "dart.changeSdk" : undefined);
        // Render an approprite label for what we're calling this SDK.
        const label = workspaceContext.hasAnyFlutterProjects
            ? "Flutter"
            : (dartIsFromFlutter ? "Dart from Flutter" : "Dart");
        let versionLabel = (workspaceContext.hasAnyFlutterProjects || dartIsFromFlutter)
            ? workspaceContext.sdks.flutterVersion
            : workspaceContext.sdks.dartVersion;
        if (versionLabel === constants_1.MAX_VERSION)
            versionLabel = "latest";
        if (versionLabel) {
            this.addStatusBarItem(`${label}: ` + (versionLabel.length > 20 ? versionLabel.substr(0, 17) + "" : versionLabel), `${label} SDK (${isLsp ? "LSP" : "DAS"}): ${versionLabel}`, switchSdkCommand);
        }
    }
    addStatusBarItem(text, tooltip, command) {
        const statusBarItem = vs.window.createStatusBarItem("dartStatusSdkVersion", vs.StatusBarAlignment.Right, 2);
        statusBarItem.name = "Dart/Flutter SDK Version";
        statusBarItem.text = text;
        statusBarItem.tooltip = tooltip;
        statusBarItem.command = command;
        this.subscriptions.push(statusBarItem);
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => {
            // Show the Dart-specific label if the document is analyzable but it isn't HTML.
            if (e && e.document && (0, utils_2.isAnalyzable)(e.document) && e.document.languageId !== "html")
                statusBarItem.show();
            else
                statusBarItem.hide();
        }));
        if (vs.window.activeTextEditor && vs.window.activeTextEditor.document && (0, utils_2.isAnalyzable)(vs.window.activeTextEditor.document))
            statusBarItem.show();
    }
    dispose() {
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.StatusBarVersionTracker = StatusBarVersionTracker;


/***/ }),

/***/ 8949:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkForStandardDartSdkUpdates = void 0;
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const utils_3 = __webpack_require__(8779);
function checkForStandardDartSdkUpdates(logger, workspaceContext) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!config_1.config.checkForSdkUpdates || workspaceContext.config.disableSdkUpdateChecks)
            return;
        // Sometimes people use the Dart SDK inside Flutter for non-Flutter projects. Since that SDK is
        // versioned with Flutter, it never makes sense to prompt the user to update the Dart SDK.
        if (workspaceContext.sdks.dartSdkIsFromFlutter)
            return;
        const dartSdkVersion = workspaceContext.sdks.dartVersion;
        try {
            const version = yield (0, utils_3.getLatestSdkVersion)();
            if (!dartSdkVersion || (0, utils_1.versionIsAtLeast)(dartSdkVersion, version))
                return;
            const goToDownloadsAction = "Go to Dart Downloads";
            const dontShowAgainAction = "Disable Update Checks";
            const message = `Version ${version} of the Dart SDK is available (you have ${dartSdkVersion}). Some features of Dart Code may not work correctly with an old SDK.`;
            const action = yield vscode_1.window.showWarningMessage(message, goToDownloadsAction, dontShowAgainAction);
            if (action === goToDownloadsAction)
                yield utils_2.envUtils.openInBrowser(constants_1.DART_DOWNLOAD_URL);
            else if (action === dontShowAgainAction)
                config_1.config.setCheckForSdkUpdates(false);
        }
        catch (e) {
            logger.error(e);
        }
    });
}
exports.checkForStandardDartSdkUpdates = checkForStandardDartSdkUpdates;


/***/ }),

/***/ 8461:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasDartAnalysisServer = exports.referencesBuildRunner = exports.referencesFlutterSdk = exports.SdkUtils = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const logging_1 = __webpack_require__(8323);
const package_map_1 = __webpack_require__(143);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(4411);
const workspace_1 = __webpack_require__(2479);
const utils_2 = __webpack_require__(7220);
const workspace_2 = __webpack_require__(2329);
const config_1 = __webpack_require__(4165);
const extension_1 = __webpack_require__(1892);
const utils_3 = __webpack_require__(8779);
const flutter_1 = __webpack_require__(3546);
// TODO: Tidy this class up (it exists mainly to share logger).
class SdkUtils {
    constructor(logger) {
        this.logger = logger;
        this.hasShownActivationFailure = false;
    }
    handleMissingSdks(context, analytics, workspaceContext) {
        // Note: This code only runs if we fail to find the Dart SDK, or fail to find the Flutter SDK
        // and are in a Flutter project. In the case where we fail to find the Flutter SDK but are not
        // in a Flutter project (eg. we ran Flutter Doctor without the extension activated) then
        // this code will not be run as the extension will activate normally, and then the command-handling
        // code for each command will detect the missing Flutter SDK and respond appropriately.
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.createProject", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "flutter.createProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("dart.createProject", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, false, "dart.createProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("_dart.flutter.createSampleProject", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "_dart.flutter.createSampleProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.doctor", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "flutter.doctor");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.upgrade", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "flutter.upgrade");
        }));
        // Wait a while before showing the error to allow the code above to have run if it will.
        setTimeout(() => {
            // Only show the "startup" message if we didn't already show another message as
            // a result of one of the above commands beinv invoked.
            if (!this.hasShownActivationFailure) {
                if (workspaceContext.hasAnyFlutterProjects) {
                    this.showRelevantActivationFailureMessage(analytics, workspaceContext, true);
                }
                else if (workspaceContext.hasAnyStandardDartProjects) {
                    this.showRelevantActivationFailureMessage(analytics, workspaceContext, false);
                }
                else {
                    this.logger.error("No Dart or Flutter SDK was found. Suppressing prompt because it doesn't appear that a Dart/Flutter project is open.");
                }
            }
        }, 500);
        return;
    }
    showRelevantActivationFailureMessage(analytics, workspaceContext, isFlutter, commandToReRun) {
        if (isFlutter && workspaceContext.sdks.flutter && !workspaceContext.sdks.dart) {
            this.showFluttersDartSdkActivationFailure();
        }
        else if (isFlutter) {
            this.showFlutterActivationFailure(commandToReRun);
        }
        else {
            this.showDartActivationFailure(commandToReRun);
        }
        if (!this.hasShownActivationFailure) {
            analytics.logSdkDetectionFailure();
            this.hasShownActivationFailure = true;
        }
    }
    showFluttersDartSdkActivationFailure() {
        // tslint:disable-next-line: no-floating-promises
        (0, utils_3.promptToReloadExtension)("Could not find Dart in your Flutter SDK. " +
            "Please run 'flutter doctor' in the terminal then reload the project once all issues are resolved.", "Reload", // eslint-disable-line @typescript-eslint/indent
        true);
    }
    showFlutterActivationFailure(commandToReRun) {
        // tslint:disable-next-line: no-floating-promises
        this.showSdkActivationFailure("Flutter", (p) => this.findFlutterSdk(p), constants_1.FLUTTER_DOWNLOAD_URL, (p) => config_1.config.setGlobalFlutterSdkPath(p), commandToReRun);
    }
    showDartActivationFailure(commandToReRun) {
        // tslint:disable-next-line: no-floating-promises
        this.showSdkActivationFailure("Dart", (p) => this.findDartSdk(p), constants_1.DART_DOWNLOAD_URL, (p) => config_1.config.setGlobalDartSdkPath(p), commandToReRun);
    }
    showSdkActivationFailure(sdkType, search, downloadUrl, saveSdkPath, commandToReRun) {
        return __awaiter(this, void 0, void 0, function* () {
            const locateAction = "Locate SDK";
            const downloadAction = "Download SDK";
            let displayMessage = `Could not find a ${sdkType} SDK. ` +
                `Please ensure ${sdkType.toLowerCase()} is installed and in your PATH (you may need to restart).`;
            while (true) {
                const ringLogContents = extension_1.ringLog.toString();
                const selectedItem = yield vscode_1.window.showErrorMessage(displayMessage, locateAction, downloadAction, constants_1.showLogAction);
                // TODO: Refactor/reformat/comment this code - it's messy and hard to understand!
                if (selectedItem === locateAction) {
                    const selectedFolders = yield vscode_1.window.showOpenDialog({ canSelectFolders: true, openLabel: `Set ${sdkType} SDK folder` });
                    if (selectedFolders && selectedFolders.length > 0) {
                        const matchingSdkFolder = search(selectedFolders.map((f) => (0, fs_1.fsPath)(f)));
                        if (matchingSdkFolder.sdkPath) {
                            yield saveSdkPath(matchingSdkFolder.sdkPath);
                            yield (0, utils_3.promptToReloadExtension)();
                            if (commandToReRun) {
                                vscode_1.commands.executeCommand(commandToReRun);
                            }
                            break;
                        }
                        else {
                            displayMessage = `That folder does not appear to be a ${sdkType} SDK.`;
                        }
                    }
                }
                else if (selectedItem === downloadAction) {
                    yield utils_2.envUtils.openInBrowser(downloadUrl);
                    break;
                }
                else if (selectedItem === constants_1.showLogAction) {
                    (0, utils_3.openLogContents)(undefined, ringLogContents);
                    break;
                }
                else {
                    break;
                }
            }
        });
    }
    scanWorkspace() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info("Searching for SDKs...");
            const pathOverride = process.env.DART_PATH_OVERRIDE || "";
            const normalPath = process.env.PATH || "";
            const paths = (pathOverride + path.delimiter + normalPath).split(path.delimiter).filter((p) => p);
            this.logger.info("Environment PATH:");
            for (const p of paths)
                this.logger.info(`    ${p}`);
            // If we are running the analyzer remotely over SSH, we only support an analyzer, since none
            // of the other SDKs will work remotely. Also, there is no need to validate the sdk path,
            // since that file will exist on a remote machine.
            if (config_1.config.analyzerSshHost) {
                return new workspace_2.WorkspaceContext({
                    dart: config_1.config.sdkPath,
                    dartSdkIsFromFlutter: false,
                    flutter: undefined,
                }, {}, false, false, false, false);
            }
            // TODO: This has gotten very messy and needs tidying up...
            let firstFlutterMobileProject;
            let hasAnyFlutterProject = false;
            let hasAnyFlutterMobileProject = false;
            let hasAnyWebProject = false;
            let hasAnyStandardDartProject = false;
            const possibleProjects = yield (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders);
            // Scan through them all to figure out what type of projects we have.
            for (const folder of possibleProjects) {
                const hasPubspecFile = (0, fs_1.hasPubspec)(folder);
                const refsFlutter = hasPubspecFile && referencesFlutterSdk(folder);
                const refsWeb = false; // hasPubspecFile && referencesWeb(folder);
                const hasFlutterCreateProjectTriggerFile = fs.existsSync(path.join(folder, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE));
                // Special case to detect the Flutter repo root, so we always consider it a Flutter project and will use the local SDK
                const isFlutterRepo = fs.existsSync(path.join(folder, "bin/flutter")) && fs.existsSync(path.join(folder, "bin/cache/dart-sdk"));
                // Since we just blocked on a lot of sync FS, yield.
                yield promises_1.resolvedPromise;
                const isSomethingFlutter = refsFlutter || hasFlutterCreateProjectTriggerFile || isFlutterRepo;
                if (isSomethingFlutter) {
                    this.logger.info(`Found Flutter project at ${folder}:
			Mobile? ${refsFlutter}
			Web? ${refsWeb}
			Create Trigger? ${hasFlutterCreateProjectTriggerFile}
			Flutter Repo? ${isFlutterRepo}`);
                }
                // Track the first Flutter Project so we can try finding the Flutter SDK from its packages file.
                firstFlutterMobileProject = firstFlutterMobileProject || (isSomethingFlutter ? folder : undefined);
                // Set some flags we'll use to construct the workspace, so we know what things we need to light up.
                hasAnyFlutterProject = hasAnyFlutterProject || isSomethingFlutter;
                hasAnyFlutterMobileProject = hasAnyFlutterMobileProject || refsFlutter || hasFlutterCreateProjectTriggerFile;
                hasAnyWebProject = hasAnyWebProject || refsWeb;
                hasAnyStandardDartProject = hasAnyStandardDartProject || (!isSomethingFlutter && hasPubspecFile);
            }
            // Certain types of workspaces will have special config, so read them here.
            const workspaceConfig = {};
            // Helper that searches for a specific folder/file up the tree and
            // runs some specific processing.
            const workspaceFolders = (0, utils_2.getDartWorkspaceFolders)();
            const topLevelFolders = workspaceFolders.map((w) => (0, fs_1.fsPath)(w.uri));
            const processWorkspaceType = (search, process) => __awaiter(this, void 0, void 0, function* () {
                for (const folder of topLevelFolders) {
                    const root = yield search(this.logger, folder);
                    if (root) {
                        process(this.logger, workspaceConfig, root);
                        return root;
                    }
                }
                return undefined;
            });
            yield processWorkspaceType(findGitRoot, workspace_1.processKnownGitRepositories);
            // TODO: Remove this lambda when the preview flag is removed.
            yield processWorkspaceType(findBazelWorkspaceRoot, (l, c, b) => (0, workspace_1.processBazelWorkspace)(l, c, b, config_1.config.previewBazelWorkspaceCustomScripts));
            const fuchsiaRoot = yield processWorkspaceType(findFuchsiaRoot, workspace_1.processFuchsiaWorkspace);
            if (fuchsiaRoot) {
                this.logger.info(`Found Fuchsia root at ${fuchsiaRoot}`);
                if (hasAnyStandardDartProject)
                    this.logger.info(`Found Fuchsia project that is not vanilla Flutter`);
            }
            let flutterSdkPath;
            if (workspaceConfig.forceFlutterWorkspace) {
                hasAnyFlutterProject = true;
                hasAnyFlutterMobileProject = true;
                flutterSdkPath = workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.flutterSdkHome;
            }
            else {
                const flutterSdkSearchPaths = [
                    config_1.config.flutterSdkPath,
                    // TODO: These could move into processFuchsiaWorkspace and be set on the config?
                    fuchsiaRoot && path.join(fuchsiaRoot, "lib/flutter"),
                    fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart-pkg/git/flutter"),
                    firstFlutterMobileProject,
                    firstFlutterMobileProject && extractFlutterSdkPathFromPackagesFile(firstFlutterMobileProject),
                    firstFlutterMobileProject && path.join(firstFlutterMobileProject, ".flutter"),
                    firstFlutterMobileProject && path.join(firstFlutterMobileProject, "vendor/flutter"),
                    process.env.FLUTTER_ROOT,
                    constants_1.isLinux ? "~/snap/flutter/common/flutter" : undefined,
                    "~/flutter-sdk",
                    "/google/flutter",
                ].concat(paths).filter(utils_1.notUndefined);
                let flutterSdkResult = this.findFlutterSdk(flutterSdkSearchPaths);
                // Handle the case where the Flutter snap has not been initialised.
                if (!flutterSdkResult.sdkPath && flutterSdkResult.candidatePaths.includes(constants_1.snapBinaryPath)) {
                    // Trigger initialization.
                    this.logger.info(`No Flutter SDK found, but a 'flutter' binary did point at ${constants_1.snapBinaryPath} so attempting to initialize...`);
                    yield (0, flutter_1.initializeFlutterSdk)(this.logger, constants_1.snapFlutterBinaryPath);
                    // Then search again.
                    this.logger.info(`Snap initialization completed, searching for Flutter SDK again...`);
                    flutterSdkResult = this.findFlutterSdk(flutterSdkSearchPaths);
                }
                flutterSdkPath = flutterSdkResult.sdkPath;
            }
            // Since we just blocked on a lot of sync FS, yield.
            yield promises_1.resolvedPromise;
            // If we're a Flutter workspace but we couldn't get the version, try running Flutter to initialise it first.
            // Do this before searching for the Dart SDK, as it might download the Dart SDK we'd like to find.
            let hasAttemptedFlutterInitialization = false;
            if (hasAnyFlutterProject && flutterSdkPath && !workspaceConfig.skipFlutterInitialization) {
                const flutterVersion = (_a = workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.flutterVersion) !== null && _a !== void 0 ? _a : (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: flutterSdkPath });
                const flutterNeedsInitializing = !flutterVersion
                    || !fs.existsSync(path.join(flutterSdkPath, "bin/cache/dart-sdk"));
                if (flutterNeedsInitializing) {
                    hasAttemptedFlutterInitialization = true;
                    yield (0, flutter_1.initializeFlutterSdk)(this.logger, path.join(flutterSdkPath, constants_1.flutterPath));
                }
            }
            const dartSdkSearchPaths = [
                // TODO: These could move into processFuchsiaWorkspace and be set on the config?
                fuchsiaRoot && path.join(fuchsiaRoot, "topaz/tools/prebuilt-dart-sdk", `${constants_1.dartPlatformName}-x64`),
                fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart/tools/sdks/dart-sdk"),
                fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart/tools/sdks", constants_1.dartPlatformName, "dart-sdk"),
                fuchsiaRoot && path.join(fuchsiaRoot, "dart/tools/sdks", constants_1.dartPlatformName, "dart-sdk"),
                firstFlutterMobileProject && flutterSdkPath && path.join(flutterSdkPath, "bin/cache/dart-sdk"),
                config_1.config.sdkPath,
            ].concat(paths)
                // The above array only has the Flutter SDK	in the search path if we KNOW it's a flutter
                // project, however this doesn't cover the activating-to-run-flutter.createProject so
                // we need to always look in the flutter SDK, but only AFTER the users PATH so that
                // we don't prioritise it over any real Dart versions.
                .concat([flutterSdkPath && path.join(flutterSdkPath, "bin/cache/dart-sdk")])
                .filter(utils_1.notUndefined);
            // Since we just blocked on a lot of sync FS, yield.
            yield promises_1.resolvedPromise;
            let dartSdkPath = this.findDartSdk(dartSdkSearchPaths).sdkPath;
            // Since we just blocked on a lot of sync FS, yield.
            yield promises_1.resolvedPromise;
            // If we still don't have a Dart SDK, but we do have a Flutter SDK and we did not already try to initialize, then
            // try again here. This could happen if we were not in a Flutter project (so didn't try to initialize before) but
            // still need a Dart SDK (for example, we were activated by running Flutter: New Project in an empty workspace.. we
            // wouldn't trigger the code above).
            if (!hasAttemptedFlutterInitialization && flutterSdkPath && !dartSdkPath) {
                yield (0, flutter_1.initializeFlutterSdk)(this.logger, path.join(flutterSdkPath, constants_1.flutterPath));
                dartSdkPath = this.findDartSdk([path.join(flutterSdkPath, "bin/cache/dart-sdk")]).sdkPath;
            }
            return new workspace_2.WorkspaceContext({
                dart: dartSdkPath,
                dartSdkIsFromFlutter: !!dartSdkPath && (0, utils_1.isDartSdkFromFlutter)(dartSdkPath),
                dartVersion: (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: dartSdkPath }),
                flutter: flutterSdkPath,
                flutterVersion: (_b = workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.flutterVersion) !== null && _b !== void 0 ? _b : (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: flutterSdkPath }),
            }, workspaceConfig, hasAnyFlutterMobileProject, hasAnyWebProject, hasAnyStandardDartProject, !!fuchsiaRoot && hasAnyStandardDartProject);
        });
    }
    findDartSdk(folders) {
        return this.searchPaths(folders, constants_1.executableNames.dart, (p) => this.hasExecutable(p, constants_1.dartVMPath) && (0, exports.hasDartAnalysisServer)(p));
    }
    findFlutterSdk(folders) {
        return this.searchPaths(folders, constants_1.executableNames.flutter, (p) => this.hasExecutable(p, constants_1.flutterPath));
    }
    hasExecutable(folder, executablePath) {
        const fullPath = path.join(folder, executablePath);
        return fs.existsSync(fullPath) && fs.statSync(fullPath).isFile();
    }
    searchPaths(paths, executableFilename, postFilter) {
        this.logger.info(`Searching for ${executableFilename}`);
        let sdkPaths = paths
            .filter((p) => p)
            .map(utils_3.resolvePaths)
            .filter(utils_1.notUndefined);
        // Any that don't end with bin, add it on (as an extra path) since some of our
        // paths may come from places that don't already include it (for ex. the
        // user config.sdkPath).
        const isBinFolder = (f) => ["bin", "sbin"].indexOf(path.basename(f)) !== -1;
        sdkPaths = (0, utils_1.flatMap)(sdkPaths, (p) => isBinFolder(p) ? [p] : [p, path.join(p, "bin")]);
        // Add on the executable name, as we need to do filtering based on the resolve path.
        // TODO: Make the list unique, but preserve the order of the first occurrences. We currently
        // have uniq() and unique(), so also consolidate them.
        this.logger.info(`    Looking for ${executableFilename} in:`);
        for (const p of sdkPaths)
            this.logger.info(`        ${p}`);
        // Restrict only to the paths that have the executable.
        sdkPaths = sdkPaths.filter((p) => fs.existsSync(path.join(p, executableFilename)));
        this.logger.info(`    Found at:`);
        for (const p of sdkPaths)
            this.logger.info(`        ${p}`);
        // Convert all the paths to their resolved locations.
        sdkPaths = sdkPaths.map((p) => {
            const fullPath = path.join(p, executableFilename);
            // In order to handle symlinks on the binary (not folder), we need to add the executableName before calling realpath.
            const realExecutableLocation = p && fs.realpathSync(fullPath);
            if (realExecutableLocation.toLowerCase() !== fullPath.toLowerCase())
                this.logger.info(`Following symlink: ${fullPath} ==> ${realExecutableLocation}`);
            // If the symlink resolves to the Snap binary, it's not a real SDK
            // and we should return as-is rather than walk up two levels, as we
            // may want to use the presence of this to trigger initialisation.
            if (realExecutableLocation === constants_1.snapBinaryPath) {
                return constants_1.snapBinaryPath;
            }
            // Then we need to take the executable name and /bin back off
            return path.dirname(path.dirname(realExecutableLocation));
        });
        // Now apply any post-filters.
        this.logger.info("    Candidate paths to be post-filtered:");
        for (const p of sdkPaths)
            this.logger.info(`        ${p}`);
        const sdkPath = sdkPaths.find(postFilter || (() => true));
        if (sdkPath)
            this.logger.info(`    Found at ${sdkPath}`);
        this.logger.info(`    Returning SDK path ${sdkPath} for ${executableFilename}`);
        return { sdkPath, candidatePaths: sdkPaths };
    }
}
exports.SdkUtils = SdkUtils;
function referencesFlutterSdk(folder) {
    if (folder && (0, fs_1.hasPubspec)(folder)) {
        const regex = new RegExp("sdk\\s*:\\s*flutter", "i");
        return regex.test(fs.readFileSync(path.join(folder, "pubspec.yaml")).toString());
    }
    return false;
}
exports.referencesFlutterSdk = referencesFlutterSdk;
function referencesBuildRunner(folder) {
    if (folder && (0, fs_1.hasPubspec)(folder)) {
        const regex = new RegExp("build_runner\\s*:", "i");
        return regex.test(fs.readFileSync(path.join(folder, "pubspec.yaml")).toString());
    }
    return false;
}
exports.referencesBuildRunner = referencesBuildRunner;
function extractFlutterSdkPathFromPackagesFile(projectFolder) {
    if (!fs.existsSync(projectFolder))
        return undefined;
    let packagePath = package_map_1.PackageMap.loadForProject(logging_1.nullLogger, projectFolder).getPackagePath("flutter");
    if (!packagePath)
        return undefined;
    // Set windows slashes to / while manipulating.
    if (constants_1.isWin) {
        packagePath = packagePath.replace(/\\/g, "/");
    }
    // Make sure ends with a slash.
    if (!packagePath.endsWith("/"))
        packagePath = packagePath + "/";
    // Trim suffix we don't need.
    const pathSuffix = "/packages/flutter/lib/";
    if (packagePath.endsWith(pathSuffix)) {
        packagePath = packagePath.substr(0, packagePath.length - pathSuffix.length);
    }
    // Make sure ends with a slash.
    if (!packagePath.endsWith("/"))
        packagePath = packagePath + "/";
    // Append bin if required.
    if (!packagePath.endsWith("/bin/")) {
        packagePath = packagePath + "bin/";
    }
    // Set windows paths back.
    if (constants_1.isWin) {
        packagePath = packagePath.replace(/\//g, "\\");
        if (packagePath.startsWith("\\"))
            packagePath = packagePath.substring(1);
    }
    return packagePath;
}
function findFuchsiaRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return findRootContaining(folder, ".jiri_root");
    });
}
function findBazelWorkspaceRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return findRootContaining(folder, "WORKSPACE", true);
    });
}
function findGitRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return findRootContaining(folder, ".git");
    });
}
function findRootContaining(folder, childName, expectFile = false) {
    if (folder) {
        // Walk up the directories from the workspace root, and see if there
        // exists a directory which has `childName` file/directory as a child.
        let child = folder;
        while (child) {
            try {
                const stat = fs.statSync(path.join(child, childName));
                if (expectFile ? stat.isFile() : stat.isDirectory()) {
                    return child;
                }
            }
            catch (_a) { }
            const parentDir = path.dirname(child);
            if (child === parentDir)
                break;
            child = parentDir;
        }
    }
    return undefined;
}
const hasDartAnalysisServer = (folder) => fs.existsSync(path.join(folder, constants_1.analyzerSnapshotPath));
exports.hasDartAnalysisServer = hasDartAnalysisServer;


/***/ }),

/***/ 6355:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartTerminalLinkProvider = void 0;
const vs = __webpack_require__(9496);
const package_map_1 = __webpack_require__(143);
const utils_1 = __webpack_require__(7220);
const utils_2 = __webpack_require__(8779);
const packageUriPattern = new RegExp("(?<uri>package:\\S+[\\/]\\S+\\.dart)(?:[: ](?<line>\\d+):(?<col>\\d+))?", "mg");
class DartTerminalLinkProvider {
    constructor(logger, context) {
        this.logger = logger;
        this.context = context;
        context.events.onPackageMapChange.listen(() => {
            this.packageMaps = undefined;
            this.packageMapDiscovery = undefined;
        });
    }
    discoverPackageMaps() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.packageMapDiscovery) {
                return this.packageMapDiscovery;
            }
            this.packageMapDiscovery = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const projectFolders = yield (0, utils_1.getAllProjectFolders)(this.logger, utils_2.getExcludedFolders, { requirePubspec: true });
                this.packageMaps = {};
                for (const projectFolder of projectFolders) {
                    this.packageMaps[projectFolder] = package_map_1.PackageMap.loadForProject(this.logger, projectFolder);
                }
                resolve();
            }));
            return this.packageMapDiscovery;
        });
    }
    isKnownPackage(packageName) {
        return this.packageMaps && !!Object.values(this.packageMaps).find((m) => m.packages[packageName]);
    }
    resolvePackageUri(uri) {
        if (!this.packageMaps)
            return undefined;
        for (const packageMap of Object.values(this.packageMaps)) {
            const filePath = packageMap.resolvePackageUri(uri);
            if (filePath)
                return filePath;
        }
        return undefined;
    }
    provideTerminalLinks(context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.packageMaps)
                yield this.discoverPackageMaps();
            const results = [];
            packageUriPattern.lastIndex = -1;
            let result;
            // tslint:disable-next-line: no-conditional-assignment
            while ((result = packageUriPattern.exec(context.line)) && result.groups) {
                let uri;
                try {
                    uri = vs.Uri.parse(result.groups.uri, true);
                }
                catch (e) {
                    this.logger.error(e);
                    continue;
                }
                if (!uri)
                    continue;
                const packageName = uri.path.split("/")[0];
                if (!this.isKnownPackage(packageName))
                    continue;
                const line = result.groups.line ? parseInt(result.groups.line) : undefined;
                const col = result.groups.col ? parseInt(result.groups.col) : undefined;
                const startIndex = result.index;
                // TODO: This should be "result[0].length" but including the line/col can cause
                // the tooltip not to render correctly, so we only highlight the uri for now.
                // https://github.com/microsoft/vscode/issues/108301
                const length = result.groups.uri.length;
                results.push({
                    col,
                    length,
                    line,
                    packageName,
                    startIndex,
                    tooltip: "Open file in editor",
                    uri: result.groups.uri,
                });
            }
            return results;
        });
    }
    handleTerminalLink(link) {
        const filePath = this.resolvePackageUri(link.uri);
        if (!filePath) {
            vs.window.showErrorMessage(`Unable to find root for package ${link.packageName}`);
            return;
        }
        vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.file(filePath), link.line, link.col);
    }
}
exports.DartTerminalLinkProvider = DartTerminalLinkProvider;


/***/ }),

/***/ 2601:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VsCodeTestController = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const enums_1 = __webpack_require__(7341);
const test_model_1 = __webpack_require__(1159);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
class VsCodeTestController {
    constructor(logger, model, discoverer) {
        this.logger = logger;
        this.model = model;
        this.discoverer = discoverer;
        this.disposables = [];
        this.itemForNode = new WeakMap();
        this.nodeForItem = new WeakMap();
        this.testRuns = {};
        const controller = vs.tests.createTestController("dart", "Dart & Flutter");
        this.controller = controller;
        this.disposables.push(controller);
        this.disposables.push(model.onDidChangeTreeData.listen((node) => this.onDidChangeTreeData(node)));
        this.disposables.push(vs.debug.onDidTerminateDebugSession((e) => this.handleDebugSessionEnd(e)));
        model.addTestEventListener(this);
        if (discoverer)
            controller.resolveHandler = (item) => this.resolveTestItem(item);
        controller.createRunProfile("Run", vs.TestRunProfileKind.Run, (request, token) => {
            this.runTests(false, request, token);
        });
        controller.createRunProfile("Debug", vs.TestRunProfileKind.Debug, (request, token) => {
            this.runTests(true, request, token);
        });
    }
    resolveTestItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.discoverer)
                return;
            if (!item) {
                this.discoverer.beginTestDiscovery();
                return;
            }
            const node = this.nodeForItem.get(item);
            if (node instanceof test_model_1.SuiteNode)
                yield this.discoverer.discoverTestsForSuite(node);
        });
    }
    registerTestRun(dartCodeDebugSessionID, run, shouldEndWithSession) {
        this.testRuns[dartCodeDebugSessionID] = { run, shouldEndWithSession };
    }
    handleDebugSessionEnd(e) {
        const run = this.testRuns[e.configuration.dartCodeDebugSessionID];
        if (run === null || run === void 0 ? void 0 : run.shouldEndWithSession)
            run.run.end();
    }
    getLatestData(test) {
        return this.nodeForItem.get(test);
    }
    runTests(debug, request, token) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const testsToRun = new Set();
            ((_a = request.include) !== null && _a !== void 0 ? _a : this.controller.items).forEach((item) => testsToRun.add(item));
            (_b = request.exclude) === null || _b === void 0 ? void 0 : _b.forEach((item) => testsToRun.delete(item));
            // For each item in the set, remove any of its descendants because they will be run by the parent.
            function removeWithDescendants(item) {
                testsToRun.delete(item);
                item.children.forEach((child) => removeWithDescendants(child));
            }
            const all = [...testsToRun];
            all.forEach((item) => item.children.forEach((child) => removeWithDescendants(child)));
            const run = this.controller.createTestRun(request);
            try {
                // As an optimisation, if we're no-debug and running complete files (eg. all included or excluded items are
                // suites), we can run the "fast path" in a single `dart test` invocation.
                if (!debug && [...testsToRun].every((item) => this.nodeForItem.get(item) instanceof test_model_1.SuiteNode)) {
                    yield vs.commands.executeCommand("_dart.runAllTestsWithoutDebugging", [...testsToRun].map((item) => this.nodeForItem.get(item)), run);
                    return;
                }
                // Group into suites since we need to run each seperately (although we can run
                // multiple tests witthin one suite together).
                const testsBySuite = new Map();
                testsToRun.forEach((test) => {
                    var _a;
                    const node = this.nodeForItem.get(test);
                    if (!node)
                        return;
                    const testNodes = (_a = testsBySuite.get(node.suiteData)) !== null && _a !== void 0 ? _a : [];
                    testsBySuite.set(node.suiteData, testNodes);
                    testNodes.push(node);
                });
                for (const suite of testsBySuite.keys()) {
                    const nodes = testsBySuite.get(suite);
                    if (!nodes)
                        continue;
                    const command = debug
                        ? "_dart.startDebuggingTestsFromVsTestController"
                        : "_dart.startWithoutDebuggingTestsFromVsTestController";
                    yield vs.commands.executeCommand(command, suite, nodes, true, run);
                }
            }
            finally {
                run.end();
            }
        });
    }
    /// Replace the whole tree.
    replaceAll() {
        const suiteTestItems = Object.values(this.model.suites)
            .map((suite) => this.createOrUpdateNode(suite.node))
            .filter(utils_1.notUndefined);
        this.controller.items.replace(suiteTestItems);
    }
    onDidChangeTreeData(node) {
        if (node === undefined) {
            this.replaceAll();
            return;
        }
        this.createOrUpdateNode(node);
    }
    /// Creates a node (including its children), or if it already exists, updates it
    /// and its children.
    /// Does not add the item to its parent, so that the calling code can .replace()
    /// all children if required.
    ///
    /// Returns undefined if in the case of an error or a node that should
    /// not be shown in the tree.
    createOrUpdateNode(node) {
        var _a, _b;
        if (!this.shouldShowNode(node))
            return;
        let collection;
        if (node instanceof test_model_1.SuiteNode) {
            collection = this.controller.items;
        }
        else {
            collection = (_a = this.itemForNode.get(node.parent)) === null || _a === void 0 ? void 0 : _a.children;
        }
        if (!collection) {
            this.logger.error(`Failed to find parent (${(_b = node.parent) === null || _b === void 0 ? void 0 : _b.label}) of node (${node.label})`);
            return;
        }
        let existingItem = collection.get(this.idForNode(node));
        // Create new item if required.
        if (!existingItem) {
            const newItem = this.createTestItem(node);
            existingItem = newItem;
        }
        else {
            // Otherwise, update this item to match the latest state.
            this.updateFields(existingItem, node);
        }
        // For new suites without chilren, set canResolveChildren because we can
        // open the file and discover tests from the Outline if the user expands them.
        if (node instanceof test_model_1.SuiteNode && node.children.length === 0)
            existingItem.canResolveChildren = true;
        existingItem.children.replace(node.children.map((c) => this.createOrUpdateNode(c)).filter(utils_1.notUndefined));
        return existingItem;
    }
    shouldShowNode(node) {
        if (config_1.config.showSkippedTests)
            return true;
        if (node instanceof test_model_1.TestNode && node.children.length === 0) {
            // Simple test node.
            // Show only if not skipped.
            return node.status !== enums_1.TestStatus.Skipped;
        }
        else if (node instanceof test_model_1.TestNode) {
            // Dynamic test node with children.
            // Show only if any child not skipped.
            return !!node.children.find((c) => c.status !== enums_1.TestStatus.Skipped);
        }
        else if (node instanceof test_model_1.GroupNode) {
            // Show only if status is not exactly skipped.
            return node.statuses.size !== 1 || !node.statuses.has(enums_1.TestStatus.Skipped);
        }
        else {
            // Otherwise show eg. suites are always shown.
            return true;
        }
    }
    idForNode(node) {
        return node instanceof test_model_1.GroupNode || node instanceof test_model_1.TestNode
            ? `${node.suiteData.path}:${node.name}`
            : node.suiteData.path;
    }
    cleanLabel(label) {
        return label.trim().split("\n").map((l) => l.trim()).join(" ");
    }
    labelForSuite(node) {
        const suitePath = node.suiteData.path;
        const wf = vs.workspace.getWorkspaceFolder(vs.Uri.file(suitePath));
        return wf
            ? path.relative((0, fs_1.fsPath)(wf.uri), node.suiteData.path)
            : path.basename(suitePath);
    }
    createTestItem(node) {
        var _a;
        const id = this.idForNode(node);
        const label = node instanceof test_model_1.SuiteNode
            ? this.labelForSuite(node)
            : this.cleanLabel((_a = node.label) !== null && _a !== void 0 ? _a : "<unnamed>");
        const uri = vs.Uri.file(node.suiteData.path);
        const item = this.controller.createTestItem(id, label, uri);
        this.updateFields(item, node);
        this.nodeForItem.set(item, node);
        this.itemForNode.set(node, item);
        item.children.replace(node.children.map((c) => this.createTestItem(c)));
        return item;
    }
    updateFields(item, node) {
        item.description = node.description;
        if ((node instanceof test_model_1.GroupNode || node instanceof test_model_1.TestNode) && node.range) {
            item.range = new vs.Range(new vs.Position(node.range.start.line, node.range.start.character), new vs.Position(node.range.end.line, node.range.end.character));
        }
    }
    getOrCreateTestRun(sessionID) {
        var _a;
        let run = (_a = this.testRuns[sessionID]) === null || _a === void 0 ? void 0 : _a.run;
        if (!run) {
            run = this.controller.createTestRun(new vs.TestRunRequest(), undefined, true);
            this.registerTestRun(sessionID, run, true);
        }
        return run;
    }
    suiteDiscovered(sessionID, node) {
        // const run = this.getOrCreateTestRun(sessionID);
        // const item = this.itemForNode.get(node);
    }
    groupDiscovered(sessionID, node) {
        // const run = this.getOrCreateTestRun(sessionID);
        // const item = this.itemForNode.get(node);
    }
    testDiscovered(sessionID, node) {
        // const run = this.getOrCreateTestRun(sessionID);
        // const item = this.itemForNode.get(node);
    }
    testStarted(sessionID, node) {
        this.testDiscovered(sessionID, node);
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item)
            run.started(item);
    }
    testOutput(sessionID, node, message) {
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item)
            this.appendTestOutputLines(run, item, message);
    }
    testErrorOutput(sessionID, node, message, isFailure, stack) {
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item) {
            // TODO: isFailure??
            this.appendTestOutputLines(run, item, message);
            this.appendTestOutputLines(run, item, stack);
        }
    }
    appendTestOutputLines(run, item, message) {
        // Multi-line text doesn't show up correctly so split up
        // https://github.com/microsoft/vscode/issues/136036
        // run.appendOutput(`${formatForTerminal(message)}\r\n`, undefined, item);
        message.split("\n").forEach((line) => {
            run.appendOutput(line, undefined, item);
        });
    }
    testDone(sessionID, node, result) {
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item) {
            switch (result) {
                case "skipped":
                    run.skipped(item);
                    break;
                case "success":
                    run.passed(item, node.duration);
                    break;
                default:
                    const errors = node.outputEvents.map((e) => this.formatError(e)).filter(utils_1.notUndefined);
                    const errorString = errors.join("\n");
                    if (result === "failure")
                        run.failed(item, new vs.TestMessage(errorString), node.duration);
                    else
                        run.errored(item, new vs.TestMessage(errorString), node.duration);
                    break;
            }
        }
    }
    suiteDone(sessionID, node) { }
    formatError(error) {
        var _a, _b;
        if (!("error" in error))
            return;
        return [
            (_a = error.error) !== null && _a !== void 0 ? _a : "",
            (_b = error.stackTrace) !== null && _b !== void 0 ? _b : "",
        ].join("\n").trim();
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.VsCodeTestController = VsCodeTestController;


/***/ }),

/***/ 4741:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleNewProjects = exports.showUserPrompts = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const fs_1 = __webpack_require__(300);
const extension_utils_1 = __webpack_require__(6143);
const user_prompts_1 = __webpack_require__(7622);
const utils_1 = __webpack_require__(7220);
const sdk_1 = __webpack_require__(997);
const utils_2 = __webpack_require__(8779);
function showUserPrompts(logger, context, webClient, workspaceContext) {
    return __awaiter(this, void 0, void 0, function* () {
        function shouldSuppress(key) {
            const stateKey = `${constants_1.userPromptContextPrefix}${key}`;
            return context.get(stateKey) === true;
        }
        /// Shows a prompt and stores the return value. Prompt should return `true` to mark
        /// this extension as seen-forever and it won't be shown again. Returning anything
        /// else will allow the prompt to appear again next time.
        function showPrompt(key, prompt) {
            const stateKey = `${constants_1.userPromptContextPrefix}${key}`;
            prompt().then((res) => context.update(stateKey, res), error);
        }
        if (workspaceContext.hasAnyFlutterProjects && !extension_utils_1.hasFlutterExtension && !shouldSuppress(constants_1.installFlutterExtensionPromptKey)) {
            // It's possible that we got here when the user installed the Flutter extension, because it causes Dart to install
            // first and activate. So, before showing this prompt we'll wait 30 seconds and then check if we still don't
            // have the Flutter extension, and then show the prompt.
            yield new Promise((resolve) => setTimeout(resolve, 20000));
            if (!(0, extension_utils_1.checkHasFlutterExtension)())
                return showPrompt(constants_1.installFlutterExtensionPromptKey, promptToInstallFlutterExtension);
        }
        // Check the user hasn't installed Flutter in a forbidden location that will cause issues.
        if (workspaceContext.hasAnyFlutterProjects && workspaceContext.sdks.flutter) {
            if (constants_1.isWin) {
                const forbiddenLocations = [
                    process.env.COMMONPROGRAMFILES,
                    process.env["COMMONPROGRAMFILES(x86)"],
                    process.env.CommonProgramW6432,
                    process.env.PROGRAMFILES,
                    process.env.ProgramW6432,
                    process.env["PROGRAMFILES(X86)"],
                ];
                const installedForbiddenLocation = forbiddenLocations.find((fl) => { var _a; return fl && ((_a = workspaceContext.sdks.flutter) === null || _a === void 0 ? void 0 : _a.toLowerCase().startsWith(fl.toLowerCase())); });
                if (installedForbiddenLocation) {
                    logger.error(`Flutter is installed in protected folder: ${installedForbiddenLocation}`);
                    vs.window.showErrorMessage("The Flutter SDK is installed in a protected folder and may not function correctly. Please move the SDK to a location that is user-writable without Administration permissions and restart.");
                }
            }
        }
        const lastSeenVersionNotification = context.lastSeenVersion;
        if (!lastSeenVersionNotification) {
            // If we've not got a stored version, this is the first install, so just
            // stash the current version and don't show anything.
            context.lastSeenVersion = extension_utils_1.extensionVersion;
        }
        else if (!extension_utils_1.isDevExtension && lastSeenVersionNotification !== extension_utils_1.extensionVersion) {
            const versionLink = extension_utils_1.extensionVersion.split(".").slice(0, 2).join(".").replace(".", "-");
            // tslint:disable-next-line: no-floating-promises
            promptToShowReleaseNotes(extension_utils_1.extensionVersion, versionLink).then(() => context.lastSeenVersion = extension_utils_1.extensionVersion);
            return;
        }
        if (workspaceContext.hasAnyFlutterProjects) {
            if (yield (0, user_prompts_1.showFlutterSurveyNotificationIfAppropriate)(context, webClient, utils_1.envUtils.openInBrowser, Date.now(), logger))
                return; // Bail if we showed it, so we won't show any other notifications.
        }
        if (!shouldSuppress(constants_1.useRecommendedSettingsPromptKey)) {
            showPrompt(constants_1.useRecommendedSettingsPromptKey, promptToUseRecommendedSettings);
            return;
        }
        // (though, there are no other notifications right now...)
    });
}
exports.showUserPrompts = showUserPrompts;
function promptToUseRecommendedSettings() {
    return __awaiter(this, void 0, void 0, function* () {
        const action = yield vs.window.showInformationMessage("Would you like to use recommended VS Code settings for Dart & Flutter?", constants_1.yesAction, constants_1.noAction, constants_1.showRecommendedSettingsAction);
        if (action === constants_1.yesAction) {
            yield vs.commands.executeCommand("dart.writeRecommendedSettings");
        }
        else if (action === constants_1.showRecommendedSettingsAction) {
            yield utils_1.envUtils.openInBrowser(constants_1.recommendedSettingsUrl);
        }
        return true;
    });
}
function promptToInstallFlutterExtension() {
    return __awaiter(this, void 0, void 0, function* () {
        const installExtension = "Install Flutter Extension";
        const res = yield vs.window.showInformationMessage("The Flutter extension is required to work with Flutter projects.", installExtension);
        if (res === installExtension) {
            yield vs.window.withProgress({ location: vs.ProgressLocation.Notification }, (progress) => {
                progress.report({ message: "Installing Flutter extension" });
                return new Promise((resolve) => {
                    vs.extensions.onDidChange((e) => resolve());
                    vs.commands.executeCommand("workbench.extensions.installExtension", constants_1.flutterExtensionIdentifier);
                });
            });
            // tslint:disable-next-line: no-floating-promises
            (0, utils_2.promptToReloadExtension)();
        }
        return false;
    });
}
function promptToShowReleaseNotes(versionDisplay, versionLink) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield vs.window.showInformationMessage(`Dart Code has been updated to v${versionDisplay}`, `Show Release Notes`);
        if (res) {
            yield utils_1.envUtils.openInBrowser(`https://dartcode.org/releases/v${versionLink}/`);
        }
        return true; // Always mark this as done; we don't want to prompt the user multiple times.
    });
}
function error(err) {
    vs.window.showErrorMessage(err.message);
}
function handleNewProjects(logger, context) {
    return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all((0, utils_1.getDartWorkspaceFolders)().map((wf) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield handleStagehandTrigger(logger, wf, constants_1.DART_CREATE_PROJECT_TRIGGER_FILE);
                yield handleFlutterCreateTrigger(wf);
            }
            catch (e) {
                logger.error("Failed to create project");
                logger.error(e);
                vs.window.showErrorMessage("Failed to create project");
            }
        })));
    });
}
exports.handleNewProjects = handleNewProjects;
function handleStagehandTrigger(logger, wf, triggerFilename) {
    return __awaiter(this, void 0, void 0, function* () {
        const triggerFile = path.join((0, fs_1.fsPath)(wf.uri), triggerFilename);
        if (!fs.existsSync(triggerFile))
            return;
        const templateJson = fs.readFileSync(triggerFile).toString().trim();
        let template;
        try {
            template = JSON.parse(templateJson);
        }
        catch (e) {
            logger.error("Failed to get Stagehand templates");
            logger.error(e);
            vs.window.showErrorMessage("Failed to run Stagehand to create project");
            return;
        }
        fs.unlinkSync(triggerFile);
        logger.info(`Creating Dart project for ${(0, fs_1.fsPath)(wf.uri)}`, enums_1.LogCategory.CommandProcesses);
        try {
            (0, sdk_1.markProjectCreationStarted)();
            const success = yield createDartProject((0, fs_1.fsPath)(wf.uri), template.name);
            if (success) {
                logger.info(`Fetching packages for newly-created project`, enums_1.LogCategory.CommandProcesses);
                yield vs.commands.executeCommand("dart.getPackages", wf.uri);
                handleDartWelcome(wf, template);
                logger.info(`Finished creating new project!`, enums_1.LogCategory.CommandProcesses);
            }
            else {
                logger.info(`Failed to create new project`, enums_1.LogCategory.CommandProcesses);
            }
        }
        finally {
            (0, sdk_1.markProjectCreationEnded)();
        }
    });
}
function handleFlutterCreateTrigger(wf) {
    return __awaiter(this, void 0, void 0, function* () {
        const flutterTriggerFile = path.join((0, fs_1.fsPath)(wf.uri), constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE);
        if (!fs.existsSync(flutterTriggerFile))
            return;
        const jsonString = fs.readFileSync(flutterTriggerFile).toString().trim();
        const json = jsonString ? JSON.parse(jsonString) : undefined;
        fs.unlinkSync(flutterTriggerFile);
        try {
            (0, sdk_1.markProjectCreationStarted)();
            const success = yield createFlutterProject((0, fs_1.fsPath)(wf.uri), json);
            if (success)
                handleFlutterWelcome(wf, json);
        }
        finally {
            (0, sdk_1.markProjectCreationEnded)();
        }
    });
}
function createDartProject(projectPath, templateName) {
    return __awaiter(this, void 0, void 0, function* () {
        const code = yield vs.commands.executeCommand("_dart.create", projectPath, templateName);
        return code === 0;
    });
}
function createFlutterProject(projectPath, triggerData) {
    return __awaiter(this, void 0, void 0, function* () {
        const projectName = (triggerData === null || triggerData === void 0 ? void 0 : triggerData.sample) ? "sample" : undefined;
        const args = { projectPath, projectName, triggerData };
        const code = yield vs.commands.executeCommand("_flutter.create", args);
        return code === 0;
    });
}
function handleFlutterWelcome(workspaceFolder, triggerData) {
    const entryFile = path.join((0, fs_1.fsPath)(workspaceFolder.uri), "lib/main.dart");
    openFile(entryFile);
    if (triggerData === null || triggerData === void 0 ? void 0 : triggerData.sample)
        vs.window.showInformationMessage(`${triggerData.sample} sample ready! Connect a device and press F5 to run.`);
    else
        vs.window.showInformationMessage("Your Flutter project is ready! Connect a device and press F5 to start running.");
}
function handleDartWelcome(workspaceFolder, template) {
    const workspacePath = (0, fs_1.fsPath)(workspaceFolder.uri);
    const projectName = path.basename(workspacePath);
    const entryFile = path.join(workspacePath, template.entrypoint.replace("__projectName__", projectName));
    openFile(entryFile);
    vs.window.showInformationMessage(`${template.label} project ready!`);
}
/// Opens a file, but does it in a setTimeout to work around VS Code reveal bug
/// https://github.com/Microsoft/vscode/issues/71588#event-2252962973
function openFile(entryFile) {
    if (!fs.existsSync(entryFile))
        return;
    // TODO: Remove this setTimeout when it's no longer required.
    setTimeout(() => {
        vs.commands.executeCommand("vscode.open", vs.Uri.file(entryFile));
    }, 100);
}


/***/ }),

/***/ 8779:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExcludedFolders = exports.openLogContents = exports.logTime = exports.promptToReloadExtension = exports.escapeShell = exports.getLatestSdkVersion = exports.isValidEntryFile = exports.ensureDebugLaunchUniqueId = exports.hasTestNameFilter = exports.isInsideFolderNamed = exports.isDartFile = exports.projectShouldUsePubForTests = exports.isTestFolder = exports.isPubRunnableTestFile = exports.isTestFile = exports.isTestFileOrFolder = exports.isWithinWorkspace = exports.isAnalyzableAndInWorkspace = exports.shouldHotReloadFor = exports.isAnalyzable = exports.createFolderForFile = exports.homeRelativePath = exports.resolvePaths = exports.isFlutterProjectFolder = exports.isPathInsideFlutterProject = exports.isInsideFlutterProject = exports.isFlutterWorkspaceFolder = void 0;
const fs = __webpack_require__(7147);
const https = __webpack_require__(5687);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const extension_1 = __webpack_require__(1892);
const project_1 = __webpack_require__(3886);
const utils_2 = __webpack_require__(8461);
function isFlutterWorkspaceFolder(folder) {
    return !!(folder && (0, utils_1.isDartWorkspaceFolder)(folder) && isFlutterProjectFolder((0, fs_1.fsPath)(folder.uri)));
}
exports.isFlutterWorkspaceFolder = isFlutterWorkspaceFolder;
function isInsideFlutterProject(uri) {
    if (!uri)
        return false;
    const projectRoot = (0, project_1.locateBestProjectRoot)((0, fs_1.fsPath)(uri));
    if (projectRoot)
        return isFlutterProjectFolder(projectRoot);
    else
        return isFlutterWorkspaceFolder(vscode_1.workspace.getWorkspaceFolder(uri));
}
exports.isInsideFlutterProject = isInsideFlutterProject;
function isPathInsideFlutterProject(path) {
    const projectRoot = (0, project_1.locateBestProjectRoot)(path);
    if (!projectRoot)
        return false;
    return isFlutterProjectFolder(projectRoot);
}
exports.isPathInsideFlutterProject = isPathInsideFlutterProject;
function isFlutterProjectFolder(folder) {
    return (0, utils_2.referencesFlutterSdk)(folder);
}
exports.isFlutterProjectFolder = isFlutterProjectFolder;
function resolvePaths(p) {
    if (typeof p !== "string")
        return undefined;
    if (p.startsWith("~/"))
        return path.join(os.homedir(), p.substr(2));
    if (!path.isAbsolute(p) && vscode_1.workspace.workspaceFolders && vscode_1.workspace.workspaceFolders.length)
        return path.join((0, fs_1.fsPath)(vscode_1.workspace.workspaceFolders[0].uri), p);
    return p;
}
exports.resolvePaths = resolvePaths;
/// Shortens a path to use ~ if it's inside the home directory.
function homeRelativePath(p) {
    if (!p)
        return undefined;
    const homedir = os.homedir();
    if ((0, fs_1.isWithinPath)(p, homedir))
        return path.join("~", path.relative(homedir, p));
    return p;
}
exports.homeRelativePath = homeRelativePath;
function createFolderForFile(file) {
    try {
        if (!file || !path.isAbsolute(file))
            return undefined;
        const folder = path.dirname(file);
        if (!fs.existsSync(folder))
            (0, fs_1.mkDirRecursive)(folder);
        return file;
    }
    catch (_a) {
        console.warn(`Ignoring invalid file path ${file}`);
        return undefined;
    }
}
exports.createFolderForFile = createFolderForFile;
function isAnalyzable(file) {
    if (file.isUntitled || !(0, fs_1.fsPath)(file.uri) || file.uri.scheme !== "file")
        return false;
    const analyzableLanguages = ["dart", "html"];
    const analyzableFilenames = [".analysis_options", "analysis_options.yaml", "pubspec.yaml"];
    // We have to include dart/html extensions as this function may be called without a language ID
    // (for example when triggered by a file system watcher).
    const analyzableFileExtensions = ["dart", "htm", "html"].concat(config_1.config.additionalAnalyzerFileExtensions);
    const extName = path.extname((0, fs_1.fsPath)(file.uri));
    const extension = extName ? extName.substr(1) : undefined;
    return (file.languageId && analyzableLanguages.indexOf(file.languageId) >= 0)
        || analyzableFilenames.indexOf(path.basename((0, fs_1.fsPath)(file.uri))) >= 0
        || (extension !== undefined && analyzableFileExtensions.includes(extension));
}
exports.isAnalyzable = isAnalyzable;
function shouldHotReloadFor(file) {
    if (file.isUntitled || !(0, fs_1.fsPath)(file.uri) || file.uri.scheme !== "file")
        return false;
    const reloadableFileExtensions = ["dart", "htm", "html", "css"];
    const extName = path.extname((0, fs_1.fsPath)(file.uri));
    const extension = extName ? extName.substr(1) : undefined;
    return extension !== undefined && reloadableFileExtensions.includes(extension);
}
exports.shouldHotReloadFor = shouldHotReloadFor;
function isAnalyzableAndInWorkspace(file) {
    return isAnalyzable(file) && isWithinWorkspace((0, fs_1.fsPath)(file.uri));
}
exports.isAnalyzableAndInWorkspace = isAnalyzableAndInWorkspace;
function isWithinWorkspace(file) {
    return !!vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(file));
}
exports.isWithinWorkspace = isWithinWorkspace;
function isTestFileOrFolder(path) {
    return !!path && (isTestFile(path) || isTestFolder(path));
}
exports.isTestFileOrFolder = isTestFileOrFolder;
function isTestFile(file) {
    // To be a test, you must be _test.dart AND inside a test folder.
    // https://github.com/Dart-Code/Dart-Code/issues/1165
    // https://github.com/Dart-Code/Dart-Code/issues/2021
    // https://github.com/Dart-Code/Dart-Code/issues/2034
    return !!file && isDartFile(file)
        && (isInsideFolderNamed(file, "test")
            || isInsideFolderNamed(file, "integration_test")
            || isInsideFolderNamed(file, "test_driver")
            || config_1.config.allowTestsOutsideTestFolder)
        && file.toLowerCase().endsWith("_test.dart");
}
exports.isTestFile = isTestFile;
// Similar to isTestFile, but requires that the file is _test.dart because it will be used as
// an entry point for pub test running.
function isPubRunnableTestFile(file) {
    return !!file && isDartFile(file) && file.toLowerCase().endsWith("_test.dart");
}
exports.isPubRunnableTestFile = isPubRunnableTestFile;
function isTestFolder(path) {
    return !!path
        && (isInsideFolderNamed(path, "test")
            || isInsideFolderNamed(path, "integration_test")) && fs.existsSync(path)
        && fs.statSync(path).isDirectory();
}
exports.isTestFolder = isTestFolder;
function projectShouldUsePubForTests(folder, config) {
    return (0, fs_1.hasPubspec)(folder) && !config.useVmForTests;
}
exports.projectShouldUsePubForTests = projectShouldUsePubForTests;
function isDartFile(file) {
    return !!file && path.extname(file.toLowerCase()) === ".dart" && fs.existsSync(file) && fs.statSync(file).isFile();
}
exports.isDartFile = isDartFile;
function isInsideFolderNamed(file, folderName) {
    if (!file)
        return false;
    const ws = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(file));
    if (!ws)
        return false;
    const relPath = path.relative((0, fs_1.fsPath)(ws.uri).toLowerCase(), file.toLowerCase());
    const segments = relPath.split(path.sep);
    return segments.indexOf(folderName.toLowerCase()) !== -1;
}
exports.isInsideFolderNamed = isInsideFolderNamed;
function hasTestNameFilter(...argss) {
    for (const args of argss) {
        if (args && (args.includes("--name") || args.includes("--pname")))
            return true;
    }
    return false;
}
exports.hasTestNameFilter = hasTestNameFilter;
/// Ensures a debug config always has a unique ID we can use to match things up.
///
/// Although VS Code assigns an ID, we cannot get at it until after the debug session starts
/// which might be after we recieve some events (since VS Code fires its event late - after all
/// initialisation has completed).
function ensureDebugLaunchUniqueId(config) {
    const conf = config;
    if (!conf.dartCodeDebugSessionID) {
        const dartCodeDebugSessionID = `session-${(0, fs_1.getRandomInt)(0x10000, 0x100000).toString(16)}`;
        conf.dartCodeDebugSessionID = dartCodeDebugSessionID;
    }
    return conf.dartCodeDebugSessionID;
}
exports.ensureDebugLaunchUniqueId = ensureDebugLaunchUniqueId;
function isValidEntryFile(file) {
    var _a;
    if (!file || !isDartFile(file))
        return false;
    // When in a no-folder workspace, all Dart files are considered runnable.
    if (!((_a = vscode_1.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a.length))
        return true;
    return isTestFile(file)
        || isInsideFolderNamed(file, "bin") || isInsideFolderNamed(file, "tool") || isInsideFolderNamed(file, "test_driver")
        || file.endsWith(`lib${path.sep}main.dart`);
}
exports.isValidEntryFile = isValidEntryFile;
function getLatestSdkVersion() {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: "storage.googleapis.com",
            method: "GET",
            path: "/dart-archive/channels/stable/release/latest/VERSION",
            port: 443,
        };
        const req = https.request(options, (resp) => {
            if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                reject({ message: `Failed to get Dart SDK Version ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
            }
            else {
                resp.on("data", (d) => {
                    try {
                        const latestVersion = JSON.parse(d.toString()).version;
                        resolve(latestVersion);
                    }
                    catch (e) {
                        reject({ message: `Failed to parse latest Dart SDK Version from JSON: ${d.toString()}` });
                    }
                });
            }
        });
        req.end();
    });
}
exports.getLatestSdkVersion = getLatestSdkVersion;
// Escapes a set of command line arguments so that the escaped string is suitable for passing as an argument
// to another shell command.
// Implementation is taken from https://github.com/xxorax/node-shell-escape
function escapeShell(args) {
    const ret = [];
    args.forEach((arg) => {
        if (/[^A-Za-z0-9_\/:=-]/.test(arg)) {
            arg = "'" + arg.replace(/'/g, "'\\''") + "'";
            arg = arg.replace(/^(?:'')+/g, "") // unduplicate single-quote at the beginning
                .replace(/\\'''/g, "\\'"); // remove non-escaped single-quote if there are enclosed between 2 escaped
        }
        ret.push(arg);
    });
    return ret.join(" ");
}
exports.escapeShell = escapeShell;
function promptToReloadExtension(prompt, buttonText, offerLog) {
    return __awaiter(this, void 0, void 0, function* () {
        const restartAction = buttonText || "Reload";
        const actions = offerLog ? [restartAction, constants_1.showLogAction] : [restartAction];
        const ringLogContents = extension_1.ringLog.toString();
        let showPromptAgain = true;
        const tempLogPath = path.join(os.tmpdir(), `log-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`);
        while (showPromptAgain) {
            showPromptAgain = false;
            const chosenAction = prompt && (yield vscode_1.window.showInformationMessage(prompt, ...actions));
            if (chosenAction === constants_1.showLogAction) {
                showPromptAgain = true;
                openLogContents(undefined, ringLogContents, tempLogPath);
            }
            else if (!prompt || chosenAction === restartAction) {
                vscode_1.commands.executeCommand("_dart.reloadExtension");
            }
        }
    });
}
exports.promptToReloadExtension = promptToReloadExtension;
const shouldLogTimings = false;
const start = process.hrtime.bigint();
let last = start;
function pad(str, length) {
    while (str.length < length)
        str = "0" + str;
    return str;
}
const logTime = (taskFinished) => {
    if (!shouldLogTimings)
        return;
    const end = process.hrtime.bigint();
    console.log(`${pad((end - last).toString(), 15)} ${taskFinished ? "<== " + taskFinished : ""}`);
    last = end;
};
exports.logTime = logTime;
function openLogContents(logType = `txt`, logContents, tempPath) {
    if (!tempPath)
        tempPath = path.join(os.tmpdir(), `log-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.${logType}`);
    fs.writeFileSync(tempPath, logContents);
    vscode_1.workspace.openTextDocument(tempPath).then(vscode_1.window.showTextDocument);
}
exports.openLogContents = openLogContents;
/// Gets all excluded folders (full absolute paths) for a given workspace
/// folder based on config.
function getExcludedFolders(f) {
    if (!f)
        return [];
    const excludedForWorkspace = config_1.config.for(f.uri).analysisExcludedFolders;
    if (!excludedForWorkspace || !Array.isArray(excludedForWorkspace))
        return [];
    const workspacePath = (0, fs_1.fsPath)(f.uri);
    return excludedForWorkspace.map((folder) => {
        // Handle both relative and absolute paths.
        if (!path.isAbsolute(folder))
            folder = path.join(workspacePath, folder);
        return folder;
    });
}
exports.getExcludedFolders = getExcludedFolders;


/***/ }),

/***/ 8202:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addToLogHeader = exports.getLogHeader = exports.clearLogHeader = exports.debuggingLogCategories = exports.extensionsLogCategories = exports.analysisServerLogCategories = exports.userSelectableLogCategories = exports.getExtensionLogPath = void 0;
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
let extensionLogPath;
function getExtensionLogPath() {
    extensionLogPath = extensionLogPath || config_1.config.extensionLogFile || path.join(process.env.DC_TEST_LOGS || os.tmpdir(), `dart-code-startup-log-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`);
    return extensionLogPath;
}
exports.getExtensionLogPath = getExtensionLogPath;
exports.userSelectableLogCategories = {
    "Analysis Server": enums_1.LogCategory.Analyzer,
    "Command Processes": enums_1.LogCategory.CommandProcesses,
    "Dart Test": enums_1.LogCategory.DartTest,
    "Debugger DAP Protocol": enums_1.LogCategory.DAP,
    "Debugger VM Service": enums_1.LogCategory.VmService,
    "DevTools": enums_1.LogCategory.DevTools,
    "Flutter Device Daemon": enums_1.LogCategory.FlutterDaemon,
    "Flutter Run": enums_1.LogCategory.FlutterRun,
    "Flutter Test": enums_1.LogCategory.FlutterTest,
    "Web Daemon": enums_1.LogCategory.WebDaemon,
};
exports.analysisServerLogCategories = [
    enums_1.LogCategory.Analyzer,
    enums_1.LogCategory.CommandProcesses,
];
exports.extensionsLogCategories = [
    enums_1.LogCategory.CommandProcesses,
    enums_1.LogCategory.DevTools,
    enums_1.LogCategory.FlutterDaemon,
];
exports.debuggingLogCategories = Object.values(exports.userSelectableLogCategories)
    .filter((c) => c !== enums_1.LogCategory.Analyzer);
const logHeader = [];
function clearLogHeader() {
    logHeader.length = 0;
}
exports.clearLogHeader = clearLogHeader;
function getLogHeader() {
    if (!logHeader.length)
        return "";
    return logHeader.join(constants_1.platformEol) + constants_1.platformEol + constants_1.platformEol;
}
exports.getLogHeader = getLogHeader;
function addToLogHeader(f) {
    try {
        logHeader.push(f().replace(/\r/g, "").replace(/\n/g, "\r\n"));
    }
    catch (_a) {
        // Don't log here; we may be trying to access things that aren't available yet.
    }
}
exports.addToLogHeader = addToLogHeader;


/***/ }),

/***/ 9106:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFlutterConfigValue = exports.reportAnalyzerTerminatedWithError = void 0;
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
let isShowingAnalyzerError = false;
function reportAnalyzerTerminatedWithError(duringStartup = false) {
    if (isShowingAnalyzerError)
        return;
    isShowingAnalyzerError = true;
    const message = duringStartup
        ? "The Dart Analyzer could not be started."
        : "The Dart Analyzer has terminated.";
    // tslint:disable-next-line: no-floating-promises
    (0, utils_1.promptToReloadExtension)(message, undefined, true).then(() => isShowingAnalyzerError = false);
}
exports.reportAnalyzerTerminatedWithError = reportAnalyzerTerminatedWithError;
function getFlutterConfigValue(logger, flutterSdkPath, folder, flutterConfigKey) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!flutterSdkPath) {
            throw Error("Cannot find Android Studio without a Flutter SDK");
        }
        const binPath = path.join(flutterSdkPath, constants_1.flutterPath);
        const args = ["config", "--machine"];
        try {
            const proc = yield (0, processes_1.runToolProcess)(logger, folder, binPath, args);
            if (proc.exitCode === 0) {
                const json = JSON.parse(proc.stdout);
                return json[flutterConfigKey];
            }
            throw Error(`Failed to run "flutter config --machine" (${proc.exitCode}): ${proc.stderr}`);
        }
        catch (e) {
            logger.error(e);
            throw e;
        }
    });
}
exports.getFlutterConfigValue = getFlutterConfigValue;


/***/ }),

/***/ 5430:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runToolProcess = exports.safeToolSpawn = exports.setupToolEnv = exports.getGlobalFlutterArgs = exports.getToolEnv = void 0;
const processes_1 = __webpack_require__(5837);
// Environment used when spawning Dart and Flutter processes.
let toolEnv = /* { [key: string]: string | undefined } */ {};
let globalFlutterArgs = [];
function getToolEnv() {
    return toolEnv;
}
exports.getToolEnv = getToolEnv;
function getGlobalFlutterArgs() {
    return globalFlutterArgs;
}
exports.getGlobalFlutterArgs = getGlobalFlutterArgs;
function setupToolEnv(envOverrides) {
    toolEnv = {};
    globalFlutterArgs = [];
    toolEnv.FLUTTER_HOST = "VSCode";
    toolEnv.PUB_ENVIRONMENT = (toolEnv.PUB_ENVIRONMENT ? `${toolEnv.PUB_ENVIRONMENT}:` : "") + "vscode.dart-code";
    if (process.env.DART_CODE_IS_TEST_RUN) {
        toolEnv.PUB_ENVIRONMENT += ".test.bot";
        globalFlutterArgs.push("--suppress-analytics");
    }
    // Add on any overrides.
    if (envOverrides)
        toolEnv = Object.assign(toolEnv, envOverrides);
}
exports.setupToolEnv = setupToolEnv;
// TODO: Should we move this to extension activate?
setupToolEnv();
function safeToolSpawn(workingDirectory, binPath, args, envOverrides) {
    const env = Object.assign({}, toolEnv, envOverrides);
    return (0, processes_1.safeSpawn)(workingDirectory, binPath, args, env);
}
exports.safeToolSpawn = safeToolSpawn;
/// Runs a process and returns the exit code, stdout, stderr. Always resolves even for non-zero exit codes.
function runToolProcess(logger, workingDirectory, binPath, args, envOverrides) {
    return (0, processes_1.runProcess)(logger, binPath, args, workingDirectory, envOverrides, safeToolSpawn);
}
exports.runToolProcess = runToolProcess;


/***/ }),

/***/ 9564:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressMessage = exports.DartDebugSessionInformation = void 0;
class DartDebugSessionInformation {
    constructor(session, debuggerType) {
        this.session = session;
        this.debuggerType = debuggerType;
        this.sessionStart = new Date();
        this.hasEnded = false;
        this.progress = {};
        this.loadedServiceExtensions = [];
    }
}
exports.DartDebugSessionInformation = DartDebugSessionInformation;
class ProgressMessage {
    constructor(reporter, completer) {
        this.reporter = reporter;
        this.completer = completer;
    }
    report(message) {
        this.reporter.report({ message });
    }
    complete() {
        this.completer.resolve();
    }
}
exports.ProgressMessage = ProgressMessage;


/***/ }),

/***/ 9662:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.editSetting = exports.showSimpleSettingsEditor = exports.showInputBoxWithSettings = void 0;
const vs = __webpack_require__(9496);
function showInputBoxWithSettings(context, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const input = vs.window.createInputBox();
        input.title = options.title;
        input.prompt = options.prompt;
        input.placeholder = options.placeholder;
        input.value = options.value;
        if (options.validation) {
            input.onDidChangeValue((s) => {
                input.validationMessage = options.validation(s);
            });
        }
        input.buttons = [
            {
                iconPath: {
                    dark: vs.Uri.file(context.asAbsolutePath("media/commands/settings.svg")),
                    light: vs.Uri.file(context.asAbsolutePath("media/commands/settings.svg")),
                },
                tooltip: "Settings",
            },
        ];
        const name = yield new Promise((resolve) => {
            input.onDidTriggerButton((e) => __awaiter(this, void 0, void 0, function* () {
                resolve("SETTINGS");
                input.hide();
            }));
            input.onDidAccept(() => input.value ? resolve({ value: input.value }) : resolve(undefined));
            input.onDidHide(() => {
                resolve(undefined);
            });
            input.show();
        });
        input.dispose();
        return name;
    });
}
exports.showInputBoxWithSettings = showInputBoxWithSettings;
function showSimpleSettingsEditor(title, placeholder, items) {
    return __awaiter(this, void 0, void 0, function* () {
        while (true) {
            const quickPick = vs.window.createQuickPick();
            quickPick.title = title;
            quickPick.placeholder = placeholder;
            quickPick.items = items;
            const selectedSetting = yield new Promise((resolve) => {
                quickPick.onDidAccept(() => resolve(quickPick.selectedItems && quickPick.selectedItems[0]));
                quickPick.onDidHide(() => resolve(undefined));
                quickPick.show();
            });
            quickPick.dispose();
            if (selectedSetting) {
                yield editSetting(selectedSetting);
            }
            else {
                return;
            }
        }
    });
}
exports.showSimpleSettingsEditor = showSimpleSettingsEditor;
function editSetting(setting) {
    return __awaiter(this, void 0, void 0, function* () {
        const title = setting.label;
        const placeHolder = `Select an option for ${setting.label} (or 'Escape' to cancel)`;
        const prompt = setting.detail;
        const value = setting.currentValue;
        switch (setting.settingKind) {
            case "STRING":
                const stringResult = yield vs.window.showInputBox({ prompt, title, value });
                if (stringResult !== undefined)
                    yield setting.setValue(stringResult);
                break;
            case "ENUM":
                const enumResult = yield vs.window.showQuickPick(setting.enumValues.map((v) => ({ label: v })), { placeHolder, title });
                if (enumResult !== undefined)
                    yield setting.setValue(enumResult.label);
                break;
            case "BOOL":
                const boolResult = yield vs.window.showQuickPick([
                    { label: "enable" },
                    { label: "disable" },
                ], { placeHolder, title });
                if (boolResult !== undefined)
                    yield setting.setValue(boolResult.label === "enable");
                break;
        }
    });
}
exports.editSetting = editSetting;


/***/ }),

/***/ 7104:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findNearestOutlineNode = void 0;
function findNearestOutlineNode(fileTracker, document, position, useReducedRange = false, kinds = ["CLASS", "METHOD", "GETTER", "SETTER"]) {
    const outline = fileTracker.getOutlineFor(document.uri);
    return outline && findNode([outline], document.offsetAt(position), useReducedRange, kinds);
}
exports.findNearestOutlineNode = findNearestOutlineNode;
function findNode(outlines, offset, useReducedRange, kinds) {
    if (!outlines)
        return undefined;
    for (const outline of outlines) {
        const outlineStart = outline.offset;
        const outlineEnd = outline.offset + outline.length;
        // Bail if this node is not spanning us.
        if (outlineStart > offset || outlineEnd < offset)
            continue;
        // Although we use the full code range above so that we can walk into children, when performing a match we want to stop
        // at the end of the element, so we use a reduce range to avoid returning a method for the whole of its body.
        const isInReducedRange = !useReducedRange || !outline.element || !outline.element.location
            || (offset >= outlineStart && offset <= outline.element.location.offset + outline.element.location.length);
        return findNode(outline.children, offset, useReducedRange, kinds)
            || (kinds.indexOf(outline.element.kind) !== -1 && isInReducedRange ? outline : undefined);
    }
}


/***/ }),

/***/ 6417:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFolderToRunCommandIn = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const project_1 = __webpack_require__(3886);
const utils_3 = __webpack_require__(8779);
function getFolderToRunCommandIn(logger, placeHolder, selection, flutterOnly = false) {
    return __awaiter(this, void 0, void 0, function* () {
        // Attempt to find a project based on the supplied folder of active file.
        let file = selection && (0, fs_1.fsPath)(selection);
        file = file || (vs.window.activeTextEditor && (0, fs_1.fsPath)(vs.window.activeTextEditor.document.uri));
        const folder = file && (0, project_1.locateBestProjectRoot)(file);
        if (folder)
            return folder;
        // Otherwise look for what projects we have.
        const selectableFolders = (yield (0, utils_2.getAllProjectFolders)(logger, utils_3.getExcludedFolders, { requirePubspec: true, sort: true }))
            .filter(flutterOnly ? utils_3.isFlutterProjectFolder : () => true);
        if (!selectableFolders || !selectableFolders.length) {
            const projectTypes = flutterOnly ? "Flutter" : "Dart/Flutter";
            vs.window.showWarningMessage(`No ${projectTypes} project roots were found. Do you have a pubspec.yaml file?`);
            return undefined;
        }
        return showFolderPicker(selectableFolders, placeHolder); // TODO: What if the user didn't pick anything?
    });
}
exports.getFolderToRunCommandIn = getFolderToRunCommandIn;
function showFolderPicker(folders, placeHolder) {
    return __awaiter(this, void 0, void 0, function* () {
        // No point asking the user if there's only one.
        if (folders.length === 1) {
            return folders[0];
        }
        const items = folders.map((f) => {
            const workspaceFolder = vs.workspace.getWorkspaceFolder(vscode_1.Uri.file(f));
            if (!workspaceFolder)
                return undefined;
            const workspacePathParent = path.dirname((0, fs_1.fsPath)(workspaceFolder.uri));
            return {
                description: (0, utils_3.homeRelativePath)(workspacePathParent),
                label: path.relative(workspacePathParent, f),
                path: f,
            };
        }).filter(utils_1.notUndefined);
        const selectedFolder = yield vs.window.showQuickPick(items, { placeHolder });
        return selectedFolder && selectedFolder.path;
    });
}


/***/ }),

/***/ 6368:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatForTerminal = exports.writeToPseudoTerminal = void 0;
const vs = __webpack_require__(9496);
function writeToPseudoTerminal(messages) {
    const emitter = new vs.EventEmitter();
    const pseudoterminal = {
        close: () => { },
        onDidWrite: emitter.event,
        open: () => {
            for (const output of messages) {
                if (output)
                    emitter.fire(formatForTerminal(output));
            }
        },
    };
    const currentTestTerminal = [
        vs.window.createTerminal({ name: "Test Output", pty: pseudoterminal }),
        emitter,
    ];
    currentTestTerminal[0].show();
    return currentTestTerminal;
}
exports.writeToPseudoTerminal = writeToPseudoTerminal;
function formatForTerminal(output) {
    // For terminal, if we send \n without a \r the rendering will be bad.
    return output.replace(/\n/g, "\r\n");
}
exports.formatForTerminal = formatForTerminal;


/***/ }),

/***/ 5663:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageDepPackage = exports.PackageDepProjectPackageGroup = exports.PackageDepProject = exports.PackageDepFolder = exports.PackageDepFile = exports.PackageDep = exports.DartPackagesProvider = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const deps_1 = __webpack_require__(2253);
const package_map_1 = __webpack_require__(143);
const utils_1 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const utils_3 = __webpack_require__(8779);
class DartPackagesProvider {
    constructor(logger, context, dartCapabilities) {
        this.logger = logger;
        this.context = context;
        this.dartCapabilities = dartCapabilities;
        this.disposables = [];
        this.onDidChangeTreeDataEmitter = new vs.EventEmitter();
        this.onDidChangeTreeData = this.onDidChangeTreeDataEmitter.event;
        this.processPackageMapChangeEvents = true;
        this.disposables.push(vs.commands.registerCommand("_dart.removeDependencyFromTreeNode", this.removeDependency, this));
        context.events.onPackageMapChange.listen(() => {
            // Calling "pub deps --json" modifies .dart_tool/package_config.json which
            // causes a loop here. The file is modified, we rebuild the tree, which triggers
            // the file to be modified, which rebuilds...
            //
            // As a workaround, when this fires, suppress any further events for a short period.
            // This may result in dropped events, but it's better than the loop.
            if (!this.processPackageMapChangeEvents)
                return;
            this.processPackageMapChangeEvents = false;
            setTimeout(() => this.processPackageMapChangeEvents = true, 5000);
            this.onDidChangeTreeDataEmitter.fire(undefined);
        });
        this.deps = new deps_1.PubDeps(logger, context.sdks, dartCapabilities);
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!element) {
                const allProjects = yield (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true });
                const nodes = allProjects.map((folder) => new PackageDepProject(vs.Uri.file(folder)));
                // If there's only one, just skip over to the deps.
                return nodes.length === 1
                    ? this.getChildren(nodes[0])
                    : nodes;
            }
            else if (element instanceof PackageDepProject) {
                // Try getting dependencies from `pub deps`.
                let packages;
                let shortestPaths;
                if (this.dartCapabilities.supportsPubDepsJson) {
                    // Fetch dependencies with "pub deps --json".
                    const root = yield this.deps.getRootDependency(element.projectFolder);
                    packages = root ? this.deps.getPackageMap(root) : undefined;
                    shortestPaths = packages ? this.deps.computeShortestPaths(packages) : undefined;
                }
                // Get packages from package file.
                const allPackages = yield this.getPackages(element, shortestPaths);
                if (!packages)
                    return allPackages;
                // Split the packages into groups.
                const directPackages = allPackages.filter((p) => { var _a; return ((_a = packages[p.packageName]) === null || _a === void 0 ? void 0 : _a.kind) === "direct"; });
                const devPackages = allPackages.filter((p) => { var _a; return ((_a = packages[p.packageName]) === null || _a === void 0 ? void 0 : _a.kind) === "dev"; });
                const transitivePackages = allPackages.filter((p) => { var _a; return ((_a = packages[p.packageName]) === null || _a === void 0 ? void 0 : _a.kind) === "transitive"; });
                for (const p of directPackages)
                    p.contextValue = constants_1.DART_DEP_DEPENDENCY_PACKAGE_NODE_CONTEXT;
                for (const p of devPackages)
                    p.contextValue = constants_1.DART_DEP_DEV_DEPENDENCY_PACKAGE_NODE_CONTEXT;
                for (const p of transitivePackages)
                    p.contextValue = constants_1.DART_DEP_TRANSITIVE_DEPENDENCY_PACKAGE_NODE_CONTEXT;
                const nodes = [];
                if (directPackages.length)
                    nodes.push(new PackageDepProjectPackageGroup("direct dependencies", constants_1.DART_DEP_DEPENDENCIES_NODE_CONTEXT, directPackages));
                if (devPackages.length)
                    nodes.push(new PackageDepProjectPackageGroup("dev dependencies", constants_1.DART_DEP_DEV_DEPENDENCIES_NODE_CONTEXT, devPackages));
                if (transitivePackages.length)
                    nodes.push(new PackageDepProjectPackageGroup("transitive dependencies", constants_1.DART_DEP_TRANSITIVE_DEPENDENCIES_NODE_CONTEXT, transitivePackages, shortestPaths));
                return nodes;
            }
            else if (element instanceof PackageDepProjectPackageGroup) {
                // For the package groups, we've already computed the children when we split
                // them into the grous, so just return them directly.
                return element.packages;
            }
            else if (element instanceof PackageDepPackage) {
                return this.getFilesAndFolders(element);
            }
            else if (element instanceof PackageDepFolder) {
                return this.getFilesAndFolders(element);
            }
            else if (element instanceof PackageDepFile) {
                return [];
            }
            else {
                this.logger.warn(`Don't know how to show children of ${element.label}/${element.resourceUri}`);
                return [];
            }
        });
    }
    getPackages(project, shortestPaths) {
        return __awaiter(this, void 0, void 0, function* () {
            const map = package_map_1.PackageMap.loadForProject(this.logger, project.projectFolder);
            const packages = map.packages;
            const packageNames = (0, array_1.sortBy)(Object.keys(packages), (s) => s.toLowerCase());
            const packageDepNodes = packageNames
                .filter((name) => packages[name] && !(0, fs_1.areSameFolder)(packages[name], path.join(project.projectFolder, "lib")))
                .map((name) => {
                let packagePath = packages[name];
                if (path.basename(packagePath) === "lib")
                    packagePath = path.normalize(path.join(packagePath, ".."));
                const shortestPath = shortestPaths ? shortestPaths[name] : undefined;
                return new PackageDepPackage(`${name}`, vs.Uri.file(packagePath), project.projectFolder, shortestPath);
            });
            return packageDepNodes;
        });
    }
    getFilesAndFolders(folder) {
        const children = (0, array_1.sortBy)(fs.readdirSync((0, fs_1.fsPath)(folder.resourceUri), { withFileTypes: true }), (s) => s.name.toLowerCase());
        const folders = [];
        const files = [];
        if (!folder.resourceUri)
            return [];
        const folderPath = (0, fs_1.fsPath)(folder.resourceUri);
        children.forEach((child) => {
            const filePath = path.join(folderPath, child.name);
            if (child.isFile()) {
                files.push(new PackageDepFile(vs.Uri.file(filePath)));
            }
            else if (child.isDirectory()) {
                folders.push(new PackageDepFolder(vs.Uri.file(filePath)));
            }
        });
        return [...folders, ...files];
    }
    removeDependency(treeNode) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageName = treeNode === null || treeNode === void 0 ? void 0 : treeNode.packageName;
            const projectFolder = treeNode === null || treeNode === void 0 ? void 0 : treeNode.projectFolder;
            if (packageName && projectFolder)
                yield vs.commands.executeCommand("_dart.removeDependency", treeNode.projectFolder, treeNode.packageName);
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DartPackagesProvider = DartPackagesProvider;
class PackageDep extends vs.TreeItem {
    constructor(label, resourceUri, collapsibleState) {
        if (label) {
            super(label, collapsibleState);
            this.resourceUri = resourceUri;
        }
        else if (resourceUri) {
            super(resourceUri, collapsibleState);
        }
        else {
            super("<unnamed>", collapsibleState);
        }
    }
}
exports.PackageDep = PackageDep;
class PackageDepFile extends PackageDep {
    constructor(resourceUri) {
        super(undefined, resourceUri, vs.TreeItemCollapsibleState.None);
        this.contextValue = constants_1.DART_DEP_FILE_NODE_CONTEXT;
        this.command = {
            arguments: [resourceUri],
            command: "dart.package.openFile",
            title: "Open File",
        };
    }
}
exports.PackageDepFile = PackageDepFile;
class PackageDepFolder extends PackageDep {
    constructor(resourceUri) {
        super(undefined, resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.contextValue = constants_1.DART_DEP_FOLDER_NODE_CONTEXT;
    }
}
exports.PackageDepFolder = PackageDepFolder;
class PackageDepProject extends PackageDep {
    constructor(projectUri) {
        const projectFolder = (0, fs_1.fsPath)(projectUri);
        super(path.basename(projectFolder), undefined, vs.TreeItemCollapsibleState.Collapsed);
        this.projectFolder = projectFolder;
        this.contextValue = constants_1.DART_DEP_PROJECT_NODE_CONTEXT;
        // Calculate relative path to the folder for the description.
        const wf = vs.workspace.getWorkspaceFolder(projectUri);
        if (wf) {
            const workspaceFolder = (0, fs_1.fsPath)(wf.uri);
            this.description = path.relative(path.dirname(workspaceFolder), path.dirname(projectFolder));
        }
    }
}
exports.PackageDepProject = PackageDepProject;
class PackageDepProjectPackageGroup extends PackageDep {
    constructor(label, context, packages, shortestPaths) {
        super(label, undefined, vs.TreeItemCollapsibleState.Collapsed);
        this.packages = packages;
        this.shortestPaths = shortestPaths;
        this.contextValue = context;
    }
}
exports.PackageDepProjectPackageGroup = PackageDepProjectPackageGroup;
class PackageDepPackage extends PackageDep {
    constructor(packageName, resourceUri, projectFolder, shortestPath) {
        super(packageName, resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.packageName = packageName;
        this.projectFolder = projectFolder;
        this.contextValue = constants_1.DART_DEP_PACKAGE_NODE_CONTEXT;
        if (shortestPath)
            this.tooltip = shortestPath.join("  ");
    }
}
exports.PackageDepPackage = PackageDepPackage;


/***/ }),

/***/ 556:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompleteStatementRequest = exports.ReanalyzeRequest = exports.DiagnosticServerRequest = exports.SuperRequest = exports.PublishFlutterOutlineNotification = exports.PublishOutlineNotification = exports.PublishClosingLabelsNotification = exports.AnalyzerStatusNotification = void 0;
const vscode_languageclient_1 = __webpack_require__(2850);
class AnalyzerStatusNotification {
}
exports.AnalyzerStatusNotification = AnalyzerStatusNotification;
AnalyzerStatusNotification.type = new vscode_languageclient_1.NotificationType("$/analyzerStatus");
class PublishClosingLabelsNotification {
}
exports.PublishClosingLabelsNotification = PublishClosingLabelsNotification;
PublishClosingLabelsNotification.type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishClosingLabels");
class PublishOutlineNotification {
}
exports.PublishOutlineNotification = PublishOutlineNotification;
PublishOutlineNotification.type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishOutline");
class PublishFlutterOutlineNotification {
}
exports.PublishFlutterOutlineNotification = PublishFlutterOutlineNotification;
PublishFlutterOutlineNotification.type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishFlutterOutline");
class SuperRequest {
}
exports.SuperRequest = SuperRequest;
SuperRequest.type = new vscode_languageclient_1.RequestType("dart/textDocument/super");
class DiagnosticServerRequest {
}
exports.DiagnosticServerRequest = DiagnosticServerRequest;
DiagnosticServerRequest.type = new vscode_languageclient_1.RequestType0("dart/diagnosticServer");
class ReanalyzeRequest {
}
exports.ReanalyzeRequest = ReanalyzeRequest;
ReanalyzeRequest.type = new vscode_languageclient_1.RequestType0("dart/reanalyze");
class CompleteStatementRequest {
}
exports.CompleteStatementRequest = CompleteStatementRequest;
CompleteStatementRequest.type = new vscode_languageclient_1.RequestType("dart/completeStatement");


/***/ }),

/***/ 458:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Analyzer = void 0;
const events_1 = __webpack_require__(3254);
const utils_1 = __webpack_require__(4586);
const promises_1 = __webpack_require__(4411);
class Analyzer {
    constructor(logger) {
        this.logger = logger;
        this.disposables = [];
        this.onReadyCompleter = new utils_1.PromiseCompleter();
        this.onReady = this.onReadyCompleter.promise;
        this.onAnalysisCompleteCompleter = new utils_1.PromiseCompleter();
        // InitialAnalysis uses the very first promise from onAnalysisCompleteCompleter.
        this.onInitialAnalysis = this.onAnalysisCompleteCompleter.promise;
        // TODO: Remove suppressProgress when non-LSP is gone and Flutter stable has LSP server that uses $/progress.
        this.onAnalysisStatusChangeEmitter = new events_1.EventEmitter();
        this.onAnalysisStatusChange = this.onAnalysisStatusChangeEmitter.event;
        this.isAnalyzing = false;
        this.disposables.push(this.onAnalysisStatusChangeEmitter);
        // tslint:disable-next-line: no-floating-promises
        this.setup();
    }
    get onCurrentAnalysisComplete() { return this.isAnalyzing ? this.onAnalysisCompleteCompleter.promise : promises_1.resolvedPromise; }
    get onNextAnalysisComplete() { return this.onAnalysisCompleteCompleter.promise; }
    setup() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.onReady;
            this.onAnalysisStatusChange.listen((status) => {
                this.isAnalyzing = status.isAnalyzing;
                if (!status.isAnalyzing) {
                    this.onAnalysisCompleteCompleter.resolve();
                    this.onAnalysisCompleteCompleter = new utils_1.PromiseCompleter();
                }
            });
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.Analyzer = Analyzer;


/***/ }),

/***/ 7355:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCapabilities = void 0;
const utils_1 = __webpack_require__(4586);
class DartCapabilities {
    constructor(dartVersion) {
        this.version = dartVersion;
    }
    static get empty() { return new DartCapabilities("0.0.0"); }
    get canDefaultLsp() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    // This is also missing in v2.10, but assume it will be back in v2.11.
    // https://github.com/dart-lang/sdk/issues/43207
    get includesSourceForSdkLibs() { return (0, utils_1.versionIsAtLeast)(this.version, "2.2.1") && !this.version.startsWith("2.10."); }
    get hasLspInsertTextModeSupport() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-0"); }
    get supportsSnippetTextEdits() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-150"); }
    get supportsWriteServiceInfo() { return (0, utils_1.versionIsAtLeast)(this.version, "2.7.1"); }
    get supportsDartCreate() { return (0, utils_1.versionIsAtLeast)(this.version, "2.10.0"); }
    get supportsDebugInternalLibraries() { return (0, utils_1.versionIsAtLeast)(this.version, "2.9.0-a"); }
    get supportsDisableDartDev() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    get hasDdsTimingFix() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-117"); }
    get supportsLanguageServerCommand() { return (0, utils_1.versionIsAtLeast)(this.version, "2.14.4"); }
    get supportsNoServeDevTools() { return (0, utils_1.versionIsAtLeast)(this.version, "2.14.0-172.0"); }
    get supportsPubUpgradeMajorVersions() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0"); }
    get supportsPubOutdated() { return (0, utils_1.versionIsAtLeast)(this.version, "2.8.0-a"); }
    get supportsPubDepsJson() { return (0, utils_1.versionIsAtLeast)(this.version, "2.14.0-0"); }
    get supportsDartPub() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    get supportsDartDevTools() { return (0, utils_1.versionIsAtLeast)(this.version, "2.15.0"); }
    get supportsDartRunTest() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    get supportsNonFileSchemeWorkspaces() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-28"); }
    // TODO: Update these (along with Flutter) when supported.
    get webSupportsEvaluation() { return false; }
    get webSupportsDebugging() { return true; }
    get webSupportsHotReload() { return false; }
}
exports.DartCapabilities = DartCapabilities;


/***/ }),

/***/ 4790:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DaemonCapabilities = exports.FlutterCapabilities = void 0;
const utils_1 = __webpack_require__(4586);
class FlutterCapabilities {
    constructor(flutterVersion) {
        this.version = flutterVersion;
    }
    static get empty() { return new FlutterCapabilities("0.0.0"); }
    get supportsCreateSkeleton() { return (0, utils_1.versionIsAtLeast)(this.version, "2.5.0"); }
    get supportsCreatingSamples() { return (0, utils_1.versionIsAtLeast)(this.version, "1.0.0"); }
    get hasLatestStructuredErrorsWork() { return (0, utils_1.versionIsAtLeast)(this.version, "1.21.0-5.0"); }
    get supportsFlutterCreateListSamples() { return (0, utils_1.versionIsAtLeast)(this.version, "1.3.10"); }
    get supportsWsVmService() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.0-5"); }
    get supportsWsDebugBackend() { return (0, utils_1.versionIsAtLeast)(this.version, "1.21.0-0"); }
    get supportsWsInjectedClient() { return (0, utils_1.versionIsAtLeast)(this.version, "2.1.0-13.0"); }
    get supportsExposeUrl() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.0-5"); }
    get supportsDartDefine() { return (0, utils_1.versionIsAtLeast)(this.version, "1.17.0"); }
    get supportsRestartDebounce() { return (0, utils_1.versionIsAtLeast)(this.version, "1.21.0-0"); }
    get supportsRunSkippedTests() { return (0, utils_1.versionIsAtLeast)(this.version, "2.1.0-11"); }
    get supportsShowWebServerDevice() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0-0"); }
    get supportsWebRendererOption() { return (0, utils_1.versionIsAtLeast)(this.version, "1.25.0-0"); }
    get supportsDevToolsServerAddress() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0-12"); }
    get supportsRunningIntegrationTests() { return (0, utils_1.versionIsAtLeast)(this.version, "2.2.0-10"); }
    // TODO: Update these (along with Dart) when supported.
    get webSupportsEvaluation() { return false; }
    get webSupportsDebugging() { return true; }
    get webSupportsHotReload() { return false; }
    get webHasReloadBug() { return !(0, utils_1.versionIsAtLeast)(this.version, "2.6.0"); } // https://github.com/dart-lang/webdev/issues/1416
}
exports.FlutterCapabilities = FlutterCapabilities;
class DaemonCapabilities {
    constructor(daemonProtocolVersion) {
        this.version = daemonProtocolVersion;
    }
    static get empty() { return new DaemonCapabilities("0.0.0"); }
    get canCreateEmulators() { return (0, utils_1.versionIsAtLeast)(this.version, "0.4.0"); }
    get canFlutterAttach() { return (0, utils_1.versionIsAtLeast)(this.version, "0.4.1"); }
    get providesPlatformTypes() { return (0, utils_1.versionIsAtLeast)(this.version, "0.5.2"); }
    get supportsAvdColdBootLaunch() { return (0, utils_1.versionIsAtLeast)(this.version, "0.6.1"); }
}
exports.DaemonCapabilities = DaemonCapabilities;


/***/ }),

/***/ 7068:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vsCodeVersion = exports.CodeCapabilities = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const utils_cloud_1 = __webpack_require__(9492);
class CodeCapabilities {
    constructor(version) {
        this.version = version;
    }
    // This version should match the minimum the LSP client we're using supports.
    // https://github.com/microsoft/vscode-languageserver-node/blob/main/client/src/node/main.ts#L25
    get supportsLatestLspClient() { return (0, utils_1.versionIsAtLeast)(this.version, "1.52.0"); }
    // Theia doesn't currently support launching without a launch.json. This may need updating to also
    // check the version in future.
    get supportsDebugWithoutLaunchJson() { return !utils_cloud_1.isTheia; }
    // Cloud IDEs may have authentication issues trying to use embedded DevTools so just disable it.
    get supportsEmbeddedDevTools() { return !utils_cloud_1.isKnownCloudIde; }
    get supportsDevTools() { return !utils_cloud_1.isCloudShell; } // Until DevTools can work without SSE, it will not work on Cloud Shell.
    get editorConfigFolder() { return utils_cloud_1.isTheia ? ".theia" : ".vscode"; }
}
exports.CodeCapabilities = CodeCapabilities;
exports.vsCodeVersion = new CodeCapabilities(vscode_1.version);


/***/ }),

/***/ 5628:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.alwaysOpenAction = exports.openDevToolsAction = exports.wantToTryDevToolsPrompt = exports.issueTrackerUri = exports.issueTrackerAction = exports.stagehandInstallationInstructionsUrl = exports.pubGlobalDocsUrl = exports.debugTerminatingProgressId = exports.debugLaunchProgressId = exports.restartReasonSave = exports.restartReasonManual = exports.showLogAction = exports.stopLoggingAction = exports.IS_RUNNING_LOCALLY_CONTEXT = exports.PUB_OUTDATED_SUPPORTED_CONTEXT = exports.DART_IS_CAPTURING_LOGS_CONTEXT = exports.DART_DEP_FILE_NODE_CONTEXT = exports.DART_DEP_FOLDER_NODE_CONTEXT = exports.DART_DEP_TRANSITIVE_DEPENDENCY_PACKAGE_NODE_CONTEXT = exports.DART_DEP_DEV_DEPENDENCY_PACKAGE_NODE_CONTEXT = exports.DART_DEP_DEPENDENCY_PACKAGE_NODE_CONTEXT = exports.DART_DEP_PACKAGE_NODE_CONTEXT = exports.DART_DEP_TRANSITIVE_DEPENDENCIES_NODE_CONTEXT = exports.DART_DEP_DEV_DEPENDENCIES_NODE_CONTEXT = exports.DART_DEP_DEPENDENCIES_NODE_CONTEXT = exports.DART_DEP_PROJECT_NODE_CONTEXT = exports.IS_LSP_CONTEXT = exports.FLUTTER_DOWNLOAD_URL = exports.DART_DOWNLOAD_URL = exports.androidStudioPaths = exports.analyzerSnapshotPath = exports.pubSnapshotPath = exports.flutterPath = exports.pubPath = exports.dartDocPath = exports.dartVMPath = exports.getExecutableName = exports.executableNames = exports.androidStudioExecutableNames = exports.platformEol = exports.platformDisplayName = exports.dartPlatformName = exports.isChromeOS = exports.isLinux = exports.isMac = exports.isWin = exports.isCI = exports.debugAdapterPath = exports.flutterExtensionIdentifier = exports.dartCodeExtensionIdentifier = void 0;
exports.validClassNameRegex = exports.validMethodNameRegex = exports.cancelAction = exports.runFlutterCreatePrompt = exports.vmServiceHttpLinkPattern = exports.vmServiceListeningBannerPattern = exports.reactivateDevToolsAction = exports.openSettingsAction = exports.recommendedSettingsUrl = exports.showRecommendedSettingsAction = exports.iUnderstandAction = exports.skipAction = exports.noAction = exports.yesAction = exports.useRecommendedSettingsPromptKey = exports.installFlutterExtensionPromptKey = exports.userPromptContextPrefix = exports.debugAnywayAction = exports.showErrorsAction = exports.isInFlutterReleaseModeDebugSessionContext = exports.isInFlutterProfileModeDebugSessionContext = exports.isInFlutterDebugModeDebugSessionContext = exports.HAS_LAST_TEST_DEBUG_CONFIG = exports.HAS_LAST_DEBUG_CONFIG = exports.REFACTOR_ANYWAY = exports.REFACTOR_FAILED_DOC_MODIFIED = exports.FLUTTER_CREATE_PROJECT_TRIGGER_FILE = exports.DART_CREATE_PROJECT_TRIGGER_FILE = exports.CHROME_OS_VM_SERVICE_PORT = exports.CHROME_OS_DEVTOOLS_PORT = exports.pleaseReportBug = exports.longRepeatPromptThreshold = exports.noRepeatPromptThreshold = exports.fortyHoursInMs = exports.twentyHoursInMs = exports.twoHoursInMs = exports.twentyMinutesInMs = exports.tenMinutesInMs = exports.fiveMinutesInMs = exports.snapFlutterBinaryPath = exports.snapBinaryPath = exports.initializingFlutterMessage = exports.modifyingFilesOutsideWorkspaceInfoUrl = exports.skipThisSurveyAction = exports.takeSurveyAction = exports.flutterSurveyAnalyticsText = exports.flutterSurveyDataUrl = exports.moreInfoAction = exports.doNotAskAgainAction = exports.notTodayAction = void 0;
exports.MAX_VERSION = exports.defaultLaunchJson = exports.dartRecommendedConfig = exports.devToolsPages = exports.widgetInspectorPage = void 0;
const fs = __webpack_require__(7147);
const utils_1 = __webpack_require__(4586);
exports.dartCodeExtensionIdentifier = "Dart-Code.dart-code";
exports.flutterExtensionIdentifier = "Dart-Code.flutter";
exports.debugAdapterPath = "out/dist/debug.js";
exports.isCI = !!process.env.CI;
exports.isWin = process.platform.startsWith("win");
exports.isMac = process.platform === "darwin";
exports.isLinux = !exports.isWin && !exports.isMac;
exports.isChromeOS = exports.isLinux && fs.existsSync("/dev/.cros_milestone");
// Used for code checks and in Dart SDK urls so Chrome OS is considered Linux.
exports.dartPlatformName = exports.isWin ? "win" : exports.isMac ? "mac" : "linux";
// Used for display (logs, analytics) so Chrome OS is its own.
exports.platformDisplayName = exports.isWin ? "win" : exports.isMac ? "mac" : exports.isChromeOS ? "chromeos" : "linux";
exports.platformEol = exports.isWin ? "\r\n" : "\n";
exports.androidStudioExecutableNames = exports.isWin ? ["studio64.exe"] : ["studio.sh", "studio"];
exports.executableNames = {
    dart: exports.isWin ? "dart.exe" : "dart",
    dartdoc: exports.isWin ? "dartdoc.bat" : "dartdoc",
    flutter: exports.isWin ? "flutter.bat" : "flutter",
    pub: exports.isWin ? "pub.bat" : "pub",
};
const getExecutableName = (cmd) => { var _a; return (_a = exports.executableNames[cmd]) !== null && _a !== void 0 ? _a : cmd; };
exports.getExecutableName = getExecutableName;
exports.dartVMPath = "bin/" + exports.executableNames.dart;
exports.dartDocPath = "bin/" + exports.executableNames.dartdoc;
exports.pubPath = "bin/" + exports.executableNames.pub;
exports.flutterPath = "bin/" + exports.executableNames.flutter;
exports.pubSnapshotPath = "bin/snapshots/pub.dart.snapshot";
exports.analyzerSnapshotPath = "bin/snapshots/analysis_server.dart.snapshot";
exports.androidStudioPaths = exports.androidStudioExecutableNames.map((s) => "bin/" + s);
exports.DART_DOWNLOAD_URL = "https://dart.dev/get-dart";
exports.FLUTTER_DOWNLOAD_URL = "https://flutter.dev/setup/";
exports.IS_LSP_CONTEXT = "dart-code:isLsp";
exports.DART_DEP_PROJECT_NODE_CONTEXT = "dart-code:depProjectNode";
exports.DART_DEP_DEPENDENCIES_NODE_CONTEXT = "dart-code:depDependenciesNode";
exports.DART_DEP_DEV_DEPENDENCIES_NODE_CONTEXT = "dart-code:depDevDependenciesNode";
exports.DART_DEP_TRANSITIVE_DEPENDENCIES_NODE_CONTEXT = "dart-code:depTransitiveDependenciesNode";
exports.DART_DEP_PACKAGE_NODE_CONTEXT = "dart-code:depPackageNode";
exports.DART_DEP_DEPENDENCY_PACKAGE_NODE_CONTEXT = "dart-code:depDependencyPackageNode";
exports.DART_DEP_DEV_DEPENDENCY_PACKAGE_NODE_CONTEXT = "dart-code:depDevDependencyPackageNode";
exports.DART_DEP_TRANSITIVE_DEPENDENCY_PACKAGE_NODE_CONTEXT = "dart-code:depTransitiveDependencyPackageNode";
exports.DART_DEP_FOLDER_NODE_CONTEXT = "dart-code:depFolderNode";
exports.DART_DEP_FILE_NODE_CONTEXT = "dart-code:depFileNode";
exports.DART_IS_CAPTURING_LOGS_CONTEXT = "dart-code:isCapturingLogs";
exports.PUB_OUTDATED_SUPPORTED_CONTEXT = "dart-code:pubOutdatedSupported";
exports.IS_RUNNING_LOCALLY_CONTEXT = "dart-code:isRunningLocally";
exports.stopLoggingAction = "Stop Logging";
exports.showLogAction = "Show Log";
exports.restartReasonManual = "manual";
exports.restartReasonSave = "save";
exports.debugLaunchProgressId = "launch";
exports.debugTerminatingProgressId = "terminate";
exports.pubGlobalDocsUrl = "https://www.dartlang.org/tools/pub/cmd/pub-global";
exports.stagehandInstallationInstructionsUrl = "https://github.com/dart-lang/stagehand#installation";
exports.issueTrackerAction = "Issue Tracker";
exports.issueTrackerUri = "https://github.com/Dart-Code/Dart-Code/issues";
exports.wantToTryDevToolsPrompt = "Dart DevTools includes additional tools for debugging and profiling Flutter apps, including a Widget Inspector. Try it?";
exports.openDevToolsAction = "Open";
exports.alwaysOpenAction = "Always Open";
exports.notTodayAction = "Not Now";
exports.doNotAskAgainAction = "Never Ask";
exports.moreInfoAction = "More Info";
exports.flutterSurveyDataUrl = "https://docs.flutter.dev/f/flutter-survey-metadata.json";
exports.flutterSurveyAnalyticsText = "By clicking on this link you agree to share feature usage along with the survey responses.";
exports.takeSurveyAction = "Take Survey";
exports.skipThisSurveyAction = "Skip This Survey";
exports.modifyingFilesOutsideWorkspaceInfoUrl = "https://dartcode.org/docs/modifying-files-outside-workspace/";
exports.initializingFlutterMessage = "Initializing Flutter. This may take a few minutes.";
exports.snapBinaryPath = "/usr/bin/snap";
exports.snapFlutterBinaryPath = "/snap/bin/flutter";
// Minutes.
exports.fiveMinutesInMs = 1000 * 60 * 5;
exports.tenMinutesInMs = 1000 * 60 * 10;
exports.twentyMinutesInMs = 1000 * 60 * 20;
// Hours.
exports.twoHoursInMs = 1000 * 60 * 60 * 2;
exports.twentyHoursInMs = 1000 * 60 * 60 * 20;
exports.fortyHoursInMs = 1000 * 60 * 60 * 40;
// Duration for not showing a prompt that has been shown before.
exports.noRepeatPromptThreshold = exports.twentyHoursInMs;
exports.longRepeatPromptThreshold = exports.fortyHoursInMs;
exports.pleaseReportBug = "Please raise a bug against the Dart extension for VS Code.";
// Chrome OS exposed ports: 8000, 8008, 8080, 8085, 8888, 9005, 3000, 4200, 5000
exports.CHROME_OS_DEVTOOLS_PORT = 8080;
exports.CHROME_OS_VM_SERVICE_PORT = 8085;
exports.DART_CREATE_PROJECT_TRIGGER_FILE = "dart.sh.create";
exports.FLUTTER_CREATE_PROJECT_TRIGGER_FILE = "flutter.create";
exports.REFACTOR_FAILED_DOC_MODIFIED = "This refactor cannot be applied because the document has changed.";
exports.REFACTOR_ANYWAY = "Refactor Anyway";
exports.HAS_LAST_DEBUG_CONFIG = "dart-code:hasLastDebugConfig";
exports.HAS_LAST_TEST_DEBUG_CONFIG = "dart-code:hasLastTestDebugConfig";
exports.isInFlutterDebugModeDebugSessionContext = "dart-code:isInFlutterDebugModeDebugSession";
exports.isInFlutterProfileModeDebugSessionContext = "dart-code:isInFlutterProfileModeDebugSession";
exports.isInFlutterReleaseModeDebugSessionContext = "dart-code:isInFlutterReleaseModeDebugSession";
exports.showErrorsAction = "Show Errors";
exports.debugAnywayAction = "Debug Anyway";
exports.userPromptContextPrefix = "hasPrompted.";
exports.installFlutterExtensionPromptKey = "install_flutter_extension_3";
exports.useRecommendedSettingsPromptKey = "use_recommended_settings";
exports.yesAction = "Yes";
exports.noAction = "No";
exports.skipAction = "Skip";
exports.iUnderstandAction = "I Understand";
exports.showRecommendedSettingsAction = "Show Recommended Settings";
exports.recommendedSettingsUrl = "https://dartcode.org/docs/recommended-settings/";
exports.openSettingsAction = "Open Settings File";
exports.reactivateDevToolsAction = "Reactivate DevTools";
exports.vmServiceListeningBannerPattern = new RegExp("Observatory (?:listening on|.* is available at:) (http:.+)");
exports.vmServiceHttpLinkPattern = new RegExp("(http://[\\d\\.:]+/)");
const runFlutterCreatePrompt = (platformType, platformNeedsGloballyEnabling) => platformNeedsGloballyEnabling
    ? `Enable the ${platformType} platform and add it to this project?`
    : `Add the ${platformType} platform to this project?`;
exports.runFlutterCreatePrompt = runFlutterCreatePrompt;
exports.cancelAction = "Cancel";
exports.validMethodNameRegex = new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
exports.validClassNameRegex = exports.validMethodNameRegex;
exports.widgetInspectorPage = { id: "inspector", commandId: "dart.openDevToolsInspector", title: "Widget Inspector" };
exports.devToolsPages = [
    // First entry is the default page.
    exports.widgetInspectorPage,
    { id: "cpu-profiler", commandId: "dart.openDevToolsCpuProfiler", title: "CPU Profiler" },
    { id: "memory", commandId: "dart.openDevToolsMemory", title: "Memory" },
    {
        commandId: "dart.openDevToolsPerformance",
        id: "performance",
        routeId: (flutterVersion) => !flutterVersion || (0, utils_1.versionIsAtLeast)(flutterVersion, "2.3.1" /* 2.3.0-16.0? */) ? "performance" : "legacy-performance",
        title: "Performance",
    },
    { id: "network", commandId: "dart.openDevToolsNetwork", title: "Network" },
    { id: "logging", commandId: "dart.openDevToolsLogging", title: "Logging" },
];
exports.dartRecommendedConfig = {
    // Automatically format code on save and during typing of certain characters
    // (like `;` and `}`).
    "editor.formatOnSave": true,
    "editor.formatOnType": true,
    // Draw a guide line at 80 characters, where Dart's formatting will wrap code.
    "editor.rulers": [80],
    // Disables built-in highlighting of words that match your selection. Without
    // this, all instances of the selected text will be highlighted, interfering
    // with Dart's ability to highlight only exact references to the selected variable.
    "editor.selectionHighlight": false,
    // By default, VS Code prevents code completion from popping open when in
    // "snippet mode" (editing placeholders in inserted code). Setting this option
    // to `false` stops that and allows completion to open as normal, as if you
    // weren't in a snippet placeholder.
    "editor.suggest.snippetsPreventQuickSuggestions": false,
    // By default, VS Code will pre-select the most recently used item from code
    // completion. This is usually not the most relevant item.
    //
    // "first" will always select top item
    // "recentlyUsedByPrefix" will filter the recently used items based on the
    //     text immediately preceeding where completion was invoked.
    "editor.suggestSelection": "first",
    // Allows pressing <TAB> to complete snippets such as `for` even when the
    // completion list is not visible.
    "editor.tabCompletion": "onlySnippets",
    // By default, VS Code will popualte code completion with words found in the
    // current file when a language service does not provide its own completions.
    // This results in code completion suggesting words when editing comments and
    // strings. This setting will prevent that.
    "editor.wordBasedSuggestions": false,
};
exports.defaultLaunchJson = JSON.stringify({
    "configurations": [
        {
            "name": "Dart & Flutter",
            "request": "launch",
            "type": "dart",
        },
    ],
    "version": "0.2.0",
}, undefined, "\t");
// This indicates that a version is the latest possible.
exports.MAX_VERSION = "999.999.999";


/***/ }),

/***/ 7341:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugOption = exports.debugOptionNames = exports.LogSeverity = exports.LogCategory = exports.VersionStatus = exports.VmService = exports.VmServiceExtension = exports.TestStatus = exports.DebuggerType = void 0;
var DebuggerType;
(function (DebuggerType) {
    DebuggerType[DebuggerType["Dart"] = 0] = "Dart";
    DebuggerType[DebuggerType["DartTest"] = 1] = "DartTest";
    DebuggerType[DebuggerType["Flutter"] = 2] = "Flutter";
    DebuggerType[DebuggerType["FlutterTest"] = 3] = "FlutterTest";
    DebuggerType[DebuggerType["Web"] = 4] = "Web";
    DebuggerType[DebuggerType["WebTest"] = 5] = "WebTest";
})(DebuggerType = exports.DebuggerType || (exports.DebuggerType = {}));
var TestStatus;
(function (TestStatus) {
    // This should be in order such that the highest number is the one to show
    // when aggregating (eg. from children).
    TestStatus[TestStatus["Waiting"] = 0] = "Waiting";
    TestStatus[TestStatus["Skipped"] = 1] = "Skipped";
    TestStatus[TestStatus["Passed"] = 2] = "Passed";
    TestStatus[TestStatus["Unknown"] = 3] = "Unknown";
    TestStatus[TestStatus["Failed"] = 4] = "Failed";
    TestStatus[TestStatus["Running"] = 5] = "Running";
})(TestStatus = exports.TestStatus || (exports.TestStatus = {}));
/// The service extensions we know about.
var VmServiceExtension;
(function (VmServiceExtension) {
    VmServiceExtension["PlatformOverride"] = "ext.flutter.platformOverride";
    VmServiceExtension["DebugBanner"] = "ext.flutter.debugAllowBanner";
    VmServiceExtension["CheckElevations"] = "ext.flutter.debugCheckElevationsEnabled";
    VmServiceExtension["DebugPaint"] = "ext.flutter.debugPaint";
    VmServiceExtension["Driver"] = "ext.flutter.driver";
    VmServiceExtension["PaintBaselines"] = "ext.flutter.debugPaintBaselinesEnabled";
    VmServiceExtension["InspectorSelectMode"] = "ext.flutter.inspector.show";
    VmServiceExtension["InspectorSetPubRootDirectories"] = "ext.flutter.inspector.setPubRootDirectories";
    VmServiceExtension["InspectorStructuredErrors"] = "ext.flutter.inspector.structuredErrors";
    VmServiceExtension["BrightnessOverride"] = "ext.flutter.brightnessOverride";
    VmServiceExtension["RepaintRainbow"] = "ext.flutter.repaintRainbow";
    VmServiceExtension["PerformanceOverlay"] = "ext.flutter.showPerformanceOverlay";
    VmServiceExtension["SlowAnimations"] = "ext.flutter.timeDilation";
})(VmServiceExtension = exports.VmServiceExtension || (exports.VmServiceExtension = {}));
/// The service extensions we know about and allow toggling via commands.
var VmService;
(function (VmService) {
    VmService["HotReload"] = "reloadSources";
    VmService["HotRestart"] = "hotRestart";
    VmService["LaunchDevTools"] = "launchDevTools";
})(VmService = exports.VmService || (exports.VmService = {}));
var VersionStatus;
(function (VersionStatus) {
    VersionStatus[VersionStatus["NotInstalled"] = 0] = "NotInstalled";
    VersionStatus[VersionStatus["UpdateRequired"] = 1] = "UpdateRequired";
    VersionStatus[VersionStatus["UpdateAvailable"] = 2] = "UpdateAvailable";
    VersionStatus[VersionStatus["Valid"] = 3] = "Valid";
})(VersionStatus = exports.VersionStatus || (exports.VersionStatus = {}));
var LogCategory;
(function (LogCategory) {
    LogCategory[LogCategory["General"] = 0] = "General";
    LogCategory[LogCategory["CI"] = 1] = "CI";
    LogCategory[LogCategory["CommandProcesses"] = 2] = "CommandProcesses";
    LogCategory[LogCategory["DAP"] = 3] = "DAP";
    LogCategory[LogCategory["DevTools"] = 4] = "DevTools";
    LogCategory[LogCategory["Analyzer"] = 5] = "Analyzer";
    LogCategory[LogCategory["DartTest"] = 6] = "DartTest";
    LogCategory[LogCategory["FlutterDaemon"] = 7] = "FlutterDaemon";
    LogCategory[LogCategory["FlutterRun"] = 8] = "FlutterRun";
    LogCategory[LogCategory["FlutterTest"] = 9] = "FlutterTest";
    LogCategory[LogCategory["VmService"] = 10] = "VmService";
    LogCategory[LogCategory["WebDaemon"] = 11] = "WebDaemon";
})(LogCategory = exports.LogCategory || (exports.LogCategory = {}));
var LogSeverity;
(function (LogSeverity) {
    LogSeverity[LogSeverity["Info"] = 0] = "Info";
    LogSeverity[LogSeverity["Warn"] = 1] = "Warn";
    LogSeverity[LogSeverity["Error"] = 2] = "Error";
})(LogSeverity = exports.LogSeverity || (exports.LogSeverity = {}));
exports.debugOptionNames = ["my code", "my code + packages", "my code + packages + SDK", "my code + SDK"];
var DebugOption;
(function (DebugOption) {
    DebugOption[DebugOption["MyCode"] = 0] = "MyCode";
    DebugOption[DebugOption["MyCodePackages"] = 1] = "MyCodePackages";
    DebugOption[DebugOption["MyCodePackagesSdk"] = 2] = "MyCodePackagesSdk";
    DebugOption[DebugOption["MyCodeSdk"] = 3] = "MyCodeSdk";
})(DebugOption = exports.DebugOption || (exports.DebugOption = {}));


/***/ }),

/***/ 3254:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventEmitter = void 0;
const evt = __webpack_require__(2361);
class EventEmitter {
    constructor() {
        this.emitter = new evt.EventEmitter();
    }
    fire(x) {
        this.emitter.emit("thing", x);
    }
    listen(listener) {
        this.emitter.on("thing", listener);
        return {
            dispose: () => { this.emitter.removeListener("thing", listener); },
        };
    }
    get event() { return this; }
    dispose() {
        this.emitter.removeAllListeners();
    }
}
exports.EventEmitter = EventEmitter;


/***/ }),

/***/ 2183:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebClient = void 0;
const http = __webpack_require__(3685);
const https = __webpack_require__(5687);
const url = __webpack_require__(7310);
const zlib = __webpack_require__(9796);
class WebClient {
    constructor(extensionVersion) {
        this.userAgent = `Dart-Code/${extensionVersion} (https://dartcode.org/)`;
    }
    // TODO: Move over things over to this...
    fetch(urlString, headers) {
        const u = url.parse(urlString);
        if (u.protocol === "https:" && u.hostname)
            return this.fetchHttps(u.hostname, u.port || "443", u.path || "", headers);
        else if (u.protocol === "http:" && u.hostname)
            return this.fetchHttp(u.hostname, u.port || "80", u.path || "", headers);
        else
            throw new Error(`Cannot fetch URL ${urlString}`);
    }
    fetchHttps(hostname, port, path, headers = {}) {
        return new Promise((resolve, reject) => {
            const options = {
                headers: Object.assign(Object.assign({}, headers), { "User-Agent": this.userAgent }),
                hostname,
                method: "GET",
                path,
                port,
            };
            const req = https.request(options, (resp) => {
                if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                    reject({ message: `Failed to get ${path}: ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
                }
                else {
                    const chunks = [];
                    resp.on("data", (b) => chunks.push(b));
                    resp.on("end", () => {
                        const buffer = Buffer.concat(chunks);
                        const encoding = resp.headers["content-encoding"];
                        if (encoding === "gzip") {
                            zlib.gunzip(buffer, (err, decoded) => {
                                if (err)
                                    reject(err);
                                else
                                    resolve(decoded === null || decoded === void 0 ? void 0 : decoded.toString());
                            });
                        }
                        else {
                            resolve(buffer.toString());
                        }
                    });
                }
            });
            req.end();
        });
    }
    fetchHttp(hostname, port, path, headers = {}) {
        return new Promise((resolve, reject) => {
            const options = {
                headers: Object.assign(Object.assign({}, headers), { "User-Agent": this.userAgent }),
                hostname,
                method: "GET",
                path,
                port,
            };
            const req = http.request(options, (resp) => {
                if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                    reject({ message: `Failed to get ${path}: ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
                }
                else {
                    const chunks = [];
                    resp.on("data", (b) => chunks.push(b.toString()));
                    resp.on("end", () => {
                        const data = chunks.join("");
                        resolve(data);
                    });
                }
            });
            req.end();
        });
    }
}
exports.WebClient = WebClient;


/***/ }),

/***/ 2241:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated file - do not edit.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flutterCSSColors = exports.flutterCupertinoColors = exports.flutterMaterialColors = void 0;
// tslint:disable: object-literal-sort-keys
exports.flutterMaterialColors = {
    "amber.primary": "ffffc107",
    "amber[50]": "fffff8e1",
    "amber[100]": "ffffecb3",
    "amber[200]": "ffffe082",
    "amber[300]": "ffffd54f",
    "amber[400]": "ffffca28",
    "amber[500]": "ffffc107",
    "amber[600]": "ffffb300",
    "amber[700]": "ffffa000",
    "amber[800]": "ffff8f00",
    "amber[900]": "ffff6f00",
    "amberAccent.primary": "ffffd740",
    "amberAccent[100]": "ffffe57f",
    "amberAccent[200]": "ffffd740",
    "amberAccent[400]": "ffffc400",
    "amberAccent[700]": "ffffab00",
    "black": "ff000000",
    "black12": "1f000000",
    "black26": "42000000",
    "black38": "61000000",
    "black45": "73000000",
    "black54": "8a000000",
    "black87": "dd000000",
    "blue.primary": "ff2196f3",
    "blue[50]": "ffe3f2fd",
    "blue[100]": "ffbbdefb",
    "blue[200]": "ff90caf9",
    "blue[300]": "ff64b5f6",
    "blue[400]": "ff42a5f5",
    "blue[500]": "ff2196f3",
    "blue[600]": "ff1e88e5",
    "blue[700]": "ff1976d2",
    "blue[800]": "ff1565c0",
    "blue[900]": "ff0d47a1",
    "blueAccent.primary": "ff448aff",
    "blueAccent[100]": "ff82b1ff",
    "blueAccent[200]": "ff448aff",
    "blueAccent[400]": "ff2979ff",
    "blueAccent[700]": "ff2962ff",
    "blueGrey.primary": "ff607d8b",
    "blueGrey[50]": "ffeceff1",
    "blueGrey[100]": "ffcfd8dc",
    "blueGrey[200]": "ffb0bec5",
    "blueGrey[300]": "ff90a4ae",
    "blueGrey[400]": "ff78909c",
    "blueGrey[500]": "ff607d8b",
    "blueGrey[600]": "ff546e7a",
    "blueGrey[700]": "ff455a64",
    "blueGrey[800]": "ff37474f",
    "blueGrey[900]": "ff263238",
    "brown.primary": "ff795548",
    "brown[50]": "ffefebe9",
    "brown[100]": "ffd7ccc8",
    "brown[200]": "ffbcaaa4",
    "brown[300]": "ffa1887f",
    "brown[400]": "ff8d6e63",
    "brown[500]": "ff795548",
    "brown[600]": "ff6d4c41",
    "brown[700]": "ff5d4037",
    "brown[800]": "ff4e342e",
    "brown[900]": "ff3e2723",
    "cyan.primary": "ff00bcd4",
    "cyan[50]": "ffe0f7fa",
    "cyan[100]": "ffb2ebf2",
    "cyan[200]": "ff80deea",
    "cyan[300]": "ff4dd0e1",
    "cyan[400]": "ff26c6da",
    "cyan[500]": "ff00bcd4",
    "cyan[600]": "ff00acc1",
    "cyan[700]": "ff0097a7",
    "cyan[800]": "ff00838f",
    "cyan[900]": "ff006064",
    "cyanAccent.primary": "ff18ffff",
    "cyanAccent[100]": "ff84ffff",
    "cyanAccent[200]": "ff18ffff",
    "cyanAccent[400]": "ff00e5ff",
    "cyanAccent[700]": "ff00b8d4",
    "deepOrange.primary": "ffff5722",
    "deepOrange[50]": "fffbe9e7",
    "deepOrange[100]": "ffffccbc",
    "deepOrange[200]": "ffffab91",
    "deepOrange[300]": "ffff8a65",
    "deepOrange[400]": "ffff7043",
    "deepOrange[500]": "ffff5722",
    "deepOrange[600]": "fff4511e",
    "deepOrange[700]": "ffe64a19",
    "deepOrange[800]": "ffd84315",
    "deepOrange[900]": "ffbf360c",
    "deepOrangeAccent.primary": "ffff6e40",
    "deepOrangeAccent[100]": "ffff9e80",
    "deepOrangeAccent[200]": "ffff6e40",
    "deepOrangeAccent[400]": "ffff3d00",
    "deepOrangeAccent[700]": "ffdd2c00",
    "deepPurple.primary": "ff673ab7",
    "deepPurple[50]": "ffede7f6",
    "deepPurple[100]": "ffd1c4e9",
    "deepPurple[200]": "ffb39ddb",
    "deepPurple[300]": "ff9575cd",
    "deepPurple[400]": "ff7e57c2",
    "deepPurple[500]": "ff673ab7",
    "deepPurple[600]": "ff5e35b1",
    "deepPurple[700]": "ff512da8",
    "deepPurple[800]": "ff4527a0",
    "deepPurple[900]": "ff311b92",
    "deepPurpleAccent.primary": "ff7c4dff",
    "deepPurpleAccent[100]": "ffb388ff",
    "deepPurpleAccent[200]": "ff7c4dff",
    "deepPurpleAccent[400]": "ff651fff",
    "deepPurpleAccent[700]": "ff6200ea",
    "green.primary": "ff4caf50",
    "green[50]": "ffe8f5e9",
    "green[100]": "ffc8e6c9",
    "green[200]": "ffa5d6a7",
    "green[300]": "ff81c784",
    "green[400]": "ff66bb6a",
    "green[500]": "ff4caf50",
    "green[600]": "ff43a047",
    "green[700]": "ff388e3c",
    "green[800]": "ff2e7d32",
    "green[900]": "ff1b5e20",
    "greenAccent.primary": "ff69f0ae",
    "greenAccent[100]": "ffb9f6ca",
    "greenAccent[200]": "ff69f0ae",
    "greenAccent[400]": "ff00e676",
    "greenAccent[700]": "ff00c853",
    "grey.primary": "ff9e9e9e",
    "grey[50]": "fffafafa",
    "grey[100]": "fff5f5f5",
    "grey[200]": "ffeeeeee",
    "grey[300]": "ffe0e0e0",
    "grey[350]": "ffd6d6d6",
    "grey[400]": "ffbdbdbd",
    "grey[500]": "ff9e9e9e",
    "grey[600]": "ff757575",
    "grey[700]": "ff616161",
    "grey[800]": "ff424242",
    "grey[850]": "ff303030",
    "grey[900]": "ff212121",
    "indigo.primary": "ff3f51b5",
    "indigo[50]": "ffe8eaf6",
    "indigo[100]": "ffc5cae9",
    "indigo[200]": "ff9fa8da",
    "indigo[300]": "ff7986cb",
    "indigo[400]": "ff5c6bc0",
    "indigo[500]": "ff3f51b5",
    "indigo[600]": "ff3949ab",
    "indigo[700]": "ff303f9f",
    "indigo[800]": "ff283593",
    "indigo[900]": "ff1a237e",
    "indigoAccent.primary": "ff536dfe",
    "indigoAccent[100]": "ff8c9eff",
    "indigoAccent[200]": "ff536dfe",
    "indigoAccent[400]": "ff3d5afe",
    "indigoAccent[700]": "ff304ffe",
    "lightBlue.primary": "ff03a9f4",
    "lightBlue[50]": "ffe1f5fe",
    "lightBlue[100]": "ffb3e5fc",
    "lightBlue[200]": "ff81d4fa",
    "lightBlue[300]": "ff4fc3f7",
    "lightBlue[400]": "ff29b6f6",
    "lightBlue[500]": "ff03a9f4",
    "lightBlue[600]": "ff039be5",
    "lightBlue[700]": "ff0288d1",
    "lightBlue[800]": "ff0277bd",
    "lightBlue[900]": "ff01579b",
    "lightBlueAccent.primary": "ff40c4ff",
    "lightBlueAccent[100]": "ff80d8ff",
    "lightBlueAccent[200]": "ff40c4ff",
    "lightBlueAccent[400]": "ff00b0ff",
    "lightBlueAccent[700]": "ff0091ea",
    "lightGreen.primary": "ff8bc34a",
    "lightGreen[50]": "fff1f8e9",
    "lightGreen[100]": "ffdcedc8",
    "lightGreen[200]": "ffc5e1a5",
    "lightGreen[300]": "ffaed581",
    "lightGreen[400]": "ff9ccc65",
    "lightGreen[500]": "ff8bc34a",
    "lightGreen[600]": "ff7cb342",
    "lightGreen[700]": "ff689f38",
    "lightGreen[800]": "ff558b2f",
    "lightGreen[900]": "ff33691e",
    "lightGreenAccent.primary": "ffb2ff59",
    "lightGreenAccent[100]": "ffccff90",
    "lightGreenAccent[200]": "ffb2ff59",
    "lightGreenAccent[400]": "ff76ff03",
    "lightGreenAccent[700]": "ff64dd17",
    "lime.primary": "ffcddc39",
    "lime[50]": "fff9fbe7",
    "lime[100]": "fff0f4c3",
    "lime[200]": "ffe6ee9c",
    "lime[300]": "ffdce775",
    "lime[400]": "ffd4e157",
    "lime[500]": "ffcddc39",
    "lime[600]": "ffc0ca33",
    "lime[700]": "ffafb42b",
    "lime[800]": "ff9e9d24",
    "lime[900]": "ff827717",
    "limeAccent.primary": "ffeeff41",
    "limeAccent[100]": "fff4ff81",
    "limeAccent[200]": "ffeeff41",
    "limeAccent[400]": "ffc6ff00",
    "limeAccent[700]": "ffaeea00",
    "orange.primary": "ffff9800",
    "orange[50]": "fffff3e0",
    "orange[100]": "ffffe0b2",
    "orange[200]": "ffffcc80",
    "orange[300]": "ffffb74d",
    "orange[400]": "ffffa726",
    "orange[500]": "ffff9800",
    "orange[600]": "fffb8c00",
    "orange[700]": "fff57c00",
    "orange[800]": "ffef6c00",
    "orange[900]": "ffe65100",
    "orangeAccent.primary": "ffffab40",
    "orangeAccent[100]": "ffffd180",
    "orangeAccent[200]": "ffffab40",
    "orangeAccent[400]": "ffff9100",
    "orangeAccent[700]": "ffff6d00",
    "pink.primary": "ffe91e63",
    "pink[50]": "fffce4ec",
    "pink[100]": "fff8bbd0",
    "pink[200]": "fff48fb1",
    "pink[300]": "fff06292",
    "pink[400]": "ffec407a",
    "pink[500]": "ffe91e63",
    "pink[600]": "ffd81b60",
    "pink[700]": "ffc2185b",
    "pink[800]": "ffad1457",
    "pink[900]": "ff880e4f",
    "pinkAccent.primary": "ffff4081",
    "pinkAccent[100]": "ffff80ab",
    "pinkAccent[200]": "ffff4081",
    "pinkAccent[400]": "fff50057",
    "pinkAccent[700]": "ffc51162",
    "purple.primary": "ff9c27b0",
    "purple[50]": "fff3e5f5",
    "purple[100]": "ffe1bee7",
    "purple[200]": "ffce93d8",
    "purple[300]": "ffba68c8",
    "purple[400]": "ffab47bc",
    "purple[500]": "ff9c27b0",
    "purple[600]": "ff8e24aa",
    "purple[700]": "ff7b1fa2",
    "purple[800]": "ff6a1b9a",
    "purple[900]": "ff4a148c",
    "purpleAccent.primary": "ffe040fb",
    "purpleAccent[100]": "ffea80fc",
    "purpleAccent[200]": "ffe040fb",
    "purpleAccent[400]": "ffd500f9",
    "purpleAccent[700]": "ffaa00ff",
    "red.primary": "fff44336",
    "red[50]": "ffffebee",
    "red[100]": "ffffcdd2",
    "red[200]": "ffef9a9a",
    "red[300]": "ffe57373",
    "red[400]": "ffef5350",
    "red[500]": "fff44336",
    "red[600]": "ffe53935",
    "red[700]": "ffd32f2f",
    "red[800]": "ffc62828",
    "red[900]": "ffb71c1c",
    "redAccent.primary": "ffff5252",
    "redAccent[100]": "ffff8a80",
    "redAccent[200]": "ffff5252",
    "redAccent[400]": "ffff1744",
    "redAccent[700]": "ffd50000",
    "teal.primary": "ff009688",
    "teal[50]": "ffe0f2f1",
    "teal[100]": "ffb2dfdb",
    "teal[200]": "ff80cbc4",
    "teal[300]": "ff4db6ac",
    "teal[400]": "ff26a69a",
    "teal[500]": "ff009688",
    "teal[600]": "ff00897b",
    "teal[700]": "ff00796b",
    "teal[800]": "ff00695c",
    "teal[900]": "ff004d40",
    "tealAccent.primary": "ff64ffda",
    "tealAccent[100]": "ffa7ffeb",
    "tealAccent[200]": "ff64ffda",
    "tealAccent[400]": "ff1de9b6",
    "tealAccent[700]": "ff00bfa5",
    "transparent": "00000000",
    "white": "ffffffff",
    "white10": "1affffff",
    "white12": "1fffffff",
    "white24": "3dffffff",
    "white30": "4dffffff",
    "white38": "62ffffff",
    "white54": "8affffff",
    "white60": "99ffffff",
    "white70": "b3ffffff",
    "yellow.primary": "ffffeb3b",
    "yellow[50]": "fffffde7",
    "yellow[100]": "fffff9c4",
    "yellow[200]": "fffff59d",
    "yellow[300]": "fffff176",
    "yellow[400]": "ffffee58",
    "yellow[500]": "ffffeb3b",
    "yellow[600]": "fffdd835",
    "yellow[700]": "fffbc02d",
    "yellow[800]": "fff9a825",
    "yellow[900]": "fff57f17",
    "yellowAccent.primary": "ffffff00",
    "yellowAccent[100]": "ffffff8d",
    "yellowAccent[200]": "ffffff00",
    "yellowAccent[400]": "ffffea00",
    "yellowAccent[700]": "ffffd600",
};
exports.flutterCupertinoColors = {
    "activeBlue": "ff007aff",
    "activeBlue.darkColor": "ff0a84ff",
    "activeBlue.darkElevatedColor": "ff0a84ff",
    "activeBlue.darkHighContrastColor": "ff409cff",
    "activeBlue.darkHighContrastElevatedColor": "ff409cff",
    "activeBlue.elevatedColor": "ff007aff",
    "activeBlue.highContrastColor": "ff0040dd",
    "activeBlue.highContrastElevatedColor": "ff0040dd",
    "activeGreen": "ff34c759",
    "activeGreen.darkColor": "ff30d158",
    "activeGreen.darkElevatedColor": "ff30d158",
    "activeGreen.darkHighContrastColor": "ff30db5b",
    "activeGreen.darkHighContrastElevatedColor": "ff30db5b",
    "activeGreen.elevatedColor": "ff34c759",
    "activeGreen.highContrastColor": "ff248a3d",
    "activeGreen.highContrastElevatedColor": "ff248a3d",
    "activeOrange": "ffff9500",
    "activeOrange.darkColor": "ffff9f0a",
    "activeOrange.darkElevatedColor": "ffff9f0a",
    "activeOrange.darkHighContrastColor": "ffffb340",
    "activeOrange.darkHighContrastElevatedColor": "ffffb340",
    "activeOrange.elevatedColor": "ffff9500",
    "activeOrange.highContrastColor": "ffc93400",
    "activeOrange.highContrastElevatedColor": "ffc93400",
    "black": "ff000000",
    "darkBackgroundGray": "ff171717",
    "destructiveRed": "ffff3b30",
    "destructiveRed.darkColor": "ffff453a",
    "destructiveRed.darkElevatedColor": "ffff453a",
    "destructiveRed.darkHighContrastColor": "ffff6961",
    "destructiveRed.darkHighContrastElevatedColor": "ffff6961",
    "destructiveRed.elevatedColor": "ffff3b30",
    "destructiveRed.highContrastColor": "ffd70015",
    "destructiveRed.highContrastElevatedColor": "ffd70015",
    "extraLightBackgroundGray": "ffefeff4",
    "inactiveGray": "ff999999",
    "inactiveGray.darkColor": "ff757575",
    "inactiveGray.darkElevatedColor": "ff757575",
    "inactiveGray.darkHighContrastColor": "ff757575",
    "inactiveGray.darkHighContrastElevatedColor": "ff757575",
    "inactiveGray.elevatedColor": "ff999999",
    "inactiveGray.highContrastColor": "ff999999",
    "inactiveGray.highContrastElevatedColor": "ff999999",
    "label": "ff000000",
    "label.darkColor": "ffffffff",
    "label.darkElevatedColor": "ffffffff",
    "label.darkHighContrastColor": "ffffffff",
    "label.darkHighContrastElevatedColor": "ffffffff",
    "label.elevatedColor": "ff000000",
    "label.highContrastColor": "ff000000",
    "label.highContrastElevatedColor": "ff000000",
    "lightBackgroundGray": "ffe5e5ea",
    "link": "ff007aff",
    "link.darkColor": "ff0984ff",
    "link.darkElevatedColor": "ff0984ff",
    "link.darkHighContrastColor": "ff0984ff",
    "link.darkHighContrastElevatedColor": "ff0984ff",
    "link.elevatedColor": "ff007aff",
    "link.highContrastColor": "ff007aff",
    "link.highContrastElevatedColor": "ff007aff",
    "opaqueSeparator": "ffc6c6c8",
    "opaqueSeparator.darkColor": "ff38383a",
    "opaqueSeparator.darkElevatedColor": "ff38383a",
    "opaqueSeparator.darkHighContrastColor": "ff38383a",
    "opaqueSeparator.darkHighContrastElevatedColor": "ff38383a",
    "opaqueSeparator.elevatedColor": "ffc6c6c8",
    "opaqueSeparator.highContrastColor": "ffc6c6c8",
    "opaqueSeparator.highContrastElevatedColor": "ffc6c6c8",
    "placeholderText": "4c3c3c43",
    "placeholderText.darkColor": "4cebebf5",
    "placeholderText.darkElevatedColor": "4cebebf5",
    "placeholderText.darkHighContrastColor": "60ebebf5",
    "placeholderText.darkHighContrastElevatedColor": "60ebebf5",
    "placeholderText.elevatedColor": "4c3c3c43",
    "placeholderText.highContrastColor": "603c3c43",
    "placeholderText.highContrastElevatedColor": "603c3c43",
    "quaternaryLabel": "2d3c3c43",
    "quaternaryLabel.darkColor": "28ebebf5",
    "quaternaryLabel.darkElevatedColor": "28ebebf5",
    "quaternaryLabel.darkHighContrastColor": "3debebf5",
    "quaternaryLabel.darkHighContrastElevatedColor": "3debebf5",
    "quaternaryLabel.elevatedColor": "2d3c3c43",
    "quaternaryLabel.highContrastColor": "423c3c43",
    "quaternaryLabel.highContrastElevatedColor": "423c3c43",
    "quaternarySystemFill": "14747480",
    "quaternarySystemFill.darkColor": "2d767680",
    "quaternarySystemFill.darkElevatedColor": "2d767680",
    "quaternarySystemFill.darkHighContrastColor": "42767680",
    "quaternarySystemFill.darkHighContrastElevatedColor": "42767680",
    "quaternarySystemFill.elevatedColor": "14747480",
    "quaternarySystemFill.highContrastColor": "28747480",
    "quaternarySystemFill.highContrastElevatedColor": "28747480",
    "secondaryLabel": "993c3c43",
    "secondaryLabel.darkColor": "99ebebf5",
    "secondaryLabel.darkElevatedColor": "99ebebf5",
    "secondaryLabel.darkHighContrastColor": "adebebf5",
    "secondaryLabel.darkHighContrastElevatedColor": "adebebf5",
    "secondaryLabel.elevatedColor": "993c3c43",
    "secondaryLabel.highContrastColor": "ad3c3c43",
    "secondaryLabel.highContrastElevatedColor": "ad3c3c43",
    "secondarySystemBackground": "fff2f2f7",
    "secondarySystemBackground.darkColor": "ff1c1c1e",
    "secondarySystemBackground.darkElevatedColor": "ff2c2c2e",
    "secondarySystemBackground.darkHighContrastColor": "ff242426",
    "secondarySystemBackground.darkHighContrastElevatedColor": "ff363638",
    "secondarySystemBackground.elevatedColor": "fff2f2f7",
    "secondarySystemBackground.highContrastColor": "ffebebf0",
    "secondarySystemBackground.highContrastElevatedColor": "ffebebf0",
    "secondarySystemFill": "28787880",
    "secondarySystemFill.darkColor": "51787880",
    "secondarySystemFill.darkElevatedColor": "51787880",
    "secondarySystemFill.darkHighContrastColor": "66787880",
    "secondarySystemFill.darkHighContrastElevatedColor": "66787880",
    "secondarySystemFill.elevatedColor": "28787880",
    "secondarySystemFill.highContrastColor": "3d787880",
    "secondarySystemFill.highContrastElevatedColor": "3d787880",
    "secondarySystemGroupedBackground": "ffffffff",
    "secondarySystemGroupedBackground.darkColor": "ff1c1c1e",
    "secondarySystemGroupedBackground.darkElevatedColor": "ff2c2c2e",
    "secondarySystemGroupedBackground.darkHighContrastColor": "ff242426",
    "secondarySystemGroupedBackground.darkHighContrastElevatedColor": "ff363638",
    "secondarySystemGroupedBackground.elevatedColor": "ffffffff",
    "secondarySystemGroupedBackground.highContrastColor": "ffffffff",
    "secondarySystemGroupedBackground.highContrastElevatedColor": "ffffffff",
    "separator": "493c3c43",
    "separator.darkColor": "99545458",
    "separator.darkElevatedColor": "99545458",
    "separator.darkHighContrastColor": "ad545458",
    "separator.darkHighContrastElevatedColor": "ad545458",
    "separator.elevatedColor": "493c3c43",
    "separator.highContrastColor": "5e3c3c43",
    "separator.highContrastElevatedColor": "5e3c3c43",
    "systemBackground": "ffffffff",
    "systemBackground.darkColor": "ff000000",
    "systemBackground.darkElevatedColor": "ff1c1c1e",
    "systemBackground.darkHighContrastColor": "ff000000",
    "systemBackground.darkHighContrastElevatedColor": "ff242426",
    "systemBackground.elevatedColor": "ffffffff",
    "systemBackground.highContrastColor": "ffffffff",
    "systemBackground.highContrastElevatedColor": "ffffffff",
    "systemBlue": "ff007aff",
    "systemBlue.darkColor": "ff0a84ff",
    "systemBlue.darkElevatedColor": "ff0a84ff",
    "systemBlue.darkHighContrastColor": "ff409cff",
    "systemBlue.darkHighContrastElevatedColor": "ff409cff",
    "systemBlue.elevatedColor": "ff007aff",
    "systemBlue.highContrastColor": "ff0040dd",
    "systemBlue.highContrastElevatedColor": "ff0040dd",
    "systemFill": "33787880",
    "systemFill.darkColor": "5b787880",
    "systemFill.darkElevatedColor": "5b787880",
    "systemFill.darkHighContrastColor": "70787880",
    "systemFill.darkHighContrastElevatedColor": "70787880",
    "systemFill.elevatedColor": "33787880",
    "systemFill.highContrastColor": "47787880",
    "systemFill.highContrastElevatedColor": "47787880",
    "systemGreen": "ff34c759",
    "systemGreen.darkColor": "ff30d158",
    "systemGreen.darkElevatedColor": "ff30d158",
    "systemGreen.darkHighContrastColor": "ff30db5b",
    "systemGreen.darkHighContrastElevatedColor": "ff30db5b",
    "systemGreen.elevatedColor": "ff34c759",
    "systemGreen.highContrastColor": "ff248a3d",
    "systemGreen.highContrastElevatedColor": "ff248a3d",
    "systemGrey": "ff8e8e93",
    "systemGrey.darkColor": "ff8e8e93",
    "systemGrey.darkElevatedColor": "ff8e8e93",
    "systemGrey.darkHighContrastColor": "ffaeaeb2",
    "systemGrey.darkHighContrastElevatedColor": "ffaeaeb2",
    "systemGrey.elevatedColor": "ff8e8e93",
    "systemGrey.highContrastColor": "ff6c6c70",
    "systemGrey.highContrastElevatedColor": "ff6c6c70",
    "systemGrey2": "ffaeaeb2",
    "systemGrey2.darkColor": "ff636366",
    "systemGrey2.darkElevatedColor": "ff636366",
    "systemGrey2.darkHighContrastColor": "ff7c7c80",
    "systemGrey2.darkHighContrastElevatedColor": "ff7c7c80",
    "systemGrey2.elevatedColor": "ffaeaeb2",
    "systemGrey2.highContrastColor": "ff8e8e93",
    "systemGrey2.highContrastElevatedColor": "ff8e8e93",
    "systemGrey3": "ffc7c7cc",
    "systemGrey3.darkColor": "ff48484a",
    "systemGrey3.darkElevatedColor": "ff48484a",
    "systemGrey3.darkHighContrastColor": "ff545456",
    "systemGrey3.darkHighContrastElevatedColor": "ff545456",
    "systemGrey3.elevatedColor": "ffc7c7cc",
    "systemGrey3.highContrastColor": "ffaeaeb2",
    "systemGrey3.highContrastElevatedColor": "ffaeaeb2",
    "systemGrey4": "ffd1d1d6",
    "systemGrey4.darkColor": "ff3a3a3c",
    "systemGrey4.darkElevatedColor": "ff3a3a3c",
    "systemGrey4.darkHighContrastColor": "ff444446",
    "systemGrey4.darkHighContrastElevatedColor": "ff444446",
    "systemGrey4.elevatedColor": "ffd1d1d6",
    "systemGrey4.highContrastColor": "ffbcbcc0",
    "systemGrey4.highContrastElevatedColor": "ffbcbcc0",
    "systemGrey5": "ffe5e5ea",
    "systemGrey5.darkColor": "ff2c2c2e",
    "systemGrey5.darkElevatedColor": "ff2c2c2e",
    "systemGrey5.darkHighContrastColor": "ff363638",
    "systemGrey5.darkHighContrastElevatedColor": "ff363638",
    "systemGrey5.elevatedColor": "ffe5e5ea",
    "systemGrey5.highContrastColor": "ffd8d8dc",
    "systemGrey5.highContrastElevatedColor": "ffd8d8dc",
    "systemGrey6": "fff2f2f7",
    "systemGrey6.darkColor": "ff1c1c1e",
    "systemGrey6.darkElevatedColor": "ff1c1c1e",
    "systemGrey6.darkHighContrastColor": "ff242426",
    "systemGrey6.darkHighContrastElevatedColor": "ff242426",
    "systemGrey6.elevatedColor": "fff2f2f7",
    "systemGrey6.highContrastColor": "ffebebf0",
    "systemGrey6.highContrastElevatedColor": "ffebebf0",
    "systemGroupedBackground": "fff2f2f7",
    "systemGroupedBackground.darkColor": "ff000000",
    "systemGroupedBackground.darkElevatedColor": "ff1c1c1e",
    "systemGroupedBackground.darkHighContrastColor": "ff000000",
    "systemGroupedBackground.darkHighContrastElevatedColor": "ff242426",
    "systemGroupedBackground.elevatedColor": "fff2f2f7",
    "systemGroupedBackground.highContrastColor": "ffebebf0",
    "systemGroupedBackground.highContrastElevatedColor": "ffebebf0",
    "systemIndigo": "ff5856d6",
    "systemIndigo.darkColor": "ff5e5ce6",
    "systemIndigo.darkElevatedColor": "ff5e5ce6",
    "systemIndigo.darkHighContrastColor": "ff7d7aff",
    "systemIndigo.darkHighContrastElevatedColor": "ff7d7aff",
    "systemIndigo.elevatedColor": "ff5856d6",
    "systemIndigo.highContrastColor": "ff3634a3",
    "systemIndigo.highContrastElevatedColor": "ff3634a3",
    "systemOrange": "ffff9500",
    "systemOrange.darkColor": "ffff9f0a",
    "systemOrange.darkElevatedColor": "ffff9f0a",
    "systemOrange.darkHighContrastColor": "ffffb340",
    "systemOrange.darkHighContrastElevatedColor": "ffffb340",
    "systemOrange.elevatedColor": "ffff9500",
    "systemOrange.highContrastColor": "ffc93400",
    "systemOrange.highContrastElevatedColor": "ffc93400",
    "systemPink": "ffff2d55",
    "systemPink.darkColor": "ffff375f",
    "systemPink.darkElevatedColor": "ffff375f",
    "systemPink.darkHighContrastColor": "ffff6482",
    "systemPink.darkHighContrastElevatedColor": "ffff6482",
    "systemPink.elevatedColor": "ffff2d55",
    "systemPink.highContrastColor": "ffd30f45",
    "systemPink.highContrastElevatedColor": "ffd30f45",
    "systemPurple": "ffaf52de",
    "systemPurple.darkColor": "ffbf5af2",
    "systemPurple.darkElevatedColor": "ffbf5af2",
    "systemPurple.darkHighContrastColor": "ffda8fff",
    "systemPurple.darkHighContrastElevatedColor": "ffda8fff",
    "systemPurple.elevatedColor": "ffaf52de",
    "systemPurple.highContrastColor": "ff8944ab",
    "systemPurple.highContrastElevatedColor": "ff8944ab",
    "systemRed": "ffff3b30",
    "systemRed.darkColor": "ffff453a",
    "systemRed.darkElevatedColor": "ffff453a",
    "systemRed.darkHighContrastColor": "ffff6961",
    "systemRed.darkHighContrastElevatedColor": "ffff6961",
    "systemRed.elevatedColor": "ffff3b30",
    "systemRed.highContrastColor": "ffd70015",
    "systemRed.highContrastElevatedColor": "ffd70015",
    "systemTeal": "ff5ac8fa",
    "systemTeal.darkColor": "ff64d2ff",
    "systemTeal.darkElevatedColor": "ff64d2ff",
    "systemTeal.darkHighContrastColor": "ff70d7ff",
    "systemTeal.darkHighContrastElevatedColor": "ff70d7ff",
    "systemTeal.elevatedColor": "ff5ac8fa",
    "systemTeal.highContrastColor": "ff0071a4",
    "systemTeal.highContrastElevatedColor": "ff0071a4",
    "systemYellow": "ffffcc00",
    "systemYellow.darkColor": "ffffd60a",
    "systemYellow.darkElevatedColor": "ffffd60a",
    "systemYellow.darkHighContrastColor": "ffffd426",
    "systemYellow.darkHighContrastElevatedColor": "ffffd426",
    "systemYellow.elevatedColor": "ffffcc00",
    "systemYellow.highContrastColor": "ffa05a00",
    "systemYellow.highContrastElevatedColor": "ffa05a00",
    "tertiaryLabel": "4c3c3c43",
    "tertiaryLabel.darkColor": "4cebebf5",
    "tertiaryLabel.darkElevatedColor": "4cebebf5",
    "tertiaryLabel.darkHighContrastColor": "60ebebf5",
    "tertiaryLabel.darkHighContrastElevatedColor": "60ebebf5",
    "tertiaryLabel.elevatedColor": "4c3c3c43",
    "tertiaryLabel.highContrastColor": "603c3c43",
    "tertiaryLabel.highContrastElevatedColor": "603c3c43",
    "tertiarySystemBackground": "ffffffff",
    "tertiarySystemBackground.darkColor": "ff2c2c2e",
    "tertiarySystemBackground.darkElevatedColor": "ff3a3a3c",
    "tertiarySystemBackground.darkHighContrastColor": "ff363638",
    "tertiarySystemBackground.darkHighContrastElevatedColor": "ff444446",
    "tertiarySystemBackground.elevatedColor": "ffffffff",
    "tertiarySystemBackground.highContrastColor": "ffffffff",
    "tertiarySystemBackground.highContrastElevatedColor": "ffffffff",
    "tertiarySystemFill": "1e767680",
    "tertiarySystemFill.darkColor": "3d767680",
    "tertiarySystemFill.darkElevatedColor": "3d767680",
    "tertiarySystemFill.darkHighContrastColor": "51767680",
    "tertiarySystemFill.darkHighContrastElevatedColor": "51767680",
    "tertiarySystemFill.elevatedColor": "1e767680",
    "tertiarySystemFill.highContrastColor": "33767680",
    "tertiarySystemFill.highContrastElevatedColor": "33767680",
    "tertiarySystemGroupedBackground": "fff2f2f7",
    "tertiarySystemGroupedBackground.darkColor": "ff2c2c2e",
    "tertiarySystemGroupedBackground.darkElevatedColor": "ff3a3a3c",
    "tertiarySystemGroupedBackground.darkHighContrastColor": "ff363638",
    "tertiarySystemGroupedBackground.darkHighContrastElevatedColor": "ff444446",
    "tertiarySystemGroupedBackground.elevatedColor": "fff2f2f7",
    "tertiarySystemGroupedBackground.highContrastColor": "ffebebf0",
    "tertiarySystemGroupedBackground.highContrastElevatedColor": "ffebebf0",
    "white": "ffffffff",
};
exports.flutterCSSColors = {
    "aliceBlue": "fff0f8ff",
    "antiqueWhite": "fffaebd7",
    "aqua": "ff00ffff",
    "aquamarine": "ff7fffd4",
    "azure": "fff0ffff",
    "beige": "fff5f5dc",
    "bisque": "ffffe4c4",
    "black": "ff000000",
    "blanchedAlmond": "ffffebcd",
    "blue": "ff0000ff",
    "blueViolet": "ff8a2be2",
    "brown": "ffa52a2a",
    "burlyWood": "ffdeb887",
    "cadetBlue": "ff5f9ea0",
    "chartreuse": "ff7fff00",
    "chocolate": "ffd2691e",
    "coral": "ffff7f50",
    "cornflowerBlue": "ff6495ed",
    "cornsilk": "fffff8dc",
    "crimson": "ffdc143c",
    "cyan": "ff00ffff",
    "darkBlue": "ff00008b",
    "darkCyan": "ff008b8b",
    "darkGoldenRod": "ffb8860b",
    "darkGray": "ffa9a9a9",
    "darkGreen": "ff006400",
    "darkGrey": "ffa9a9a9",
    "darkKhaki": "ffbdb76b",
    "darkMagenta": "ff8b008b",
    "darkOliveGreen": "ff556b2f",
    "darkOrange": "ffff8c00",
    "darkOrchid": "ff9932cc",
    "darkRed": "ff8b0000",
    "darkSalmon": "ffe9967a",
    "darkSeaGreen": "ff8fbc8f",
    "darkSlateBlue": "ff483d8b",
    "darkSlateGray": "ff2f4f4f",
    "darkSlateGrey": "ff2f4f4f",
    "darkTurquoise": "ff00ced1",
    "darkViolet": "ff9400d3",
    "deepPink": "ffff1493",
    "deepSkyBlue": "ff00bfff",
    "dimGray": "ff696969",
    "dimGrey": "ff696969",
    "dodgerBlue": "ff1e90ff",
    "fireBrick": "ffb22222",
    "floralWhite": "fffffaf0",
    "forestGreen": "ff228b22",
    "fuchsia": "ffff00ff",
    "gainsboro": "ffdcdcdc",
    "ghostWhite": "fff8f8ff",
    "gold": "ffffd700",
    "goldenRod": "ffdaa520",
    "gray": "ff808080",
    "green": "ff008000",
    "greenYellow": "ffadff2f",
    "grey": "ff808080",
    "honeyDew": "fff0fff0",
    "hotPink": "ffff69b4",
    "indianRed": "ffcd5c5c",
    "indigo": "ff4b0082",
    "ivory": "fffffff0",
    "khaki": "fff0e68c",
    "lavender": "ffe6e6fa",
    "lavenderBlush": "fffff0f5",
    "lawnGreen": "ff7cfc00",
    "lemonChiffon": "fffffacd",
    "lightBlue": "ffadd8e6",
    "lightCoral": "fff08080",
    "lightCyan": "ffe0ffff",
    "lightGoldenRodYellow": "fffafad2",
    "lightGray": "ffd3d3d3",
    "lightGreen": "ff90ee90",
    "lightGrey": "ffd3d3d3",
    "lightPink": "ffffb6c1",
    "lightSalmon": "ffffa07a",
    "lightSeaGreen": "ff20b2aa",
    "lightSkyBlue": "ff87cefa",
    "lightSlateGray": "ff778899",
    "lightSlateGrey": "ff778899",
    "lightSteelBlue": "ffb0c4de",
    "lightYellow": "ffffffe0",
    "lime": "ff00ff00",
    "limeGreen": "ff32cd32",
    "linen": "fffaf0e6",
    "magenta": "ffff00ff",
    "maroon": "ff800000",
    "mediumAquaMarine": "ff66cdaa",
    "mediumBlue": "ff0000cd",
    "mediumOrchid": "ffba55d3",
    "mediumPurple": "ff9370db",
    "mediumSeaGreen": "ff3cb371",
    "mediumSlateBlue": "ff7b68ee",
    "mediumSpringGreen": "ff00fa9a",
    "mediumTurquoise": "ff48d1cc",
    "mediumVioletRed": "ffc71585",
    "midnightBlue": "ff191970",
    "mintCream": "fff5fffa",
    "mistyRose": "ffffe4e1",
    "moccasin": "ffffe4b5",
    "navajoWhite": "ffffdead",
    "navy": "ff000080",
    "oldLace": "fffdf5e6",
    "olive": "ff808000",
    "oliveDrab": "ff6b8e23",
    "orange": "ffffa500",
    "orangeRed": "ffff4500",
    "orchid": "ffda70d6",
    "paleGoldenRod": "ffeee8aa",
    "paleGreen": "ff98fb98",
    "paleTurquoise": "ffafeeee",
    "paleVioletRed": "ffdb7093",
    "papayaWhip": "ffffefd5",
    "peachPuff": "ffffdab9",
    "peru": "ffcd853f",
    "pink": "ffffc0cb",
    "plum": "ffdda0dd",
    "powderBlue": "ffb0e0e6",
    "purple": "ff800080",
    "rebeccaPurple": "ff663399",
    "red": "ffff0000",
    "rosyBrown": "ffbc8f8f",
    "royalBlue": "ff4169e1",
    "saddleBrown": "ff8b4513",
    "salmon": "fffa8072",
    "sandyBrown": "fff4a460",
    "seaGreen": "ff2e8b57",
    "seaShell": "fffff5ee",
    "sienna": "ffa0522d",
    "silver": "ffc0c0c0",
    "skyBlue": "ff87ceeb",
    "slateBlue": "ff6a5acd",
    "slateGray": "ff708090",
    "slateGrey": "ff708090",
    "snow": "fffffafa",
    "springGreen": "ff00ff7f",
    "steelBlue": "ff4682b4",
    "tan": "ffd2b48c",
    "teal": "ff008080",
    "thistle": "ffd8bfd8",
    "tomato": "ffff6347",
    "turquoise": "ff40e0d0",
    "violet": "ffee82ee",
    "wheat": "fff5deb3",
    "white": "ffffffff",
    "whiteSmoke": "fff5f5f5",
    "yellow": "ffffff00",
    "yellowGreen": "ff9acd32",
};


/***/ }),

/***/ 5820:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFutterWebRenderer = void 0;
function getFutterWebRenderer(flutterCapabilities, renderer) {
    if (!flutterCapabilities.supportsWebRendererOption)
        return;
    if (!renderer || renderer === "auto")
        return;
    return renderer;
}
exports.getFutterWebRenderer = getFutterWebRenderer;


/***/ }),

/***/ 8323:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RingLog = exports.captureLogs = exports.logToConsole = exports.logProcess = exports.nullLogger = exports.CategoryLogger = exports.EmittingLogger = void 0;
const events_1 = __webpack_require__(2361);
const fs = __webpack_require__(7147);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(4586);
class LogEmitter extends events_1.EventEmitter {
    fire(msg) {
        this.emit("log", msg);
    }
    onLog(listener) {
        this.on("log", listener);
        return {
            dispose: () => { this.removeListener("log", listener); },
        };
    }
}
class EmittingLogger {
    constructor() {
        this.onLogEmitter = new LogEmitter();
        this.onLog = (listener) => this.onLogEmitter.onLog(listener);
    }
    log(message, severity, category = enums_1.LogCategory.General) {
        this.onLogEmitter.fire(new LogMessageImpl(message, severity, category));
    }
    info(message, category) {
        this.log(message, enums_1.LogSeverity.Info, category);
    }
    warn(errorOrMessage, category) {
        this.log((0, utils_1.errorString)(errorOrMessage), enums_1.LogSeverity.Warn, category);
    }
    error(errorOrMessage, category) {
        this.log((0, utils_1.errorString)(errorOrMessage), enums_1.LogSeverity.Error, category);
    }
    dispose() {
        this.onLogEmitter.removeAllListeners();
    }
}
exports.EmittingLogger = EmittingLogger;
class LogMessageImpl {
    constructor(message, severity, category) {
        this.message = message;
        this.severity = severity;
        this.category = category;
    }
    toLine(maxLength) {
        const logMessage = (maxLength && this.message && this.message.length > maxLength
            ? this.message.substring(0, maxLength) + ""
            : (this.message || "<empty message>")).trimRight();
        const time = `[${(new Date()).toLocaleTimeString()}]`;
        const prefix = `[${enums_1.LogCategory[this.category]}] [${enums_1.LogSeverity[this.severity]}]`;
        return `${time} ${prefix} ${logMessage}`;
    }
}
class CategoryLogger {
    constructor(base, defaultCategory) {
        this.base = base;
        this.defaultCategory = defaultCategory;
    }
    info(message, category = this.defaultCategory) {
        this.base.info(message, category);
    }
    warn(errorOrMessage, category = this.defaultCategory) {
        this.base.warn(errorOrMessage, category);
    }
    error(errorOrMessage, category = this.defaultCategory) {
        this.base.error(errorOrMessage, category);
    }
}
exports.CategoryLogger = CategoryLogger;
class NullLogger {
    // tslint:disable-next-line: no-empty
    info(message, category) { }
    // tslint:disable-next-line: no-empty
    warn(message, category) { }
    // tslint:disable-next-line: no-empty
    error(error, category) { }
}
exports.nullLogger = new NullLogger();
function logProcess(logger, category, process) {
    const prefix = `(PROC ${process.pid})`;
    logger.info(`${prefix} Logging data for process...`, category);
    process.stdout.on("data", (data) => logger.info(`${prefix} ${data}`, category));
    process.stderr.on("data", (data) => logger.info(`${prefix} ${data}`, category));
    process.on("close", (code, signal) => logger.info(`${prefix} closed (${code}, ${signal})`, category));
    process.on("exit", (code, signal) => logger.info(`${prefix} exited (${code}, ${signal})`, category));
}
exports.logProcess = logProcess;
function logToConsole(logger) {
    return logger.onLog((m) => {
        if (m.severity === enums_1.LogSeverity.Error)
            console.error(m.toLine(1000));
        else if (m.severity === enums_1.LogSeverity.Warn)
            console.warn(m.toLine(1000));
    });
}
exports.logToConsole = logToConsole;
function captureLogs(logger, file, header, maxLogLineLength, logCategories, excludeLogCategories = false) {
    if (!file || !path.isAbsolute(file))
        throw new Error("Path passed to logTo must be an absolute path");
    const time = (detailed = false) => detailed ? `[${(new Date()).toTimeString()}] ` : `[${(new Date()).toLocaleTimeString()}] `;
    let logStream = fs.createWriteStream(file);
    if (header)
        logStream.write(header);
    const categoryNames = logCategories.map((c) => enums_1.LogCategory[c]);
    logStream.write(`Logging Categories:${constants_1.platformEol}    ${categoryNames.join(", ")}${constants_1.platformEol}${constants_1.platformEol}`);
    logStream.write(`${(new Date()).toDateString()} ${time(true)}Log file started${constants_1.platformEol}`);
    let fileLogger = logger.onLog((e) => {
        if (!logStream)
            return;
        // We should log this event if:
        // - We don't have a category filter; or
        // - The category filter includes this category; or
        // - The log is WARN/ERROR (they get logged everywhere).
        const shouldLog = (excludeLogCategories
            ? logCategories.indexOf(e.category) === -1
            : logCategories.indexOf(e.category) !== -1)
            || e.severity === enums_1.LogSeverity.Warn
            || e.severity === enums_1.LogSeverity.Error;
        if (!shouldLog)
            return;
        logStream.write(`${e.toLine(maxLogLineLength)}${os.EOL}`);
    });
    return {
        dispose() {
            if (fileLogger) {
                fileLogger.dispose();
                fileLogger = undefined;
            }
            return new Promise((resolve) => {
                if (logStream) {
                    logStream.write(`${(new Date()).toDateString()} ${time(true)}Log file ended${os.EOL}`);
                    logStream.end(resolve);
                    logStream = undefined;
                }
            });
        },
    };
}
exports.captureLogs = captureLogs;
class RingLog {
    constructor(size) {
        this.size = size;
        this.pointer = 0;
        this.lines = new Array(this.size);
    }
    get rawLines() { return this.lines; }
    log(message) {
        this.lines[this.pointer] = message;
        this.pointer = (this.pointer + 1) % this.size;
    }
    toString() {
        return this.lines.slice(this.pointer, this.size).concat(this.lines.slice(0, this.pointer)).filter((l) => l).join("\n");
    }
}
exports.RingLog = RingLog;


/***/ }),

/***/ 5837:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPubExecutionInfo = exports.runProcess = exports.RunProcessResult = exports.safeSpawn = void 0;
const child_process = __webpack_require__(2081);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
function safeSpawn(workingDirectory, binPath, args, env) {
    // Spawning processes on Windows with funny symbols in the path requires quoting. However if you quote an
    // executable with a space in its path and an argument also has a space, you have to then quote all of the
    // arguments too!\
    // https://github.com/nodejs/node/issues/7367
    const quotedArgs = args.map((a) => `"${a.replace(/"/g, `\\"`)}"`);
    const customEnv = Object.assign({}, process.env, env);
    return child_process.spawn(`"${binPath}"`, quotedArgs, { cwd: workingDirectory, env: customEnv, shell: true });
}
exports.safeSpawn = safeSpawn;
class RunProcessResult {
    constructor(exitCode, stdout, stderr) {
        this.exitCode = exitCode;
        this.stdout = stdout;
        this.stderr = stderr;
    }
}
exports.RunProcessResult = RunProcessResult;
function runProcess(logger, binPath, args, workingDirectory, env, spawn) {
    return new Promise((resolve) => {
        logger.info(`Spawning ${binPath} with args ${JSON.stringify(args)} in ${workingDirectory} with env ${JSON.stringify(env)}`);
        const proc = spawn(workingDirectory, binPath, args, env);
        (0, logging_1.logProcess)(logger, enums_1.LogCategory.CommandProcesses, proc);
        const out = [];
        const err = [];
        proc.stdout.on("data", (data) => out.push(data.toString()));
        proc.stderr.on("data", (data) => err.push(data.toString()));
        proc.on("exit", (code) => {
            resolve(new RunProcessResult((0, utils_1.nullToUndefined)(code), out.join(""), err.join("")));
        });
    });
}
exports.runProcess = runProcess;
function getPubExecutionInfo(dartCapabilities, dartSdkPath, args) {
    if (dartCapabilities.supportsDartPub) {
        return {
            args: ["pub", ...args],
            executable: path.join(dartSdkPath, constants_1.dartVMPath),
        };
    }
    else {
        return {
            args,
            executable: path.join(dartSdkPath, constants_1.pubPath),
        };
    }
}
exports.getPubExecutionInfo = getPubExecutionInfo;


/***/ }),

/***/ 8316:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PubApi = void 0;
class PubApi {
    constructor(webClient) {
        this.webClient = webClient;
        this.pubHost = process.env.PUB_HOSTED_URL || "https://pub.dev";
    }
    getPackage(packageID) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.get(`packages/${packageID}`);
        });
    }
    getPackageNames() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.get(`package-name-completion-data`);
        });
    }
    get(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {
                Accept: "application/vnd.pub.v2+json",
                "Accept-Encoding": "gzip",
            };
            const response = yield this.webClient.fetch(`${this.pubHost}/api/${url}`, headers);
            return JSON.parse(response);
        });
    }
}
exports.PubApi = PubApi;


/***/ }),

/***/ 2253:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PubDeps = void 0;
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const processes_1 = __webpack_require__(5837);
/// Interacts with "pub deps --json" to look up types of dependencies.
class PubDeps {
    constructor(logger, sdks, dartCapabilities) {
        this.logger = logger;
        this.sdks = sdks;
        this.dartCapabilities = dartCapabilities;
    }
    getRootDependency(projectDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.dartCapabilities.supportsPubDepsJson) {
                return undefined;
            }
            const binPath = this.sdks.flutter
                ? path.join(this.sdks.flutter, constants_1.flutterPath)
                : path.join(this.sdks.dart, constants_1.dartVMPath);
            const result = yield (0, processes_1.runProcess)(this.logger, binPath, ["pub", "deps", "--json"], projectDirectory, undefined, processes_1.safeSpawn);
            if (result.exitCode !== 0) {
                this.logger.error(`Running "pub deps --json" returned exit code ${result.exitCode}:\n${result.stdout}\n${result.stderr}`);
                return undefined;
            }
            try {
                return JSON.parse(result.stdout);
            }
            catch (e) {
                this.logger.error(`"pub deps --json" returned invalid JSON ${e}:\n${result.stdout}`);
                return undefined;
            }
        });
    }
    getPackageMap(root) {
        const packages = {};
        for (const p of root.packages) {
            packages[p.name] = p;
        }
        return packages;
    }
    computeShortestPaths(packageMap) {
        var _a, _b, _c, _d, _e;
        const results = {};
        const rootName = (_a = Object.values(packageMap).find((p) => p.kind === "root")) === null || _a === void 0 ? void 0 : _a.name;
        // Queue is a list of pairs of packages to process, and the paths to get to them.
        const queue = [];
        for (const name of Object.keys(packageMap)) {
            if (((_b = packageMap[name]) === null || _b === void 0 ? void 0 : _b.kind) === "direct" || ((_c = packageMap[name]) === null || _c === void 0 ? void 0 : _c.kind) === "dev") {
                const path = rootName ? [rootName, name] : [name];
                results[name] = path;
                queue.push([name, path]);
            }
        }
        // Traverse the tree breadth-first, so that the first time we come across any node, we know that is
        // the shortest path.
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let i = 0; i < queue.length; i++) {
            const [pkg, path] = queue[i];
            const dependencies = (_e = (_d = packageMap[pkg]) === null || _d === void 0 ? void 0 : _d.dependencies) !== null && _e !== void 0 ? _e : [];
            // Loop over this packages dependencies, and if we've not previously been to them
            // this is (one of) the shortest paths there.
            for (const dep of dependencies) {
                if (results[dep])
                    continue;
                const newPath = [...path, dep];
                results[dep] = newPath;
                // Also push the dependency onto the queue to process its dependencies.
                queue.push([dep, newPath]);
            }
        }
        return results;
    }
}
exports.PubDeps = PubDeps;


/***/ }),

/***/ 143:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageMap = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const url = __webpack_require__(7310);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
class PackageMap {
    static findPackagesFile(entryPoint) {
        if (typeof entryPoint !== "string")
            return undefined;
        const file = (0, utils_1.findFileInAncestor)([path.join(".dart_tool/package_config.json"), ".packages"], entryPoint);
        return file;
    }
    static loadForProject(logger, projectFolder) {
        const paths = [
            ".dart_tool/package_config.json",
            ".packages",
        ];
        for (const p of paths) {
            const fullP = path.join(projectFolder, p);
            if (fs.existsSync(fullP))
                return this.load(logger, fullP);
        }
        return new MissingPackageMap();
    }
    static load(logger, file) {
        if (!file)
            return new MissingPackageMap();
        try {
            if (path.basename(file).toLowerCase() === ".packages")
                return new DotPackagesPackageMap(file);
            else
                return new PackageConfigJsonPackageMap(logger, file);
        }
        catch (e) {
            logger.error(e);
            return new MissingPackageMap();
        }
    }
    getPackagePath(name) {
        return this.packages[name];
    }
    resolvePackageUri(uri) {
        if (!uri)
            return undefined;
        let name = uri;
        if (name.startsWith("package:"))
            name = name.substring(8);
        const index = name.indexOf("/");
        if (index === -1)
            return undefined;
        const rest = name.substring(index + 1);
        name = name.substring(0, index);
        const location = this.getPackagePath(name);
        if (location)
            return path.join(location, rest);
        else
            return undefined;
    }
}
exports.PackageMap = PackageMap;
class MissingPackageMap extends PackageMap {
    get packages() {
        return {};
    }
    getPackagePath(name) {
        return undefined;
    }
    resolvePackageUri(uri) {
        return undefined;
    }
}
class DotPackagesPackageMap extends PackageMap {
    constructor(file) {
        super();
        this.map = {};
        if (!file)
            return;
        this.localPackageRoot = path.dirname(file);
        const lines = fs.readFileSync(file, { encoding: "utf8" }).split("\n");
        for (let line of lines) {
            line = line.trim();
            if (line.length === 0 || line.startsWith("#"))
                continue;
            const index = line.indexOf(":");
            if (index !== -1) {
                const name = line.substr(0, index);
                const rest = line.substring(index + 1);
                if (rest.startsWith("file:"))
                    this.map[name] = (0, utils_1.uriToFilePath)(rest);
                else
                    this.map[name] = path.join(this.localPackageRoot, rest);
            }
        }
    }
    get packages() { return Object.assign({}, this.map); }
}
class PackageConfigJsonPackageMap extends PackageMap {
    constructor(logger, packageConfigPath) {
        super();
        this.logger = logger;
        this.packageConfigPath = packageConfigPath;
        this.map = {};
        const json = fs.readFileSync(this.packageConfigPath, "utf8");
        this.config = JSON.parse(json);
        for (const pkg of this.config.packages) {
            try {
                const packageConfigFolderPath = path.dirname(this.packageConfigPath);
                const packageRootPath = this.getPathForUri(pkg.rootUri);
                const packageLibPath = this.getPathForUri(pkg.packageUri);
                this.map[pkg.name] = path.resolve(packageConfigFolderPath, packageRootPath !== null && packageRootPath !== void 0 ? packageRootPath : "", packageLibPath !== null && packageLibPath !== void 0 ? packageLibPath : "");
            }
            catch (e) {
                logger.error(`Failed to resolve path for package ${pkg.name}: ${e}`);
            }
        }
    }
    getPathForUri(uri) {
        if (!uri)
            return undefined;
        const parsedPath = (0, fs_1.normalizeSlashes)(uri.startsWith("file:")
            ? url.fileURLToPath(uri)
            : unescape(uri));
        return parsedPath.endsWith(path.sep) ? parsedPath : `${parsedPath}${path.sep}`;
    }
    get packages() { return Object.assign({}, this.map); }
    getPackagePath(name) {
        return this.map[name];
    }
}


/***/ }),

/***/ 1119:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageCacheData = void 0;
class PackageCacheData {
    constructor(lastUpdated, packages) {
        this.lastUpdated = lastUpdated;
        this.packages = packages;
    }
    static get maxCacheAgeMs() { return PackageCacheData.maxCacheAgeHours * 60 * 60 * 1000; }
    static fromPackageNames(packages) {
        const packageMap = new Map();
        packages.forEach((p) => packageMap.set(p, undefined));
        return new PackageCacheData(new Date().getTime(), packageMap);
    }
    get packageNames() {
        // TODO: Can we avoid this and just iterate in the callee, since we often
        // bail out early?
        return Array.from(this.packages.keys());
    }
    get cacheTimeRemainingMs() {
        const ageMs = new Date().getTime() - this.lastUpdated;
        const timeRemainingMs = PackageCacheData.maxCacheAgeMs - ageMs;
        return timeRemainingMs < 0
            ? 0
            : timeRemainingMs;
    }
    static fromJson(json) {
        const data = JSON.parse(json, PackageCacheData.mapReviver);
        if (data.version !== PackageCacheData.cacheVersion)
            return undefined;
        return new PackageCacheData(data.lastUpdated, data.packages);
    }
    toJson() {
        return JSON.stringify({
            lastUpdated: this.lastUpdated,
            packages: this.packages,
            version: PackageCacheData.cacheVersion,
        }, PackageCacheData.mapReplacer, 2);
    }
    static mapReplacer(key, value) {
        return value instanceof Map
            ? {
                dataType: "Map",
                value: [...value],
            }
            : value;
    }
    static mapReviver(key, value) {
        return typeof value === "object" && (value === null || value === void 0 ? void 0 : value.dataType) === "Map"
            ? new Map(value.value)
            : value;
    }
}
exports.PackageCacheData = PackageCacheData;
PackageCacheData.cacheVersion = 1;
PackageCacheData.maxCacheAgeHours = 18;
PackageCacheData.maxPackageDetailsRequestsInFlight = 5;


/***/ }),

/***/ 3438:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanPubOutput = void 0;
function cleanPubOutput(pubOutput) {
    // Sometimes pub will output additional text that we need to discard:
    // Precompiling executable...\nPrecompiled stagehand:stagehand.\n[{"name":"console-full","label"
    const precompilingHeaderPattern = RegExp("^Precompil(?:ing|ed).*$", "gm");
    const json = pubOutput.replace(precompilingHeaderPattern, "");
    return json;
}
exports.cleanPubOutput = cleanPubOutput;


/***/ }),

/***/ 3058:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StdIOService = void 0;
const fs = __webpack_require__(7147);
const processes_1 = __webpack_require__(5837);
// Reminder: This class is used in the debug adapter as well as the main Code process!
class StdIOService {
    constructor(logger, maxLogLineLength, messagesWrappedInBrackets = false, treatHandlingErrorsAsUnhandledMessages = false, treatCarriageReturnsAsNewlines = false, logFile) {
        this.logger = logger;
        this.maxLogLineLength = maxLogLineLength;
        this.messagesWrappedInBrackets = messagesWrappedInBrackets;
        this.treatHandlingErrorsAsUnhandledMessages = treatHandlingErrorsAsUnhandledMessages;
        this.treatCarriageReturnsAsNewlines = treatCarriageReturnsAsNewlines;
        this.logFile = logFile;
        this.disposables = [];
        this.additionalPidsToTerminate = [];
        this.nextRequestID = 1;
        this.activeRequests = {};
        this.messageBuffers = [];
        this.requestErrorSubscriptions = [];
        this.processExited = false;
    }
    createProcess(workingDirectory, binPath, args, envOverrides) {
        this.logTraffic(`Spawning ${binPath} with args ${JSON.stringify(args)}`);
        if (workingDirectory)
            this.logTraffic(`..  in ${workingDirectory}`);
        if (envOverrides.envOverrides || envOverrides.toolEnv)
            this.logTraffic(`..  with ${JSON.stringify(envOverrides)}`);
        const env = Object.assign({}, envOverrides.toolEnv, envOverrides.envOverrides);
        this.process = (0, processes_1.safeSpawn)(workingDirectory, binPath, args, env);
        this.logTraffic(`    PID: ${process.pid}`);
        this.process.stdout.on("data", (data) => this.handleStdOut(data));
        this.process.stderr.on("data", (data) => this.handleStdErr(data));
        this.process.on("exit", (code, signal) => this.handleExit(code, signal));
        this.process.on("error", (error) => this.handleError(error));
    }
    /// Flutter may send only \r as a line terminator for improved terminal output
    /// but we should always treat this as a standard newline (eg. terminating a message)
    /// so all \r's can be replaced with \n immediately. Blank lines (from \n\n)
    /// are already handled gracefully.
    ///
    /// https://github.com/flutter/flutter/pull/57590
    normalizeNewlines(data) {
        const normalised = this.treatCarriageReturnsAsNewlines
            ? Buffer.from(data.toString().replace(/\r/g, "\n"))
            : data;
        return Buffer.from(normalised);
    }
    handleStdOut(data) {
        data = this.normalizeNewlines(data);
        // Add this message to the buffer for processing.
        this.messageBuffers.push(data);
        // Kick off processing if we have a full message.
        if (data.indexOf("\n") >= 0)
            this.processMessageBuffer();
    }
    handleStdErr(data) {
        this.logTraffic(`${data.toString()}`, true);
    }
    handleExit(code, signal) {
        this.logTraffic(`Process terminated! ${code}, ${signal}`);
        this.processExited = true;
    }
    handleError(error) {
        this.logTraffic(`Process errored! ${error}`);
    }
    buildRequest(id, method, params) {
        return {
            id: id.toString(),
            method,
            params,
        };
    }
    sendRequest(method, params) {
        // Generate an ID for this request so we can match up the response.
        const id = this.nextRequestID++;
        return new Promise((resolve, reject) => {
            // Stash the callbacks so we can call them later.
            this.activeRequests[id.toString()] = [resolve, reject, method];
            const req = this.buildRequest(id, method, params);
            const json = this.messagesWrappedInBrackets
                ? "[" + JSON.stringify(req) + "]\r\n"
                : JSON.stringify(req) + "\r\n";
            this.sendMessage(json);
        });
    }
    cancelAllRequests() {
        Object.keys(this.activeRequests).forEach((key) => this.activeRequests[key] = "CANCELLED");
    }
    sendMessage(json) {
        this.logTraffic(`==> ${json}`);
        if (this.process)
            this.process.stdin.write(json);
        else
            this.logTraffic(`  (not sent: no process)`);
    }
    processMessageBuffer() {
        let fullBuffer = Buffer.concat(this.messageBuffers);
        this.messageBuffers = [];
        // If the message doesn't end with \n then put the last part back into the buffer.
        const lastNewline = fullBuffer.lastIndexOf("\n");
        if (lastNewline !== fullBuffer.length - 1) {
            const incompleteMessage = fullBuffer.slice(lastNewline + 1);
            fullBuffer = fullBuffer.slice(0, lastNewline);
            this.messageBuffers.push(incompleteMessage);
        }
        // Process the complete messages in the buffer.
        fullBuffer.toString().split("\n").filter((m) => m.trim() !== "").forEach((m) => this.handleMessage(`${m}\n`));
    }
    // tslint:disable-next-line:no-empty
    processUnhandledMessage(message) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logTraffic(`<== ${message.trimRight()}\r\n`);
            if (!this.shouldHandleMessage(message.trim())) {
                return this.processUnhandledMessage(message);
            }
            let msg;
            try {
                msg = JSON.parse(message);
                if (this.messagesWrappedInBrackets && msg && msg.length === 1)
                    msg = msg[0];
            }
            catch (e) {
                if (this.treatHandlingErrorsAsUnhandledMessages) {
                    this.logger.error(`Unexpected non-JSON message, assuming normal stdout (${e})\n\n${e.stack}\n\n${message}`);
                    return this.processUnhandledMessage(message);
                }
                else {
                    throw e;
                }
            }
            try {
                if (msg && this.isNotification(msg))
                    // tslint:disable-next-line: no-floating-promises
                    this.handleNotification(msg).catch((e) => this.logger.error(e));
                else if (msg && this.isRequest(msg))
                    this.processServerRequest(msg).catch((e) => this.logger.error(e));
                else if (msg && this.isResponse(msg))
                    this.handleResponse(msg).catch((e) => this.logger.error(e));
                else {
                    this.logger.error(`Unexpected JSON message, assuming normal stdout : ${message}`);
                    this.processUnhandledMessage(message).catch((e) => this.logger.error(e));
                }
            }
            catch (e) {
                if (this.treatHandlingErrorsAsUnhandledMessages) {
                    this.logger.error(`Failed to handle JSON message, assuming normal stdout (${e})\n\n${e.stack}\n\n${message}`);
                    this.processUnhandledMessage(message).catch((e) => this.logger.error(e));
                }
                else {
                    throw e;
                }
            }
        });
    }
    // tslint:disable-next-line: no-empty
    handleRequest(method, args) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    isNotification(msg) { return !!msg.event; }
    isRequest(msg) { return !!msg.method && !!msg.id; }
    isResponse(msg) { return !!msg.id; }
    processServerRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            let error;
            try {
                result = yield this.handleRequest(request.method, request.params);
            }
            catch (e) {
                error = e;
            }
            const resp = { id: request.id, result, error };
            const json = this.messagesWrappedInBrackets
                ? "[" + JSON.stringify(resp) + "]\r\n"
                : JSON.stringify(resp) + "\r\n";
            this.sendMessage(json);
        });
    }
    handleResponse(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this.activeRequests[evt.id];
            delete this.activeRequests[evt.id];
            if (handler === "CANCELLED") {
                this.logger.info(`Ignoring response to ${evt.id} because it was cancelled:\n\n${JSON.stringify(evt, undefined, 4)}`);
                return;
            }
            else if (!handler) {
                this.logger.error(`Unable to handle response with ID ${evt.id} because its handler is not available`);
                return;
            }
            const method = handler[2];
            const error = evt.error;
            if (error && error.code === "SERVER_ERROR") {
                error.method = method;
                this.notify(this.requestErrorSubscriptions, error).catch((e) => this.logger.error(e));
            }
            if (error) {
                yield handler[1](error);
            }
            else {
                yield handler[0](evt.result);
            }
        });
    }
    notify(subscriptions, notification) {
        return Promise.all(subscriptions.slice().map((sub) => sub(notification))).catch((e) => console.error(e));
    }
    subscribe(subscriptions, subscriber) {
        subscriptions.push(subscriber);
        const disposable = {
            dispose: () => {
                // Remove from the subscription list.
                let index = subscriptions.indexOf(subscriber);
                if (index >= 0) {
                    subscriptions.splice(index, 1);
                }
                // Also remove from our disposables (else we'll leak it).
                index = this.disposables.indexOf(disposable);
                if (index >= 0) {
                    this.disposables.splice(index, 1);
                }
            },
        };
        this.disposables.push(disposable);
        return disposable;
    }
    registerForRequestError(subscriber) {
        return this.subscribe(this.requestErrorSubscriptions, subscriber);
    }
    logTraffic(message, isError = false) {
        if (isError)
            this.logger.error(message);
        else
            this.logger.info(message);
        if (this.openLogFile !== this.logFile && this.logStream) {
            this.logStream.end();
            this.logStream = undefined;
            this.openLogFile = undefined;
        }
        if (!this.logFile)
            return;
        if (!this.logStream) {
            this.logStream = fs.createWriteStream(this.logFile);
            this.openLogFile = this.logFile;
        }
        this.logStream.write(`[${(new Date()).toLocaleTimeString()}]: `);
        if (this.maxLogLineLength && message.length > this.maxLogLineLength)
            this.logStream.write(message.substring(0, this.maxLogLineLength) + "\r\n");
        else
            this.logStream.write(message.trim() + "\r\n");
    }
    dispose() {
        for (const pid of this.additionalPidsToTerminate) {
            try {
                process.kill(pid);
            }
            catch (e) {
                // TODO: Logger knows the category!
                this.logger.error({ message: e.toString() });
            }
        }
        this.additionalPidsToTerminate.length = 0;
        try {
            if (!this.processExited && this.process && !this.process.killed)
                this.process.kill();
        }
        catch (e) {
            // This tends to throw a lot because the shell process quit when we terminated the related
            // process above, so just swallow the error.
        }
        this.process = undefined;
        this.disposables.forEach((d) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield d.dispose();
            }
            catch (e) {
                this.logger.error({ message: e.toString() });
            }
        }));
        this.disposables.length = 0;
        // Clear log file so if any more log events come through later, we don't
        // create a new log file and overwrite what we had.
        this.logFile = undefined;
        if (this.logStream) {
            this.logStream.end();
            this.logStream = undefined;
            this.openLogFile = undefined;
        }
    }
}
exports.StdIOService = StdIOService;


/***/ }),

/***/ 9055:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.internalApiSymbol = void 0;
// TODO: Can we make this work better when webpack'd?
exports.internalApiSymbol = "_privateApi"; // Symbol();


/***/ }),

/***/ 9602:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestSessionCoordinator = void 0;
const utils_1 = __webpack_require__(4586);
const outline_lsp_1 = __webpack_require__(4215);
const test_model_1 = __webpack_require__(1159);
/// Handles results from a test debug session and provides them to the test model.
class TestSessionCoordinator {
    constructor(logger, data, fileTracker) {
        this.logger = logger;
        this.data = data;
        this.fileTracker = fileTracker;
        this.disposables = [];
        /// A link between a suite path and the debug session ID that owns it, so we can ensure
        /// it is correctly ended when the debug session ends, even if we don't get the correct
        /// end events.
        this.owningDebugSessions = {};
        /// For a given debug session, lookups by IDs to get back to the suite.
        this.debugSessionLookups = {};
        /// A link between a suite path and a visitor for visiting its latest outline data.
        /// This data is refreshed when a test suite starts running.
        this.suiteOutlineVisitors = {};
        /// For each debug session ID, stores a mapping of phantom (empty) groups and their parent IDs so we can
        /// jump over them.
        this.phantomGroupParents = {};
    }
    handleDebugSessionCustomEvent(debugSessionID, dartCodeDebugSessionID, event, body) {
        if (event === "dart.testNotification") {
            // tslint:disable-next-line: no-floating-promises
            this.handleNotification(debugSessionID, dartCodeDebugSessionID !== null && dartCodeDebugSessionID !== void 0 ? dartCodeDebugSessionID : `untagged-session-${debugSessionID}`, body).catch((e) => this.logger.error(e));
        }
    }
    handleDebugSessionEnd(debugSessionID, dartCodeDebugSessionID) {
        // Get the suite paths that have us as the owning debug session.
        const suitePaths = Object.keys(this.owningDebugSessions).filter((suitePath) => {
            const owningSessionID = this.owningDebugSessions[suitePath];
            return owningSessionID === debugSessionID;
        });
        // End them all and remove from the lookup.
        for (const suitePath of suitePaths) {
            this.handleSuiteEnd(dartCodeDebugSessionID, this.data.suites[suitePath]);
            this.owningDebugSessions[suitePath] = undefined;
            delete this.owningDebugSessions[suitePath];
        }
    }
    handleNotification(debugSessionID, dartCodeDebugSessionID, evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.type) {
                // We won't get notifications that aren't directly tied to Suites because
                // of how the DA works.
                // case "start":
                // 	this.handleStartNotification(evt as StartNotification);
                // 	break;
                // We won't get notifications that aren't directly tied to Suites because
                // of how the DA works.
                // case "allSuites":
                // 	this.handleAllSuitesNotification(evt as AllSuitesNotification);
                // 	break;
                case "suite":
                    this.handleSuiteNotification(dartCodeDebugSessionID, evt);
                    break;
                case "testStart":
                    this.handleTestStartNotification(dartCodeDebugSessionID, evt);
                    break;
                case "testDone":
                    this.handleTestDoneNotification(dartCodeDebugSessionID, evt);
                    break;
                case "group":
                    this.handleGroupNotification(dartCodeDebugSessionID, evt);
                    break;
                // We won't get notifications that aren't directly tied to Suites because
                // of how the DA works.
                // case "done":
                // 	this.handleDoneNotification(suite, evt as DoneNotification);
                // 	break;
                case "print":
                    this.handlePrintNotification(dartCodeDebugSessionID, evt);
                    break;
                case "error":
                    this.handleErrorNotification(dartCodeDebugSessionID, evt);
                    break;
            }
        });
    }
    handleSuiteNotification(dartCodeDebugSessionID, evt) {
        if (!this.debugSessionLookups[dartCodeDebugSessionID])
            this.debugSessionLookups[dartCodeDebugSessionID] = { suiteForID: {}, suiteForTestID: {} };
        const suiteData = this.data.suiteDiscovered(dartCodeDebugSessionID, evt.suite.path);
        this.debugSessionLookups[dartCodeDebugSessionID].suiteForID[evt.suite.id] = suiteData;
        // Also capture the test nodes from the outline so that we can look up the full range for a test (instead of online its line/col)
        // to provide to VS Code to better support "run test at cursor".
        this.captureTestOutlne(evt.suite.path);
    }
    captureTestOutlne(path) {
        var _a;
        const visitor = new outline_lsp_1.LspTestOutlineVisitor(this.logger, path);
        this.suiteOutlineVisitors[path] = visitor;
        const outline = (_a = this.fileTracker) === null || _a === void 0 ? void 0 : _a.getOutlineFor(path);
        if (outline)
            visitor.visit(outline);
    }
    handleTestStartNotification(dartCodeDebugSessionID, evt) {
        var _a, _b, _c;
        // Skip loading tests.
        if (((_a = evt.test.name) === null || _a === void 0 ? void 0 : _a.startsWith("loading ")) && !((_b = evt.test.groupIDs) === null || _b === void 0 ? void 0 : _b.length))
            return;
        const suite = this.debugSessionLookups[dartCodeDebugSessionID].suiteForID[evt.test.suiteID];
        if (!suite) {
            this.logger.warn(`Could not find suite ${evt.test.suiteID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        this.debugSessionLookups[dartCodeDebugSessionID].suiteForTestID[evt.test.id] = suite;
        const path = (evt.test.root_url || evt.test.url) ? (0, utils_1.uriToFilePath)(evt.test.root_url || evt.test.url) : undefined;
        const line = evt.test.root_line || evt.test.line;
        const character = evt.test.root_column || evt.test.column;
        const range = this.getRangeForNode(suite, line, character);
        const groupID = ((_c = evt.test.groupIDs) === null || _c === void 0 ? void 0 : _c.length) ? evt.test.groupIDs[evt.test.groupIDs.length - 1] : undefined;
        this.data.testDiscovered(dartCodeDebugSessionID, suite.path, test_model_1.TestSource.Result, evt.test.id, evt.test.name, this.getRealGroupId(dartCodeDebugSessionID, groupID), path, range, evt.time, true);
    }
    handleTestDoneNotification(dartCodeDebugSessionID, evt) {
        var _a;
        // If we don't have a test, it was likely a "loading foo.dart" test that we skipped over, so skip the result too.
        const suite = (_a = this.debugSessionLookups[dartCodeDebugSessionID]) === null || _a === void 0 ? void 0 : _a.suiteForTestID[evt.testID];
        if (!suite) {
            return;
        }
        const test = suite.getCurrentTest(dartCodeDebugSessionID, evt.testID);
        if (!test)
            return;
        const result = evt.skipped ? "skipped" : evt.result;
        this.data.testDone(dartCodeDebugSessionID, suite.path, evt.testID, result, evt.time);
    }
    handleGroupNotification(dartCodeDebugSessionID, evt) {
        var _a, _b;
        // Skip phantom groups.
        if (!evt.group.name) {
            if (dartCodeDebugSessionID) {
                this.phantomGroupParents[dartCodeDebugSessionID] = this.phantomGroupParents[dartCodeDebugSessionID] || {};
                this.phantomGroupParents[dartCodeDebugSessionID][evt.group.id] = (_a = evt.group.parentID) !== null && _a !== void 0 ? _a : null; // Null signifies top-level.
            }
            return;
        }
        const suite = (_b = this.debugSessionLookups[dartCodeDebugSessionID]) === null || _b === void 0 ? void 0 : _b.suiteForID[evt.group.suiteID];
        if (!suite) {
            this.logger.warn(`Could not find suite ${evt.group.suiteID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        const path = (evt.group.root_url || evt.group.url) ? (0, utils_1.uriToFilePath)(evt.group.root_url || evt.group.url) : undefined;
        const line = evt.group.root_line || evt.group.line;
        const character = evt.group.root_column || evt.group.column;
        const range = this.getRangeForNode(suite, line, character);
        this.data.groupDiscovered(dartCodeDebugSessionID, suite.path, test_model_1.TestSource.Result, evt.group.id, evt.group.name, this.getRealGroupId(dartCodeDebugSessionID, evt.group.parentID), path, range, true);
    }
    getRealGroupId(dartCodeDebugSessionID, groupID) {
        const mapping = dartCodeDebugSessionID ? this.phantomGroupParents[dartCodeDebugSessionID] : undefined;
        const mappedValue = mapping && groupID ? mapping[groupID] : undefined;
        // Null is a special value that means undefined top-level)
        return mappedValue === null
            ? undefined
            // Whereas a real undefined we just pass-through as it was.
            : mappedValue !== null && mappedValue !== void 0 ? mappedValue : groupID;
    }
    handleSuiteEnd(dartCodeDebugSessionID, suite) {
        this.data.suiteDone(dartCodeDebugSessionID, suite.path);
    }
    handlePrintNotification(dartCodeDebugSessionID, evt) {
        var _a;
        const suite = (_a = this.debugSessionLookups[dartCodeDebugSessionID]) === null || _a === void 0 ? void 0 : _a.suiteForTestID[evt.testID];
        if (!suite) {
            this.logger.warn(`Could not find suite for test ${evt.testID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        const test = suite.getCurrentTest(dartCodeDebugSessionID, evt.testID);
        // It's possible we'll get notifications for tests we don't track (like loading tests) - for example package:test
        // may send "Consider enabling the flag chain-stack-traces to receive more detailed exceptions" against the first
        // loading test.
        if (!test)
            return;
        test.outputEvents.push(evt);
        this.data.testOutput(dartCodeDebugSessionID, suite.path, evt.testID, evt.message);
    }
    handleErrorNotification(dartCodeDebugSessionID, evt) {
        var _a;
        const suite = (_a = this.debugSessionLookups[dartCodeDebugSessionID]) === null || _a === void 0 ? void 0 : _a.suiteForTestID[evt.testID];
        if (!suite) {
            this.logger.warn(`Could not find suite for test ${evt.testID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        const test = suite.getCurrentTest(dartCodeDebugSessionID, evt.testID);
        // It's possible we'll get notifications for tests we don't track (like loading tests) - for example package:test
        // may send "Consider enabling the flag chain-stack-traces to receive more detailed exceptions" against the first
        // loading test.
        if (!test)
            return;
        test.outputEvents.push(evt);
        this.data.testErrorOutput(dartCodeDebugSessionID, suite.path, evt.testID, evt.isFailure, evt.error, evt.stackTrace);
    }
    getRangeForNode(suite, line, character) {
        var _a, _b;
        if (!line || !character)
            return;
        // In test notifications, we only get the start line/column but we need to give VS Code the full range for "Run Test at Cursor" to work.
        // The outline data was captured when the suite started, so we can assume it's reasonable accurate, so try to look up the node
        // there and use its range. Otherwise, just make a range that goes from the start position to the next line (assuming the rest
        // of the line is the test name, and we can at least support running it there).
        const testsOnLine = line ? (_a = this.suiteOutlineVisitors[suite.path]) === null || _a === void 0 ? void 0 : _a.testsByLine[line - 1] : undefined;
        const test = testsOnLine ? testsOnLine.find((t) => t.range.start.character === character - 1) : undefined;
        const range = line && character ? (_b = test === null || test === void 0 ? void 0 : test.range) !== null && _b !== void 0 ? _b : { start: { line, character }, end: { line: line + 1, character } } : undefined;
        return range;
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestSessionCoordinator = TestSessionCoordinator;


/***/ }),

/***/ 1159:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestSource = exports.SuiteData = exports.TestModel = exports.TestNode = exports.GroupNode = exports.SuiteNode = exports.TreeNode = void 0;
const path = __webpack_require__(1017);
const enums_1 = __webpack_require__(7341);
const events_1 = __webpack_require__(3254);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const test_1 = __webpack_require__(8729);
class TreeNode {
    constructor(suiteData) {
        this.suiteData = suiteData;
        this._isStale = false;
        this.testSource = TestSource.Outline;
        this.isPotentiallyDeleted = false;
        this.children = [];
        this.statuses = new Set([enums_1.TestStatus.Unknown]);
    }
    /// Adds a status to the existing statuses list.
    appendStatus(status) {
        if (status === enums_1.TestStatus.Failed
            || status === enums_1.TestStatus.Passed
            || status === enums_1.TestStatus.Skipped) {
            this.isStale = false;
            this.isPotentiallyDeleted = false;
        }
        this.statuses.add(status);
    }
    clearStatuses() {
        this.statuses.clear();
        this.description = undefined; // Clear old run duration.
    }
    hasStatus(status) {
        return this.statuses.has(status);
    }
    getHighestStatus(includeSkipped) {
        const statuses = this instanceof TestNode
            ? new Set(this.children.map((c) => c.status))
            : this.statuses;
        // Always include Skipped status for Suite nodes that have only that status, else they'll
        // show as unknown.
        if (!includeSkipped && this instanceof SuiteNode && statuses.size === 1 && statuses.has(enums_1.TestStatus.Skipped))
            includeSkipped = true;
        const validStatues = [...statuses].filter((s) => includeSkipped || s !== enums_1.TestStatus.Skipped);
        return validStatues.length
            ? Math.max(...validStatues)
            : enums_1.TestStatus.Unknown;
    }
    getTestCount(includeSkipped) {
        return this.children.map((t) => t.getTestCount(includeSkipped))
            .reduce((total, value) => total + value, 0);
    }
    get label() {
        const name = this instanceof GroupNode
            ? this.name
            : this instanceof TestNode
                ? this.name
                : undefined;
        let parent = this.parent;
        while (name && parent) {
            const parentName = parent instanceof GroupNode
                ? parent.name
                : parent instanceof TestNode
                    ? parent.name
                    : undefined;
            if (parentName && name.startsWith(`${parentName} `))
                return name.substr(parentName.length + 1); // +1 because of the space (included above).
            // Otherwise try next parent up.
            parent = parent === null || parent === void 0 ? void 0 : parent.parent;
        }
        return name !== null && name !== void 0 ? name : "<unnamed>";
    }
    get testPassCount() {
        return this.children.map((t) => t.testPassCount)
            .reduce((total, value) => total + value, 0);
    }
    get isStale() {
        return this._isStale;
    }
    set isStale(value) {
        this._isStale = value;
    }
}
exports.TreeNode = TreeNode;
class SuiteNode extends TreeNode {
    constructor(suiteData) {
        super(suiteData);
    }
    get parent() { return undefined; }
}
exports.SuiteNode = SuiteNode;
class GroupNode extends TreeNode {
    constructor(suiteData, parent, name, path, range) {
        super(suiteData);
        this.suiteData = suiteData;
        this.parent = parent;
        this.name = name;
        this.path = path;
        this.range = range;
    }
}
exports.GroupNode = GroupNode;
class TestNode extends TreeNode {
    // TODO: Flatten test into this class so we're not tied to the test protocol.
    constructor(suiteData, parent, name, path, range) {
        super(suiteData);
        this.suiteData = suiteData;
        this.parent = parent;
        this.name = name;
        this.path = path;
        this.range = range;
        this._status = enums_1.TestStatus.Unknown;
        this.outputEvents = [];
    }
    getTestCount(includeSkipped) {
        if (this.children.length)
            return super.getTestCount(includeSkipped);
        return includeSkipped || this.status !== enums_1.TestStatus.Skipped ? 1 : 0;
    }
    get testPassCount() {
        if (this.children.length)
            return super.testPassCount;
        return this.status === enums_1.TestStatus.Passed ? 1 : 0;
    }
    get status() {
        if (this.children.length)
            return super.getHighestStatus(true);
        return this._status;
    }
    set status(value) {
        this._status = value;
        if (this._status === enums_1.TestStatus.Failed
            || this._status === enums_1.TestStatus.Passed
            || this._status === enums_1.TestStatus.Skipped) {
            this.isStale = false;
            this.isPotentiallyDeleted = false;
        }
    }
    get isStale() {
        if (this.children.length)
            return !!this.children.find((c) => c.isStale);
        return super.isStale;
    }
    set isStale(value) {
        super.isStale = value;
    }
}
exports.TestNode = TestNode;
class TestModel {
    constructor(config, isPathInsideFlutterProject) {
        this.config = config;
        this.isPathInsideFlutterProject = isPathInsideFlutterProject;
        this.onDidChangeDataEmitter = new events_1.EventEmitter();
        this.onDidChangeTreeData = this.onDidChangeDataEmitter.event;
        this.testEventListeners = [];
        // TODO: Make private?
        this.suites = {};
    }
    addTestEventListener(listener) {
        this.testEventListeners.push(listener);
    }
    flagSuiteStart(suitePath, isRunningWholeSuite) {
        if (suitePath && path.isAbsolute(suitePath)) {
            const suite = this.suites[(0, fs_1.fsPath)(suitePath)];
            if (suite) {
                // Mark all test for this suite as "stale" which will make them faded, so that results from
                // the "new" run are more obvious in the tree.
                suite.getAllGroups().forEach((g) => g.isStale = true);
                suite.getAllTests().forEach((t) => t.isStale = true);
                if (isRunningWholeSuite && suite) {
                    this.markAllAsPotentiallyDeleted(suite, TestSource.Result);
                }
            }
        }
    }
    // When running the whole suite (or updating from Outline), we flag all tests as being
    // potentially deleted and then any tests that aren't run are removed from the tree. This
    // is to ensure if a test is renamed, we don't keep the old version of it in the test tree
    // forever since we don't have the necessary information to know the test was renamed.
    //
    // When updating from the outline, we'll skip children of dynamic nodes as we don't
    // know if they've been deleted or not, and don't want to cause their results to
    // immediately disappear.
    markAllAsPotentiallyDeleted(suite, source) {
        function doNode(node) {
            if (node.testSource === source)
                node.isPotentiallyDeleted = true;
            node.children.forEach(doNode);
        }
        doNode(suite.node);
    }
    // Marks a node and all of its parents as not-deleted so they will not be cleaned up.
    markAsNotDeleted(node) {
        while (node) {
            node.isPotentiallyDeleted = false;
            node = node.parent;
        }
    }
    removeAllPotentiallyDeletedNodes(suite) {
        // Delete nodes that were marked as potentially deleted and then never updated.
        // This means they weren't run in the last run, so probably were deleted (or
        // renamed and got new nodes, which still means the old ones should be removed).
        const toDelete = [
            ...suite.getAllGroups(),
            ...suite.getAllTests(),
        ].filter((t) => t.isPotentiallyDeleted);
        const toUpdate = new Set(toDelete.map((node) => node.parent));
        toDelete.forEach((node) => this.removeNode(node));
        toUpdate.forEach((node) => this.updateNode(node));
    }
    getOrCreateSuite(suitePath) {
        let suite = this.suites[suitePath];
        if (!suite) {
            suite = new SuiteData(suitePath, this.isPathInsideFlutterProject(suitePath));
            this.suites[suitePath] = suite;
            return [suite, true];
        }
        return [suite, false];
    }
    clearSuite(suitePath) {
        if (!this.suites[suitePath])
            return;
        delete this.suites[suitePath];
        this.updateNode();
    }
    clearSuiteOrDirectory(suiteOrDirectoryPath) {
        // We can't tell if it's a file or directory because it's already been deleted, so just
        // try both.
        let found = false;
        if (this.suites[suiteOrDirectoryPath]) {
            found = true;
            delete this.suites[suiteOrDirectoryPath];
        }
        else {
            for (const suitePath of Object.keys(this.suites)) {
                if ((0, fs_1.isWithinPath)(suitePath, suiteOrDirectoryPath)) {
                    delete this.suites[suitePath];
                    found = true;
                }
            }
        }
        if (found)
            this.updateNode();
    }
    handleConfigChange() {
        // When config changes, some things may change (for example
        // skipped tests may be hidden, so the test counts need
        // recomputing).
        Object.values(this.suites).forEach((suite) => this.rebuildSuiteNode(suite));
    }
    updateNode(node) {
        this.onDidChangeDataEmitter.fire(node);
    }
    rebuildSuiteNode(suite) {
        // Walk the tree to get the status.
        this.rebuildNode(suite.node);
        this.updateNode(suite.node);
    }
    /// Rebuilds any data on a node that is dependent on its children.
    rebuildNode(node) {
        if (!node.children.length)
            return;
        const childStatuses = (0, utils_1.flatMap)(node.children.map((c) => {
            this.rebuildNode(c);
            if (c instanceof GroupNode) {
                return [...c.statuses];
            }
            if (c instanceof TestNode)
                return [c.status];
            return [enums_1.TestStatus.Unknown];
        }), (s) => s);
        const childStatusesSet = new Set(childStatuses);
        const statusAreEqual = node.statuses.size === childStatusesSet.size && [...childStatusesSet].every((s) => node.statuses.has(s));
        if (!statusAreEqual) {
            node.clearStatuses();
            childStatuses.forEach((s) => node.appendStatus(s));
        }
        node.description = `${node.testPassCount}/${node.getTestCount(this.config.showSkippedTests)} passed`;
    }
    suiteDiscovered(dartCodeDebugSessionID, suitePath) {
        const [suite, didCreate] = this.getOrCreateSuite(suitePath);
        suite.node.appendStatus(enums_1.TestStatus.Waiting);
        this.updateNode(suite.node);
        this.updateNode();
        this.testEventListeners.forEach((l) => l.suiteDiscovered(dartCodeDebugSessionID, suite.node));
        return suite;
    }
    groupDiscovered(dartCodeDebugSessionID, suitePath, source, groupID, groupName, parentID, groupPath, range, hasStarted = false) {
        var _a;
        const suite = this.suites[suitePath];
        const existingGroup = suite.reuseMatchingGroup(groupName);
        const oldParent = existingGroup === null || existingGroup === void 0 ? void 0 : existingGroup.parent;
        let parent = parentID ? suite.getMyGroup(dartCodeDebugSessionID, parentID) : suite.node;
        /// If we're a dynamic test/group, we should be re-parented under the dynamic node that came from
        /// the analyzer.
        if (groupName && source === TestSource.Result)
            parent = (_a = this.findMatchingDynamicNode(parent, groupName)) !== null && _a !== void 0 ? _a : parent;
        const groupNode = existingGroup || new GroupNode(suite, parent, groupName, groupPath, range);
        suite.storeGroup(dartCodeDebugSessionID, groupID, groupNode);
        if (existingGroup) {
            groupNode.parent = parent;
            groupNode.name = groupName;
            groupNode.path = groupPath;
            groupNode.range = range;
        }
        else {
            groupNode.testSource = source;
        }
        this.markAsNotDeleted(groupNode);
        // Remove from old parent if required
        const hasChangedParent = oldParent !== parent;
        if (oldParent && hasChangedParent) {
            oldParent.children.splice(oldParent.children.indexOf(groupNode), 1);
            this.updateNode(oldParent);
        }
        // Push to new parent if required.
        if (!groupNode.parent.children.find((n) => n === groupNode))
            groupNode.parent.children.push(groupNode);
        if (hasStarted) {
            groupNode.appendStatus(enums_1.TestStatus.Running);
        }
        this.updateNode(groupNode.parent);
        this.testEventListeners.forEach((l) => l.groupDiscovered(dartCodeDebugSessionID, groupNode));
        return groupNode;
    }
    testDiscovered(dartCodeDebugSessionID, suitePath, source, testID, testName, groupID, testPath, range, startTime, hasStarted = false) {
        var _a;
        const suite = this.suites[suitePath];
        const existingTest = suite.reuseMatchingTest(testName);
        const oldParent = existingTest === null || existingTest === void 0 ? void 0 : existingTest.parent;
        let parent = groupID ? suite.getMyGroup(dartCodeDebugSessionID, groupID) : suite.node;
        /// If we're a dynamic test/group, we should be re-parented under the dynamic node that came from
        /// the analyzer.
        if (testName && source === TestSource.Result)
            parent = (_a = this.findMatchingDynamicNode(parent, testName)) !== null && _a !== void 0 ? _a : parent;
        const testNode = existingTest || new TestNode(suite, parent, testName, testPath, range);
        suite.storeTest(dartCodeDebugSessionID, testID, testNode);
        if (existingTest) {
            testNode.parent = parent;
            testNode.name = testName;
            testNode.path = testPath;
            const originalRange = testNode.range;
            testNode.range = range;
            // If we're an Outline node being updated, and we have Results children that
            // had the same range as us, they should be updated too, so Results nodes do not
            // drift away from the location over time.
            if (testNode.testSource === TestSource.Outline) {
                const children = testNode.children
                    .filter((c) => c.testSource === TestSource.Result)
                    .filter((c) => !c.range || (originalRange && this.rangeEquals(c.range, originalRange)));
                for (const child of children)
                    child.range = range;
            }
        }
        else {
            testNode.testSource = source;
        }
        this.markAsNotDeleted(testNode);
        testNode.testStartTime = startTime;
        // Remove from old parent if required.
        const hasChangedParent = oldParent && oldParent !== testNode.parent;
        if (oldParent && hasChangedParent) {
            oldParent.children.splice(oldParent.children.indexOf(testNode), 1);
            this.updateNode(oldParent);
        }
        // Push to new parent if required.
        if (!testNode.parent.children.find((n) => n === testNode))
            testNode.parent.children.push(testNode);
        if (hasStarted) {
            // Clear any test output from previous runs.
            testNode.outputEvents.length = 0;
            testNode.status = enums_1.TestStatus.Running;
        }
        this.updateNode(testNode.parent);
        this.rebuildSuiteNode(suite);
        if (hasStarted && dartCodeDebugSessionID)
            this.testEventListeners.forEach((l) => l.testStarted(dartCodeDebugSessionID, testNode));
        return testNode;
    }
    /// Find a matching node in 'parent' that might be a node for a dynamic test/group that name is
    /// an instance of.
    findMatchingDynamicNode(parent, name) {
        // If the parent has any children exactly named us, they should be used regardless.
        if (parent.children.find((c) => c.name === name))
            return;
        for (const child of parent.children) {
            if (!child.name || typeof child !== typeof parent)
                continue;
            const regex = new RegExp((0, test_1.makeRegexForTests)([{ name: child.name, isGroup: child instanceof GroupNode }]));
            if (regex.test(name))
                return child;
        }
    }
    testDone(dartCodeDebugSessionID, suitePath, testID, result, endTime) {
        const suite = this.suites[suitePath];
        const testNode = suite.getCurrentTest(dartCodeDebugSessionID, testID);
        if (result === "skipped") {
            testNode.status = enums_1.TestStatus.Skipped;
        }
        else if (result === "success") {
            testNode.status = enums_1.TestStatus.Passed;
        }
        else if (result === "failure") {
            testNode.status = enums_1.TestStatus.Failed;
        }
        else if (result === "error")
            testNode.status = enums_1.TestStatus.Failed;
        else {
            testNode.status = enums_1.TestStatus.Unknown;
        }
        if (endTime && testNode.testStartTime) {
            testNode.duration = endTime - testNode.testStartTime;
            testNode.description = ``;
            // Don't clear this, as concurrent runs will overwrite each
            // other and then we'll get no time at the end.
            // testNode.testStartTime = undefined;
        }
        this.updateNode(testNode);
        this.updateNode(testNode.parent);
        this.rebuildSuiteNode(suite);
        if (dartCodeDebugSessionID)
            this.testEventListeners.forEach((l) => l.testDone(dartCodeDebugSessionID, testNode, result));
    }
    suiteDone(dartCodeDebugSessionID, suitePath) {
        const suite = this.suites[suitePath];
        if (!suite)
            return;
        // TODO: Some notification that things are complete?
        // TODO: Maybe a progress bar during the run?
        this.removeAllPotentiallyDeletedNodes(suite);
        // Anything marked as running should be set back to Unknown
        suite.getAllTests().filter((t) => t.status === enums_1.TestStatus.Running).forEach((t) => {
            t.status = enums_1.TestStatus.Unknown;
            this.updateNode(t);
        });
        this.rebuildSuiteNode(suite);
        if (dartCodeDebugSessionID)
            this.testEventListeners.forEach((l) => l.suiteDone(dartCodeDebugSessionID, suite.node));
    }
    testOutput(dartCodeDebugSessionID, suitePath, testID, message) {
        const suite = this.suites[suitePath];
        const test = suite.getCurrentTest(dartCodeDebugSessionID, testID);
        if (test)
            this.testEventListeners.forEach((l) => l.testOutput(dartCodeDebugSessionID, test, message));
    }
    testErrorOutput(dartCodeDebugSessionID, suitePath, testID, isFailure, message, stack) {
        const suite = this.suites[suitePath];
        const test = suite.getCurrentTest(dartCodeDebugSessionID, testID);
        if (test)
            this.testEventListeners.forEach((l) => l.testErrorOutput(dartCodeDebugSessionID, test, message, isFailure, stack));
    }
    removeNode(node) {
        const parent = node.parent;
        const index = parent.children.indexOf(node);
        if (index > -1)
            parent.children.splice(index, 1);
    }
    rangeEquals(r1, r2) {
        return this.positionEquals(r1.start, r2.start) && this.positionEquals(r1.end, r2.end);
    }
    positionEquals(p1, p2) {
        return p1.line === p2.line && p1.character === p2.character;
    }
}
exports.TestModel = TestModel;
class SuiteData {
    constructor(path, isFlutterSuite) {
        this.path = path;
        this.isFlutterSuite = isFlutterSuite;
        this.groups = new Map();
        this.tests = new Map();
        this.node = new SuiteNode(this);
    }
    getAllGroups() {
        // We need to uniq() these because we store values in the map from
        // other runs so that concurrent runs can look up parent nodes from
        // their own IDs.
        return (0, utils_1.uniq)([...this.groups.values()]);
    }
    getAllTests() {
        // We need to uniq() these because we store values in the map from
        // other runs so that concurrent runs can look up parent nodes from
        // their own IDs.
        return (0, utils_1.uniq)([...this.tests.values()]);
    }
    getCurrentTest(sessionID, id) {
        return this.tests.get(`${sessionID}_${id}`);
    }
    getMyGroup(sessionID, id) {
        return this.groups.get(`${sessionID}_${id}`);
    }
    getMyTest(sessionID, id) {
        return this.tests.get(`${sessionID}_${id}`);
    }
    storeGroup(sessionID, groupID, node) {
        return this.groups.set(`${sessionID}_${groupID}`, node);
    }
    storeTest(sessionID, testID, node) {
        return this.tests.set(`${sessionID}_${testID}`, node);
    }
    reuseMatchingGroup(groupName) {
        return this.getAllGroups().find((g) => g.name === groupName);
    }
    reuseMatchingTest(testName) {
        return this.getAllTests().find((t) => t.name === testName);
    }
}
exports.SuiteData = SuiteData;
var TestSource;
(function (TestSource) {
    TestSource[TestSource["Outline"] = 0] = "Outline";
    TestSource[TestSource["Result"] = 1] = "Result";
})(TestSource = exports.TestSource || (exports.TestSource = {}));


/***/ }),

/***/ 4586:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.disposeAll = exports.isWebDevice = exports.escapeDartString = exports.generateTestNameFromFileName = exports.clamp = exports.asHex = exports.asHexColor = exports.notNullOrUndefined = exports.notNull = exports.notUndefined = exports.nullToUndefined = exports.BufferedLogger = exports.errorString = exports.usingCustomScript = exports.isStableSdk = exports.pubVersionIsAtLeast = exports.versionIsAtLeast = exports.isDartSdkFromFlutter = exports.uriToFilePath = exports.findFileInAncestor = exports.PromiseCompleter = exports.escapeRegExp = exports.filenameSafe = exports.flatMapAsync = exports.flatMap = exports.uniq = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const semver = __webpack_require__(1249);
const constants_1 = __webpack_require__(5628);
function uniq(array) {
    return array.filter((value, index) => array.indexOf(value) === index);
}
exports.uniq = uniq;
function flatMap(input, f) {
    return input.reduce((acc, x) => acc.concat(f(x)), []);
}
exports.flatMap = flatMap;
function flatMapAsync(input, f) {
    return __awaiter(this, void 0, void 0, function* () {
        let res = [];
        for (const x of input)
            res = res.concat(yield f(x));
        return res;
    });
}
exports.flatMapAsync = flatMapAsync;
function filenameSafe(input) {
    return input.replace(/[^a-z0-9]+/gi, "_").toLowerCase();
}
exports.filenameSafe = filenameSafe;
function escapeRegExp(input) {
    return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
exports.escapeRegExp = escapeRegExp;
class PromiseCompleter {
    constructor() {
        this.promise = new Promise((res, rej) => {
            this.resolve = res;
            this.reject = rej;
        });
    }
}
exports.PromiseCompleter = PromiseCompleter;
function findFileInAncestor(files, startLocation) {
    let lastParent;
    let parent = startLocation;
    while (parent && parent.length > 1 && parent !== lastParent) {
        for (const file of files) {
            const child = path.join(parent, file);
            if (fs.existsSync(child))
                return child;
        }
        lastParent = parent;
        parent = path.dirname(parent);
    }
    return undefined;
}
exports.findFileInAncestor = findFileInAncestor;
/// Converts a file URI to file path without a dependency on vs.Uri.
function uriToFilePath(uri, returnWindowsPath = constants_1.isWin) {
    let filePath = uri;
    if (uri.startsWith("file://"))
        filePath = decodeURI(uri.substring(7));
    else if (uri.startsWith("file:"))
        filePath = decodeURI(uri.substring(5)); // TODO: Does this case ever get hit? Will it be over-decoded?
    // Windows fixup.
    if (returnWindowsPath) {
        filePath = filePath.replace(/\//g, "\\");
        if (filePath.startsWith("\\"))
            filePath = filePath.substring(1);
    }
    else {
        if (!filePath.startsWith("/"))
            filePath = `/${filePath}`;
    }
    return filePath;
}
exports.uriToFilePath = uriToFilePath;
function isDartSdkFromFlutter(dartSdkPath) {
    const possibleFlutterSdkPath = path.join(path.dirname(path.dirname(path.dirname(dartSdkPath))), "bin");
    return fs.existsSync(path.join(possibleFlutterSdkPath, constants_1.executableNames.flutter));
}
exports.isDartSdkFromFlutter = isDartSdkFromFlutter;
function versionIsAtLeast(inputVersion, requiredVersion) {
    return semver.gte(inputVersion, requiredVersion);
}
exports.versionIsAtLeast = versionIsAtLeast;
function pubVersionIsAtLeast(inputVersion, requiredVersion) {
    // Standard semver gt/lt
    if (semver.gt(inputVersion, requiredVersion))
        return true;
    else if (semver.lt(inputVersion, requiredVersion))
        return false;
    // If the versions are equal, we need to handle build metadata like pub does.
    // https://github.com/dart-lang/pub_semver/
    // If only one of them has build metadata, it's newest.
    if (inputVersion.indexOf("+") !== -1 && requiredVersion.indexOf("+") === -1)
        return true;
    if (inputVersion.indexOf("+") === -1 && requiredVersion.indexOf("+") !== -1)
        return false;
    // Otherwise, since they're both otherwise equal and both have build
    // metadata we can treat the build metadata like pre-release by converting
    // it to pre-release (with -) or appending it to existing pre-release.
    inputVersion = inputVersion.replace("+", inputVersion.indexOf("-") === -1 ? "-" : ".");
    requiredVersion = requiredVersion.replace("+", requiredVersion.indexOf("-") === -1 ? "-" : ".");
    return versionIsAtLeast(inputVersion, requiredVersion);
}
exports.pubVersionIsAtLeast = pubVersionIsAtLeast;
function isStableSdk(sdkVersion) {
    // We'll consider empty versions as dev; stable versions will likely always
    // be shipped with valid version files.
    return !!(sdkVersion && !semver.prerelease(sdkVersion));
}
exports.isStableSdk = isStableSdk;
function usingCustomScript(binPath, binArgs, customScript) {
    if (customScript === null || customScript === void 0 ? void 0 : customScript.script) {
        binPath = customScript.script;
        if (customScript.replacesArgs)
            binArgs = binArgs.slice(customScript.replacesArgs);
    }
    return { executable: binPath, args: binArgs };
}
exports.usingCustomScript = usingCustomScript;
function errorString(error) {
    if (!error)
        return "<empty error>";
    else if (error instanceof Error)
        return error.message + (error.stack ? `\n${error.stack}` : "");
    else if (error.message)
        return error.message;
    else if (typeof error === "string")
        return error;
    else
        return `${error}`;
}
exports.errorString = errorString;
class BufferedLogger {
    constructor() {
        this.buffer = [];
    }
    info(message, category) {
        this.buffer.push({ type: "info", message, category });
    }
    warn(message, category) {
        this.buffer.push({ type: "warn", message, category });
    }
    error(error, category) {
        this.buffer.push({ type: "error", message: error, category });
    }
    flushTo(logger) {
        if (!this.buffer.length)
            return;
        logger.info("Flushing log messages...");
        for (const log of this.buffer) {
            switch (log.type) {
                case "info":
                    logger.info(log.message, log.category);
                    break;
                case "warn":
                    logger.warn(log.message, log.category);
                    break;
                case "error":
                    logger.error(log.message, log.category);
                    break;
            }
        }
        logger.info("Done flushing log messages...");
    }
}
exports.BufferedLogger = BufferedLogger;
function nullToUndefined(value) {
    return (value === null ? undefined : value);
}
exports.nullToUndefined = nullToUndefined;
function notUndefined(x) {
    return x !== undefined;
}
exports.notUndefined = notUndefined;
function notNull(x) {
    return x !== null;
}
exports.notNull = notNull;
function notNullOrUndefined(x) {
    return notUndefined(x) && notNull(x);
}
exports.notNullOrUndefined = notNullOrUndefined;
function asHexColor({ r, g, b, a }) {
    r = clamp(r, 0, 255);
    g = clamp(g, 0, 255);
    b = clamp(b, 0, 255);
    a = clamp(a, 0, 255);
    return `${asHex(a)}${asHex(r)}${asHex(g)}${asHex(b)}`.toLowerCase();
}
exports.asHexColor = asHexColor;
function asHex(v) {
    return Math.round(v).toString(16).padStart(2, "0");
}
exports.asHex = asHex;
function clamp(v, min, max) {
    return Math.min(Math.max(min, v), max);
}
exports.clamp = clamp;
function generateTestNameFromFileName(input) {
    return path.basename(input).replace("_test.dart", "").replace(/_/g, " ");
}
exports.generateTestNameFromFileName = generateTestNameFromFileName;
function escapeDartString(input) {
    return input.replace(/(['"\\])/g, "\\$1");
}
exports.escapeDartString = escapeDartString;
function isWebDevice(deviceId) {
    return !!((deviceId === null || deviceId === void 0 ? void 0 : deviceId.startsWith("web")) || deviceId === "chrome" || deviceId === "edge");
}
exports.isWebDevice = isWebDevice;
function disposeAll(disposables) {
    const toDispose = disposables.slice();
    disposables.length = 0;
    for (const d of toDispose) {
        try {
            d.dispose();
        }
        catch (e) {
            console.warn(e);
        }
    }
}
exports.disposeAll = disposeAll;


/***/ }),

/***/ 7434:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayContainsArray = exports.arrayStartsWith = exports.arraysEqual = exports.unique = exports.not = exports.sortBy = void 0;
function sortBy(items, f) {
    return items.sort((item1, item2) => {
        const r1 = f(item1);
        const r2 = f(item2);
        if (r1 < r2)
            return -1;
        if (r1 > r2)
            return 1;
        return 0;
    });
}
exports.sortBy = sortBy;
function not(f) {
    return (x) => !f(x);
}
exports.not = not;
function unique(items) {
    return Array.from(new Set(items));
}
exports.unique = unique;
function arraysEqual(items1, items2) {
    return items1.length === items2.length && items1.every((val, i) => val === items2[i]);
}
exports.arraysEqual = arraysEqual;
function arrayStartsWith(items1, items2) {
    return items1.length >= items2.length && arraysEqual(items1.slice(0, items2.length), items2);
}
exports.arrayStartsWith = arrayStartsWith;
function arrayContainsArray(haystack, needle) {
    // Loop over valid starting points for the subarray
    for (let i = 0; i <= haystack.length - needle.length; i++) {
        // Check if the relevant length sublist equals the other array.
        if (arraysEqual(haystack.slice(i, i + needle.length), needle))
            return true;
    }
    return false;
}
exports.arrayContainsArray = arrayContainsArray;


/***/ }),

/***/ 9439:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stripMarkdown = exports.cleanDartdoc = void 0;
const utils_1 = __webpack_require__(4586);
const materialIconRegex = new RegExp((0, utils_1.escapeRegExp)('<i class="material-icons')
    + "(?:-([\\w]+))?"
    + (0, utils_1.escapeRegExp)(' md-36">')
    + "([\\w\\s_]+)"
    + (0, utils_1.escapeRegExp)("</i> &#x2014;")
    + "\\s+", "gi");
const cupertinoIconRegex = new RegExp((0, utils_1.escapeRegExp)(`<i class='cupertino-icons md-36'>`)
    + "([\\w\\s_]+)"
    + (0, utils_1.escapeRegExp)("</i> &#x2014;")
    + "\\s+", "gi");
const dartDocDirectives = new RegExp(`(\\n\\s*{@.*?}$)|(^{@.*?}\\s*\\n)|(^{@.*?}$)`, "gim");
const dartDocCodeBlockSections = new RegExp(`(\`\`\`\\w+) +\\w+`, "gi");
function cleanDartdoc(doc, iconPathFormat) {
    if (!doc)
        return "";
    // Clean up some dart.core dartdoc.
    const index = doc.indexOf("## Other resources");
    if (index !== -1)
        doc = doc.substring(0, index);
    // Remove colons from old-style references like [:foo:].
    doc = doc.replace(/\[:\S+:\]/g, (match) => `[${match.substring(2, match.length - 2)}]`);
    // Replace material icon HTML blocks with markdown to load the images from the correct place.
    doc = doc.replace(materialIconRegex, (_fullMatch, variant, icon) => {
        if (variant) {
            // HACK: Classnames don't match the filenames.
            if (variant === "round")
                variant = "rounded";
            icon = `${icon}_${variant}`;
        }
        const iconPath = iconPathFormat.replace("$1", `material/${icon}`);
        return `![${icon}](${iconPath}|width=32,height=32)\n\n`;
    });
    // Replace cupertino icon HTML blocks with markdown to load the images from the correct place.
    doc = doc.replace(cupertinoIconRegex, (_fullMatch, icon) => {
        const iconPath = iconPathFormat.replace("$1", `cupertino/${icon}`);
        return `![${icon}](${iconPath}|width=32,height=32)\n\n`;
    });
    // Remove any directives like {@template xxx}
    doc = doc.replace(dartDocDirectives, "");
    // Remove any code block section names like ```dart preamble
    doc = doc.replace(dartDocCodeBlockSections, "$1");
    return doc;
}
exports.cleanDartdoc = cleanDartdoc;
/// Strips markdown to make nicer plain text.
function stripMarkdown(doc) {
    if (!doc)
        return "";
    // Remove links like [foo](bar).
    doc = doc.replace(/\[(.+?)\]\(.+?\)/g, "$1");
    // Remove references like [foo].
    doc = doc.replace(/\[(.+?)\]/g, "$1");
    return doc;
}
exports.stripMarkdown = stripMarkdown;


/***/ }),

/***/ 2335:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDebugAdapterPort = exports.getDebugAdapterName = void 0;
const enums_1 = __webpack_require__(7341);
function getDebugAdapterName(debugType) {
    let debuggerName;
    switch (debugType) {
        case enums_1.DebuggerType.Flutter:
            debuggerName = "flutter";
            break;
        case enums_1.DebuggerType.FlutterTest:
            debuggerName = "flutter_test";
            break;
        case enums_1.DebuggerType.Web:
            debuggerName = "web";
            break;
        case enums_1.DebuggerType.WebTest:
            debuggerName = "web_test";
            break;
        case enums_1.DebuggerType.Dart:
            debuggerName = "dart";
            break;
        case enums_1.DebuggerType.DartTest:
            debuggerName = "dart_test";
            break;
        default:
            throw new Error(`Unknown debugger type: ${debugType}`);
    }
    return debuggerName;
}
exports.getDebugAdapterName = getDebugAdapterName;
function getDebugAdapterPort(debuggerName) {
    const debugAdapterNames = [
        "flutter",
        "flutter_test",
        "web",
        "web_test",
        "dart",
        "dart_test",
    ];
    const index = debugAdapterNames.indexOf(debuggerName);
    if (index === -1)
        throw new Error(`Unknown debugger type: ${debuggerName}`);
    return 4711 + index;
}
exports.getDebugAdapterPort = getDebugAdapterPort;


/***/ }),

/***/ 359:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterOutlineVisitorLsp = exports.FlutterOutlineVisitor = void 0;
class FlutterOutlineVisitor {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.kind) {
            case "DART_ELEMENT":
                this.visitDartElement(outline);
                break;
            case "GENERIC":
                this.visitGeneric(outline);
                break;
            case "NEW_INSTANCE":
                this.visitNewInstance(outline);
                break;
            case "INVOCATION":
                this.visitInvocation(outline);
                break;
            case "VARIABLE":
                this.visitVariable(outline);
                break;
            case "PLACEHOLDER":
                this.visitPlaceholder(outline);
                break;
            default:
                this.logger.error(`Unknown Flutter Outline item! ${outline && outline.kind}`);
        }
        if (outline.attributes) {
            for (const attribute of outline.attributes)
                this.visitAttribute(attribute);
        }
    }
    visitDartElement(outline) { this.visitChildren(outline); }
    visitGeneric(outline) { this.visitChildren(outline); }
    visitNewInstance(outline) { this.visitChildren(outline); }
    visitInvocation(outline) { this.visitChildren(outline); }
    visitVariable(outline) { this.visitChildren(outline); }
    visitPlaceholder(outline) { this.visitChildren(outline); }
    // tslint:disable-next-line: no-empty
    visitAttribute(attribute) { }
}
exports.FlutterOutlineVisitor = FlutterOutlineVisitor;
class FlutterOutlineVisitorLsp {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.kind) {
            case "DART_ELEMENT":
                this.visitDartElement(outline);
                break;
            case "GENERIC":
                this.visitGeneric(outline);
                break;
            case "NEW_INSTANCE":
                this.visitNewInstance(outline);
                break;
            case "INVOCATION":
                this.visitInvocation(outline);
                break;
            case "VARIABLE":
                this.visitVariable(outline);
                break;
            case "PLACEHOLDER":
                this.visitPlaceholder(outline);
                break;
            default:
                this.logger.error(`Unknown Flutter Outline item! ${outline && outline.kind}`);
        }
        if (outline.attributes) {
            for (const attribute of outline.attributes)
                this.visitAttribute(attribute);
        }
    }
    visitDartElement(outline) { this.visitChildren(outline); }
    visitGeneric(outline) { this.visitChildren(outline); }
    visitNewInstance(outline) { this.visitChildren(outline); }
    visitInvocation(outline) { this.visitChildren(outline); }
    visitVariable(outline) { this.visitChildren(outline); }
    visitPlaceholder(outline) { this.visitChildren(outline); }
    // tslint:disable-next-line: no-empty
    visitAttribute(attribute) { }
}
exports.FlutterOutlineVisitorLsp = FlutterOutlineVisitorLsp;


/***/ }),

/***/ 300:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nextAvailableFilename = exports.normalizeSlashes = exports.areSameFolder = exports.mkDirRecursive = exports.getRandomInt = exports.tryDeleteFile = exports.getSdkVersion = exports.findProjectFolders = exports.resolveTildePaths = exports.isFlutterRepoAsync = exports.hasCreateTriggerFileAsync = exports.hasPubspecAsync = exports.hasPubspec = exports.hasPackagesFile = exports.readDirAsync = exports.getChildFolders = exports.isEqualOrWithinPath = exports.isWithinPathOrEqual = exports.isWithinPath = exports.forceWindowsDriveLetterToUppercase = exports.fsPath = void 0;
const fs = __webpack_require__(7147);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
function fsPath(uri, { useRealCasing = false } = {}) {
    // tslint:disable-next-line:disallow-fspath
    let newPath = typeof uri === "string" ? uri : uri.fsPath;
    if (useRealCasing) {
        const realPath = fs.existsSync(newPath) && fs.realpathSync.native(newPath);
        // Since realpathSync.native will resolve symlinks, only do anything if the paths differ
        // _only_ by case.
        // when there was no symlink (eg. the lowercase version of both paths match).
        if (realPath && realPath.toLowerCase() === newPath.toLowerCase() && realPath !== newPath) {
            console.warn(`Rewriting path:\n  ${newPath}\nto:\n  ${realPath} because the casing appears munged`);
            newPath = realPath;
        }
    }
    newPath = forceWindowsDriveLetterToUppercase(newPath);
    return newPath;
}
exports.fsPath = fsPath;
function forceWindowsDriveLetterToUppercase(p) {
    if (typeof p !== "string")
        return undefined;
    if (p && constants_1.isWin && path.isAbsolute(p) && p.startsWith(p.charAt(0).toLowerCase()))
        return p.substr(0, 1).toUpperCase() + p.substr(1);
    return p;
}
exports.forceWindowsDriveLetterToUppercase = forceWindowsDriveLetterToUppercase;
function isWithinPath(file, folder) {
    const relative = path.relative(folder.toLowerCase(), file.toLowerCase());
    return !!relative && !relative.startsWith("..") && !path.isAbsolute(relative);
}
exports.isWithinPath = isWithinPath;
function isWithinPathOrEqual(file, folder) {
    const relative = path.relative(folder, file);
    return !relative || isWithinPath(file, folder);
}
exports.isWithinPathOrEqual = isWithinPathOrEqual;
function isEqualOrWithinPath(file, folder) {
    const relative = path.relative(folder.toLowerCase(), file.toLowerCase());
    return relative === "" || (!!relative && !relative.startsWith("..") && !path.isAbsolute(relative));
}
exports.isEqualOrWithinPath = isEqualOrWithinPath;
function getChildFolders(logger, parent, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!fs.existsSync(parent))
            return [];
        const files = yield readDirAsync(logger, parent);
        return files.filter((f) => f.isDirectory())
            .filter((f) => f.name !== "bin" || (options && options.allowBin)) // Don't look in bin folders
            .filter((f) => f.name !== "cache" || (options && options.allowCache)) // Don't look in cache folders
            .map((item) => path.join(parent, item.name));
    });
}
exports.getChildFolders = getChildFolders;
function readDirAsync(logger, folder) {
    return new Promise((resolve) => fs.readdir(folder, { withFileTypes: true }, (err, files) => {
        // We will generate errors if we don't have access to this folder
        // so just skip over it.
        if (err) {
            logger.warn(`Skipping folder ${folder} due to error: ${err}`);
            resolve([]);
        }
        else {
            resolve(files);
        }
    }));
}
exports.readDirAsync = readDirAsync;
function hasPackagesFile(folder) {
    return fs.existsSync(path.join(folder, ".packages"));
}
exports.hasPackagesFile = hasPackagesFile;
function hasPubspec(folder) {
    return fs.existsSync(path.join(folder, "pubspec.yaml"));
}
exports.hasPubspec = hasPubspec;
function hasPubspecAsync(folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield fileExists(path.join(folder, "pubspec.yaml"));
    });
}
exports.hasPubspecAsync = hasPubspecAsync;
function hasCreateTriggerFileAsync(folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield fileExists(path.join(folder, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE));
    });
}
exports.hasCreateTriggerFileAsync = hasCreateTriggerFileAsync;
function isFlutterRepoAsync(folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield fileExists(path.join(folder, "bin/flutter"))) && (yield fileExists(path.join(folder, "bin/cache/dart-sdk")));
    });
}
exports.isFlutterRepoAsync = isFlutterRepoAsync;
function fileExists(p) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fs.promises.access(p);
            return true;
        }
        catch (_a) {
            return false;
        }
    });
}
function resolveTildePaths(p) {
    if (typeof p !== "string")
        return undefined;
    if (p.startsWith("~/"))
        return path.join(os.homedir(), p.substr(2));
    return p;
}
exports.resolveTildePaths = resolveTildePaths;
// Walks a few levels down and returns all folders that look like project
// folders, such as:
// - have a pubspec.yaml
// - have a project create trigger file
// - are the Flutter repo root
function findProjectFolders(logger, roots, excludedFolders, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const dartToolFolderName = `${path.sep}.dart_tool${path.sep}`;
        const level2Folders = yield (0, utils_1.flatMapAsync)(roots, (f) => getChildFolders(logger, f));
        const level3Folders = yield (0, utils_1.flatMapAsync)(level2Folders, (f) => getChildFolders(logger, f));
        const allPossibleFolders = roots.concat(level2Folders).concat(level3Folders)
            .filter((f) => !f.includes(dartToolFolderName) && excludedFolders.every((ef) => !isEqualOrWithinPath(f, ef)));
        const projectFolderPromises = allPossibleFolders.map((folder) => __awaiter(this, void 0, void 0, function* () {
            return ({
                exists: options && options.requirePubspec
                    ? yield hasPubspecAsync(folder)
                    : (yield hasPubspecAsync(folder)) || (yield hasCreateTriggerFileAsync(folder)) || (yield isFlutterRepoAsync(folder)),
                folder,
            });
        }));
        const projectFoldersChecks = yield Promise.all(projectFolderPromises);
        const projectFolders = projectFoldersChecks
            .filter((res) => res.exists)
            .map((res) => res.folder);
        return options && options.sort
            ? (0, array_1.sortBy)(projectFolders, (p) => p.toLowerCase())
            : projectFolders;
    });
}
exports.findProjectFolders = findProjectFolders;
function getSdkVersion(logger, { sdkRoot }) {
    if (!sdkRoot)
        return undefined;
    const versionFile = path.join(sdkRoot, "version");
    if (!fs.existsSync(versionFile))
        return undefined;
    try {
        return fs
            .readFileSync(versionFile, "utf8")
            .trim()
            .split("\n")
            .filter((l) => l)
            .filter((l) => l.trim().substr(0, 1) !== "#")
            .join("\n")
            .trim();
    }
    catch (e) {
        logger.error(e);
        return undefined;
    }
}
exports.getSdkVersion = getSdkVersion;
function tryDeleteFile(filePath) {
    if (fs.existsSync(filePath)) {
        try {
            fs.unlinkSync(filePath);
        }
        catch (_a) {
            console.warn(`Failed to delete file ${path}.`);
        }
    }
}
exports.tryDeleteFile = tryDeleteFile;
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min;
}
exports.getRandomInt = getRandomInt;
function mkDirRecursive(folder) {
    const parent = path.dirname(folder);
    if (!fs.existsSync(parent))
        mkDirRecursive(parent);
    if (!fs.existsSync(folder))
        fs.mkdirSync(folder);
}
exports.mkDirRecursive = mkDirRecursive;
function areSameFolder(folder1, folder2) {
    // Trim any trailing path separators of either direction.
    folder1 = folder1.replace(/[\\/]+$/, "");
    folder2 = folder2.replace(/[\\/]+$/, "");
    return folder1 === folder2;
}
exports.areSameFolder = areSameFolder;
function normalizeSlashes(p) {
    return p.replace(/[\\/]/g, path.sep);
}
exports.normalizeSlashes = normalizeSlashes;
/**
 * Gets a unique path or filename for the specified {folderUri} location, appending a numerical value
 * between {prefix} and suffix, as required.
 *
 * A directory/file location will be generated from {prefix} with a trailing number (eg. `mydir1`) and
 * its existence will be checked; if it already exists, the number will be incremented and checked again.
 *
 * This will continue until a non-existent directory/file is available, or until the maxiumum search
 * limit (of 128) is reached.
 *
 * @param folder directory to check for existing directories or files.
 * @param prefix prefix of the directory/file
 * @param suffix suffix of the directory/file
 */
function nextAvailableFilename(folder, prefix, suffix = "") {
    // Set an upper bound on how many attempts we should make in getting a non-existent name.
    const maxSearchLimit = 128;
    for (let index = 1; index <= maxSearchLimit; index++) {
        const name = `${prefix}${index}${suffix}`;
        const fullPath = path.join(folder, name);
        if (!fs.existsSync(fullPath)) {
            // Name doesn't appear to exist on-disk and thus can be used - return it.
            return name;
        }
    }
    // We hit the search limit, so return {prefix}{index} (eg. mydir1) and allow the extension to
    // handle the already-exists condition if user doesn't change it manually.
    return `${prefix}1${suffix}`;
}
exports.nextAvailableFilename = nextAvailableFilename;


/***/ }),

/***/ 6074:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassOutlineVisitor = exports.TestOutlineVisitor = exports.OutlineVisitor = void 0;
const test_1 = __webpack_require__(8729);
class OutlineVisitor {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        var _a, _b, _c;
        switch ((_a = outline === null || outline === void 0 ? void 0 : outline.element) === null || _a === void 0 ? void 0 : _a.kind) {
            case "CLASS":
                this.visitClass(outline);
                break;
            case "CLASS_TYPE_ALIAS":
                this.visitClassTypeAlias(outline);
                break;
            case "COMPILATION_UNIT":
                this.visitCompilationUnit(outline);
                break;
            case "CONSTRUCTOR":
                this.visitConstructor(outline);
                break;
            case "CONSTRUCTOR_INVOCATION":
                this.visitContructorInvocation(outline);
                break;
            case "ENUM":
                this.visitEnum(outline);
                break;
            case "ENUM_CONSTANT":
                this.visitEnumConstant(outline);
                break;
            case "FIELD":
                this.visitField(outline);
                break;
            case "FILE":
                this.visitFile(outline);
                break;
            case "FUNCTION":
                this.visitFunction(outline);
                break;
            case "FUNCTION_INVOCATION":
                this.visitFunctionInvocation(outline);
                break;
            case "FUNCTION_TYPE_ALIAS":
                this.visitFunctionTypeAlias(outline);
                break;
            case "GETTER":
                this.visitGetter(outline);
                break;
            case "LABEL":
                this.visitLabel(outline);
                break;
            case "LIBRARY":
                this.visitLibrary(outline);
                break;
            case "LOCAL_VARIABLE":
                this.visitLocalVariable(outline);
                break;
            case "METHOD":
                this.visitMethod(outline);
                break;
            case "MIXIN":
                this.visitMixin(outline);
                break;
            case "PARAMETER":
                this.visitParameter(outline);
                break;
            case "PREFIX":
                this.visitPrefix(outline);
                break;
            case "SETTER":
                this.visitSetter(outline);
                break;
            case "TOP_LEVEL_VARIABLE":
                this.visitTopLevelVariable(outline);
                break;
            case "TYPE_PARAMETER":
                this.visitTypeParameter(outline);
                break;
            case "UNIT_TEST_GROUP":
                this.visitUnitTestGroup(outline);
                break;
            case "UNIT_TEST_TEST":
                this.visitUnitTestTest(outline);
                break;
            case "UNKNOWN":
                this.visitUnknown(outline);
                break;
            default:
                this.logger.error(`Unknown Outline item! ${(_b = outline === null || outline === void 0 ? void 0 : outline.element) === null || _b === void 0 ? void 0 : _b.kind} (${(_c = outline === null || outline === void 0 ? void 0 : outline.element) === null || _c === void 0 ? void 0 : _c.name})`);
        }
    }
    visitClass(outline) { this.visitChildren(outline); }
    visitClassTypeAlias(outline) { this.visitChildren(outline); }
    visitCompilationUnit(outline) { this.visitChildren(outline); }
    visitConstructor(outline) { this.visitChildren(outline); }
    visitContructorInvocation(outline) { this.visitChildren(outline); }
    visitEnum(outline) { this.visitChildren(outline); }
    visitEnumConstant(outline) { this.visitChildren(outline); }
    visitField(outline) { this.visitChildren(outline); }
    visitFile(outline) { this.visitChildren(outline); }
    visitFunction(outline) { this.visitChildren(outline); }
    visitFunctionInvocation(outline) { this.visitChildren(outline); }
    visitFunctionTypeAlias(outline) { this.visitChildren(outline); }
    visitGetter(outline) { this.visitChildren(outline); }
    visitLabel(outline) { this.visitChildren(outline); }
    visitLibrary(outline) { this.visitChildren(outline); }
    visitLocalVariable(outline) { this.visitChildren(outline); }
    visitMixin(outline) { this.visitChildren(outline); }
    visitMethod(outline) { this.visitChildren(outline); }
    visitParameter(outline) { this.visitChildren(outline); }
    visitPrefix(outline) { this.visitChildren(outline); }
    visitSetter(outline) { this.visitChildren(outline); }
    visitTopLevelVariable(outline) { this.visitChildren(outline); }
    visitTypeParameter(outline) { this.visitChildren(outline); }
    visitUnitTestGroup(outline) { this.visitChildren(outline); }
    visitUnitTestTest(outline) { this.visitChildren(outline); }
    visitUnknown(outline) { this.visitChildren(outline); }
}
exports.OutlineVisitor = OutlineVisitor;
class TestOutlineVisitor extends OutlineVisitor {
    constructor() {
        super(...arguments);
        this.tests = [];
        this.names = [];
    }
    visitUnitTestTest(outline) {
        this.addTest(outline, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.addTest(outline, super.visitUnitTestGroup);
    }
    addTest(outline, base) {
        const name = (0, test_1.extractTestNameFromOutline)(outline.element.name);
        if (!name || !outline.element.location)
            return;
        this.names.push(name);
        const fullName = this.names.join(" ");
        const isGroup = outline.element.kind === "UNIT_TEST_GROUP";
        this.tests.push({
            file: outline.element.location.file,
            fullName,
            isGroup,
            length: outline.codeLength || outline.element.location.length,
            offset: outline.codeOffset || outline.element.location.offset,
        });
        try {
            base.bind(this)(outline);
        }
        finally {
            this.names.pop();
        }
    }
}
exports.TestOutlineVisitor = TestOutlineVisitor;
class ClassOutlineVisitor extends OutlineVisitor {
    constructor() {
        super(...arguments);
        this.classes = [];
    }
    visitClass(outline) {
        this.addClass(outline);
        super.visitClass(outline);
    }
    visitMixin(outline) {
        this.addClass(outline);
        super.visitMixin(outline);
    }
    addClass(outline) {
        if (!outline.element || !outline.element.location || !outline.element.name)
            return;
        this.classes.push({
            className: outline.element.name,
            codeLength: outline.codeLength,
            codeOffset: outline.codeOffset,
            length: outline.length,
            offset: outline.offset,
        });
    }
}
exports.ClassOutlineVisitor = ClassOutlineVisitor;


/***/ }),

/***/ 4215:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspClassOutlineVisitor = exports.LspTestOutlineVisitor = exports.LspOutlineVisitor = void 0;
const test_1 = __webpack_require__(8729);
class LspOutlineVisitor {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visitNode(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.element && outline.element.kind) {
            case "CLASS":
                this.visitClass(outline);
                break;
            case "CLASS_TYPE_ALIAS":
                this.visitClassTypeAlias(outline);
                break;
            case "COMPILATION_UNIT":
                this.visitCompilationUnit(outline);
                break;
            case "CONSTRUCTOR":
                this.visitConstructor(outline);
                break;
            case "CONSTRUCTOR_INVOCATION":
                this.visitContructorInvocation(outline);
                break;
            case "ENUM":
                this.visitEnum(outline);
                break;
            case "ENUM_CONSTANT":
                this.visitEnumConstant(outline);
                break;
            case "FIELD":
                this.visitField(outline);
                break;
            case "FILE":
                this.visitFile(outline);
                break;
            case "FUNCTION":
                this.visitFunction(outline);
                break;
            case "FUNCTION_INVOCATION":
                this.visitFunctionInvocation(outline);
                break;
            case "FUNCTION_TYPE_ALIAS":
                this.visitFunctionTypeAlias(outline);
                break;
            case "GETTER":
                this.visitGetter(outline);
                break;
            case "LABEL":
                this.visitLabel(outline);
                break;
            case "LIBRARY":
                this.visitLibrary(outline);
                break;
            case "LOCAL_VARIABLE":
                this.visitLocalVariable(outline);
                break;
            case "METHOD":
                this.visitMethod(outline);
                break;
            case "MIXIN":
                this.visitMixin(outline);
                break;
            case "PARAMETER":
                this.visitParameter(outline);
                break;
            case "PREFIX":
                this.visitPrefix(outline);
                break;
            case "SETTER":
                this.visitSetter(outline);
                break;
            case "TOP_LEVEL_VARIABLE":
                this.visitTopLevelVariable(outline);
                break;
            case "TYPE_PARAMETER":
                this.visitTypeParameter(outline);
                break;
            case "UNIT_TEST_GROUP":
                this.visitUnitTestGroup(outline);
                break;
            case "UNIT_TEST_TEST":
                this.visitUnitTestTest(outline);
                break;
            case "UNKNOWN":
                this.visitUnknown(outline);
                break;
            default:
                this.logger.error(`Unknown Outline item! ${outline && outline.element && outline.element.kind}`);
        }
    }
    visitClass(outline) { this.visitChildren(outline); }
    visitClassTypeAlias(outline) { this.visitChildren(outline); }
    visitCompilationUnit(outline) { this.visitChildren(outline); }
    visitConstructor(outline) { this.visitChildren(outline); }
    visitContructorInvocation(outline) { this.visitChildren(outline); }
    visitEnum(outline) { this.visitChildren(outline); }
    visitEnumConstant(outline) { this.visitChildren(outline); }
    visitField(outline) { this.visitChildren(outline); }
    visitFile(outline) { this.visitChildren(outline); }
    visitFunction(outline) { this.visitChildren(outline); }
    visitFunctionInvocation(outline) { this.visitChildren(outline); }
    visitFunctionTypeAlias(outline) { this.visitChildren(outline); }
    visitGetter(outline) { this.visitChildren(outline); }
    visitLabel(outline) { this.visitChildren(outline); }
    visitLibrary(outline) { this.visitChildren(outline); }
    visitLocalVariable(outline) { this.visitChildren(outline); }
    visitMethod(outline) { this.visitChildren(outline); }
    visitMixin(outline) { this.visitChildren(outline); }
    visitParameter(outline) { this.visitChildren(outline); }
    visitPrefix(outline) { this.visitChildren(outline); }
    visitSetter(outline) { this.visitChildren(outline); }
    visitTopLevelVariable(outline) { this.visitChildren(outline); }
    visitTypeParameter(outline) { this.visitChildren(outline); }
    visitUnitTestGroup(outline) { this.visitChildren(outline); }
    visitUnitTestTest(outline) { this.visitChildren(outline); }
    visitUnknown(outline) { this.visitChildren(outline); }
}
exports.LspOutlineVisitor = LspOutlineVisitor;
class LspTestOutlineVisitor extends LspOutlineVisitor {
    constructor(logger, file) {
        super(logger);
        this.file = file;
        this.tests = [];
        this.testsByLine = {};
        this.names = [];
    }
    visit(outline) {
        this.tests.length = 0;
        for (const line of Object.keys(this.testsByLine)) {
            delete this.testsByLine[parseInt(line)];
        }
        super.visit(outline);
    }
    visitUnitTestTest(outline) {
        this.addTest(outline, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.addTest(outline, super.visitUnitTestGroup);
    }
    addTest(outline, base) {
        const name = (0, test_1.extractTestNameFromOutline)(outline.element.name);
        if (!name || !outline.element.range)
            return;
        this.names.push(name);
        const fullName = this.names.join(" ");
        const isGroup = outline.element.kind === "UNIT_TEST_GROUP";
        const range = outline.codeRange || outline.range || (outline.element ? outline.element.range : undefined);
        const info = {
            file: this.file,
            fullName,
            isGroup,
            range,
        };
        this.tests.push(info);
        if (range) {
            if (!this.testsByLine[range.start.line])
                this.testsByLine[range.start.line] = [];
            this.testsByLine[range.start.line].push(info);
        }
        try {
            base.bind(this)(outline);
        }
        finally {
            this.names.pop();
        }
    }
}
exports.LspTestOutlineVisitor = LspTestOutlineVisitor;
class LspClassOutlineVisitor extends LspOutlineVisitor {
    constructor() {
        super(...arguments);
        this.classes = [];
    }
    visitClass(outline) {
        this.addClass(outline);
        super.visitClass(outline);
    }
    visitMixin(outline) {
        this.addClass(outline);
        super.visitMixin(outline);
    }
    addClass(outline) {
        if (!outline.element || !outline.element.range || !outline.element.name)
            return;
        this.classes.push({
            className: outline.element.name,
            codeRange: outline.codeRange,
            range: outline.range,
        });
    }
}
exports.LspClassOutlineVisitor = LspClassOutlineVisitor;


/***/ }),

/***/ 3953:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeSettingIntoProject = exports.writeFlutterSdkSettingIntoProject = exports.writeFlutterTriggerFile = exports.writeDartSdkSettingIntoProject = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
function writeDartSdkSettingIntoProject(dartSdkPath, projectFolder) {
    writeSettingIntoProject(projectFolder, { "dart.sdkPath": dartSdkPath });
}
exports.writeDartSdkSettingIntoProject = writeDartSdkSettingIntoProject;
function writeFlutterTriggerFile(folderPath, triggerData) {
    const jsonString = triggerData ? JSON.stringify(triggerData) : "";
    fs.writeFileSync(path.join(folderPath, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE), jsonString);
}
exports.writeFlutterTriggerFile = writeFlutterTriggerFile;
function writeFlutterSdkSettingIntoProject(flutterSdkPath, projectFolder) {
    writeSettingIntoProject(projectFolder, { "dart.flutterSdkPath": flutterSdkPath });
}
exports.writeFlutterSdkSettingIntoProject = writeFlutterSdkSettingIntoProject;
function writeSettingIntoProject(projectFolder, settings) {
    const vsCodeFolder = path.join(projectFolder, ".vscode");
    const settingsFile = path.join(vsCodeFolder, "settings.json");
    if (!fs.existsSync(vsCodeFolder))
        fs.mkdirSync(vsCodeFolder);
    // The file should never exist, because the user has to select a new folder
    // to create projects. If it exists, something is wrong. We can't just load
    // the file, because VS Code settings file are not standard JSON (they can
    // have comments) so we don't want to try and deal with parsing them.
    if (fs.existsSync(settingsFile))
        return;
    fs.writeFileSync(settingsFile, JSON.stringify(settings, undefined, 4));
}
exports.writeSettingIntoProject = writeSettingIntoProject;


/***/ }),

/***/ 4411:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitFor = exports.resolvedPromise = void 0;
exports.resolvedPromise = Promise.resolve(true);
function waitFor(action, checkEveryMilliseconds = 100, tryForMilliseconds = 10000, token) {
    return __awaiter(this, void 0, void 0, function* () {
        let timeRemaining = tryForMilliseconds;
        while (timeRemaining > 0 && !(token && token.isCancellationRequested)) {
            const res = yield action();
            if (res)
                return res;
            yield new Promise((resolve) => setTimeout(resolve, checkEveryMilliseconds));
            timeRemaining -= checkEveryMilliseconds;
        }
    });
}
exports.waitFor = waitFor;


/***/ }),

/***/ 8729:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractTestNameFromOutline = exports.defaultDartTestFileContents = exports.defaultFlutterTestFileContents = exports.defaultTestFileContents = exports.createTestFileAction = exports.makeRegexForTests = exports.getLaunchConfig = void 0;
const path = __webpack_require__(1017);
const utils_1 = __webpack_require__(4586);
function getLaunchConfig(noDebug, path, testNames, runSkippedTests, template) {
    let toolArgs = [];
    if (template === null || template === void 0 ? void 0 : template.toolArgs)
        toolArgs = toolArgs.concat(template === null || template === void 0 ? void 0 : template.toolArgs);
    if (testNames) {
        toolArgs.push("--name");
        toolArgs.push(makeRegexForTests(testNames));
    }
    if (runSkippedTests)
        toolArgs.push("--run-skipped");
    return Object.assign({
        // Trailing space is a workaround for https://github.com/microsoft/vscode/issues/100115
        name: "Tests ",
        noDebug,
        request: "launch",
        type: "dart",
    }, template, {
        args: template === null || template === void 0 ? void 0 : template.args,
        expectSingleTest: (testNames === null || testNames === void 0 ? void 0 : testNames.length) === 1 && !testNames[0].name.includes("$") && !testNames[0].isGroup,
        program: path,
        toolArgs,
    });
}
exports.getLaunchConfig = getLaunchConfig;
const regexEscapedInterpolationExpressionPattern = /\\\$(?:(?:\w+)|(?:\\\{.*\\\}))/g;
function makeRegexForTests(names) {
    const regexSegments = [];
    for (const name of names) {
        const prefix = "^";
        // We can't anchor to the end for groups, as we want them to run all children.
        const suffix = name.isGroup ? "" : "( \\(variant: .*\\))?$";
        const escapedName = (0, utils_1.escapeRegExp)(name.name);
        // If a test name contains interpolated expressions, passing the exact
        // name won't match. So we just replace them out with wildcards. We'll need
        // to do this after escaping for regex, to ensure the original expression
        // is escaped but our wildcard is not.
        const substitutedName = escapedName.replace(regexEscapedInterpolationExpressionPattern, ".*");
        regexSegments.push(`${prefix}${substitutedName}${suffix}`);
    }
    return regexSegments.join("|");
}
exports.makeRegexForTests = makeRegexForTests;
const createTestFileAction = (file) => `Create ${path.basename(file)}`;
exports.createTestFileAction = createTestFileAction;
const defaultTestFileContents = (isFlutterProject, dartEscapedTestName) => isFlutterProject ? defaultFlutterTestFileContents(dartEscapedTestName) : defaultDartTestFileContents(dartEscapedTestName);
exports.defaultTestFileContents = defaultTestFileContents;
const defaultTestFileSelectionPlaceholder = "// TODO: Implement test";
function defaultFlutterTestFileContents(dartEscapedTestName) {
    const contents = `
import 'package:flutter_test/flutter_test.dart';

void main() {
  testWidgets('${dartEscapedTestName} ...', (tester) async {
    ${defaultTestFileSelectionPlaceholder}
  });
}
`.trim();
    return {
        contents,
        selectionLength: defaultTestFileSelectionPlaceholder.length,
        selectionOffset: contents.indexOf(defaultTestFileSelectionPlaceholder),
    };
}
exports.defaultFlutterTestFileContents = defaultFlutterTestFileContents;
function defaultDartTestFileContents(dartEscapedTestName) {
    const contents = `
import 'package:test/test.dart';

void main() {
  test('${dartEscapedTestName} ...', () async {
    ${defaultTestFileSelectionPlaceholder}
  });
}
`.trim();
    return {
        contents,
        selectionLength: defaultTestFileSelectionPlaceholder.length,
        selectionOffset: contents.indexOf(defaultTestFileSelectionPlaceholder),
    };
}
exports.defaultDartTestFileContents = defaultDartTestFileContents;
function extractTestNameFromOutline(elementName) {
    if (!elementName)
        return;
    // Strip off the function name/parent like test( or testWidget(
    const openParen = elementName.indexOf("(");
    const closeParen = elementName.lastIndexOf(")");
    if (openParen === -1 || closeParen === -1 || openParen >= closeParen)
        return;
    elementName = elementName.substring(openParen + 2, closeParen - 1);
    // For tests with variables, we often end up with additional quotes wrapped
    // around them...
    if ((elementName.startsWith("'") || elementName.startsWith('"')) && (elementName.endsWith("'") || elementName.endsWith('"')))
        elementName = elementName.substring(1, elementName.length - 1);
    return elementName;
}
exports.extractTestNameFromOutline = extractTestNameFromOutline;


/***/ }),

/***/ 2479:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tryProcessBazelFlutterConfig = exports.processBazelWorkspace = exports.processFuchsiaWorkspace = exports.processKnownGitRepositories = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
function processKnownGitRepositories(logger, config, gitRoot) {
    const isDartSdkRepo = fs.existsSync(path.join(gitRoot, "README.dart-sdk")) && fs.existsSync(path.join(gitRoot, ".packages"));
    if (isDartSdkRepo) {
        config.disableAutomaticPackageGet = true;
        // The Dart SDKs tests cannot run using pub, so also force them to use the VM.
        config.useVmForTests = true;
    }
}
exports.processKnownGitRepositories = processKnownGitRepositories;
function processFuchsiaWorkspace(logger, config, fuchsiaRoot) {
    config.disableAutomaticPackageGet = true;
    config.disableSdkUpdateChecks = true;
}
exports.processFuchsiaWorkspace = processFuchsiaWorkspace;
function processBazelWorkspace(logger, config, bazelWorkspaceRoot, parseFlutterJson) {
    config.disableAutomaticPackageGet = true;
    config.disableSdkUpdateChecks = true;
    if (parseFlutterJson)
        tryProcessBazelFlutterConfig(logger, config, bazelWorkspaceRoot);
}
exports.processBazelWorkspace = processBazelWorkspace;
function tryProcessBazelFlutterConfig(logger, config, bazelWorkspaceRoot) {
    // flutter.json does not support windows.
    if (constants_1.isWin)
        return;
    try {
        const flutterConfigPath = path.join(bazelWorkspaceRoot, "dart/config/intellij-plugins/flutter.json");
        if (!fs.existsSync(flutterConfigPath))
            return;
        logger.info(`Loading Bazel Flutter config from ${flutterConfigPath}`);
        const flutterConfigJson = fs.readFileSync(flutterConfigPath, "utf8");
        const flutterConfig = JSON.parse(flutterConfigJson);
        function makeFullPath(relOrAbsolute) {
            if (path.isAbsolute(relOrAbsolute))
                return relOrAbsolute;
            return path.join(bazelWorkspaceRoot, relOrAbsolute);
        }
        function makeScript(relOrAbsolute, replacesArgs = 1) {
            if (relOrAbsolute) {
                return {
                    replacesArgs,
                    script: makeFullPath(relOrAbsolute),
                };
            }
        }
        config.forceFlutterWorkspace = true;
        config.forceFlutterDebug = true;
        config.skipFlutterInitialization = true;
        config.omitTargetFlag = true;
        config.startDevToolsServerEagerly = true;
        config.startDevToolsFromDaemon = true;
        config.flutterVersion = constants_1.MAX_VERSION;
        config.flutterDaemonScript = makeScript(flutterConfig.daemonScript);
        config.flutterDoctorScript = makeScript(flutterConfig.doctorScript);
        config.flutterRunScript = makeScript(flutterConfig.runScript);
        config.flutterSdkHome = makeFullPath(flutterConfig.sdkHome);
        config.flutterSyncScript = makeFullPath(flutterConfig.syncScript);
        config.flutterTestScript = makeScript(flutterConfig.testScript);
    }
    catch (e) {
        logger.error(e);
    }
}
exports.tryProcessBazelFlutterConfig = tryProcessBazelFlutterConfig;


/***/ }),

/***/ 1197:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorRangeComputer = void 0;
const colors_1 = __webpack_require__(2241);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
class ColorRangeComputer {
    constructor() {
        this.materialNameColorPattern = "\\bColors\\.(?<mc>[\\w_\\[\\]\\.]+)";
        this.cupertinoNameColorPattern = "\\bCupertinoColors\\.(?<cc>[\\w_\\[\\]\\.]+)";
        this.cssNameColorPattern = "\\bCSSColors\\.(?<css>[\\w]+)";
        this.colorConstructorPattern = "\\bColor\\(\\s*0[xX](?<cons>[A-Fa-f0-9]{8}),{0,1}\\s*\\)";
        this.colorConstructorRgbo = "\\bColor\\.fromRGBO\\(\\s*(?<rgboR>[\\w_]+),\\s*(?<rgboG>[\\w_]+),\\s*(?<rgboB>[\\w_]+),\\s*(?<rgboO>[\\w_.]+),{0,1}\\s*\\)";
        this.colorConstructorArgb = "\\bColor\\.fromARGB\\(\\s*(?<argbA>[\\w_]+),\\s*(?<argbR>[\\w_]+),\\s*(?<argbG>[\\w_]+),\\s*(?<argbB>[\\w_]+),{0,1}\\s*\\)";
        this.allColors = [
            this.materialNameColorPattern,
            this.cupertinoNameColorPattern,
            this.cssNameColorPattern,
            this.colorConstructorPattern,
            this.colorConstructorRgbo,
            this.colorConstructorArgb,
        ];
        this.allColorsPattern = new RegExp(`^.*?(?<range>${this.allColors.join("|")})`, "gm");
    }
    compute(document) {
        const text = document.getText();
        // Build a map of all possible decorations, with those in this file. We need to include all
        // colors so if any were removed, we will clear their decorations.
        const decs = {};
        let result;
        this.allColorsPattern.lastIndex = -1;
        // eslint-disable-next-line no-cond-assign
        while (result = this.allColorsPattern.exec(text)) {
            if (!result.groups)
                continue;
            let colorHex;
            if (result.groups.mc)
                colorHex = this.extractMaterialColor(result.groups.mc);
            else if (result.groups.cc)
                colorHex = this.extractCupertinoColor(result.groups.cc);
            else if (result.groups.css)
                colorHex = this.extractCSSColor(result.groups.css);
            else if (result.groups.cons)
                colorHex = result.groups.cons.toLowerCase();
            else if (result.groups.rgboR && result.groups.rgboG && result.groups.rgboB && result.groups.rgboO)
                colorHex = this.extractRgboColor(result.groups.rgboR, result.groups.rgboG, result.groups.rgboB, result.groups.rgboO);
            else if (result.groups.argbA && result.groups.argbR && result.groups.argbG && result.groups.argbB)
                colorHex = this.extractArgbColor(result.groups.argbA, result.groups.argbR, result.groups.argbG, result.groups.argbB);
            if (colorHex) {
                if (!decs[colorHex])
                    decs[colorHex] = [];
                // We can't get the index of the captures yet (https://github.com/tc39/proposal-regexp-match-indices) but we do know
                // - the length of the whole match
                // - the length of the main capture
                // - that the main capture ends at the same point as the whole match
                // Therefore the index we want, is the (match index + match length - capture length).
                const index = result.index + result[0].length - result.groups.range.length;
                decs[colorHex].push((0, utils_2.toRange)(document, index, result.groups.range.length));
            }
        }
        return decs;
    }
    extractMaterialColor(input) {
        const colorName = input.replace(/\.shade(\d+)/, "[$1]");
        if (!(colorName in colors_1.flutterMaterialColors || `${colorName}.primary` in colors_1.flutterMaterialColors))
            return;
        return (colors_1.flutterMaterialColors[colorName] || colors_1.flutterMaterialColors[`${colorName}.primary`]).toLowerCase();
    }
    extractCupertinoColor(input) {
        const colorName = input.replace(/\.color/, "[$1]");
        if (!(colorName in colors_1.flutterCupertinoColors || `${colorName}.color` in colors_1.flutterCupertinoColors))
            return;
        return (colors_1.flutterCupertinoColors[colorName] || colors_1.flutterCupertinoColors[`${colorName}.color`]).toLowerCase();
    }
    extractCSSColor(input) {
        if (!(input in colors_1.flutterCSSColors))
            return;
        return (colors_1.flutterCSSColors[input]).toLowerCase();
    }
    extractRgboColor(inputR, inputG, inputB, inputO) {
        const r = parseInt(inputR);
        const g = parseInt(inputG);
        const b = parseInt(inputB);
        const opacity = parseFloat(inputO);
        if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(opacity))
            return;
        return (0, utils_1.asHexColor)({ r, g, b, a: opacity * 255 });
    }
    extractArgbColor(inputA, inputR, inputG, inputB) {
        const a = parseInt(inputA);
        const r = parseInt(inputR);
        const g = parseInt(inputG);
        const b = parseInt(inputB);
        if (isNaN(a) || isNaN(r) || isNaN(g) || isNaN(b))
            return;
        return (0, utils_1.asHexColor)({ a, r, g, b });
    }
}
exports.ColorRangeComputer = ColorRangeComputer;


/***/ }),

/***/ 2074:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTemplateOfType = exports.getTemplatedLaunchConfigs = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const debugTypeTokenRegex = new RegExp((0, utils_1.escapeRegExp)("${debugType}"), "gi");
function getTemplatedLaunchConfigs(document, fileType) {
    var _a, _b;
    const runConfigs = vscode_1.workspace.getConfiguration("launch", document.uri).get("configurations") || [];
    const wantedTemplateTypes = [`run-${fileType}`, `debug-${fileType}`];
    const filePath = (0, fs_1.fsPath)(document.uri);
    const workspaceUri = (_a = vscode_1.workspace.getWorkspaceFolder(document.uri)) === null || _a === void 0 ? void 0 : _a.uri;
    const workspacePath = workspaceUri ? (0, fs_1.fsPath)(workspaceUri) : undefined;
    // Loop through each launch config and add the relevant templates. Configs may be
    // added multiple times if they have multiple template types.
    const runFileTemplates = [];
    for (const templateType of wantedTemplateTypes) {
        const relevantLaunchConfigs = runConfigs
            .filter((c) => c.type === "dart" && isTemplateOfType(c, templateType))
            .filter((c) => { var _a, _b, _c; return ((_a = c.codeLens) === null || _a === void 0 ? void 0 : _a.path) && workspacePath ? (0, fs_1.isWithinPathOrEqual)(filePath, path.join(workspacePath, (_b = c.codeLens) === null || _b === void 0 ? void 0 : _b.path)) : !((_c = c.codeLens) === null || _c === void 0 ? void 0 : _c.path); });
        for (const launchConfig of relevantLaunchConfigs) {
            runFileTemplates.push(Object.assign(Object.assign({}, launchConfig), { name: (((_b = launchConfig.codeLens) === null || _b === void 0 ? void 0 : _b.title) || launchConfig.name || "${debugType}").replace(debugTypeTokenRegex, templateType.startsWith("run-") ? "Run" : "Debug"), template: templateType }));
        }
    }
    return runFileTemplates;
}
exports.getTemplatedLaunchConfigs = getTemplatedLaunchConfigs;
function isTemplateOfType(config, templateType) {
    var _a;
    const template = ((_a = config.codeLens) === null || _a === void 0 ? void 0 : _a.for) || config.template;
    return !!template && ((typeof template === "string" && template === templateType)
        || (Array.isArray(template) && template.indexOf(templateType) !== -1));
}
exports.isTemplateOfType = isTemplateOfType;


/***/ }),

/***/ 6711:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterDeviceManager = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const processes_1 = __webpack_require__(5837);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const utils_3 = __webpack_require__(7220);
class FlutterDeviceManager {
    constructor(logger, daemon, config) {
        this.logger = logger;
        this.daemon = daemon;
        this.config = config;
        this.subscriptions = [];
        this.devices = [];
        this.emulators = [];
        this.knownEmulatorNames = {};
        this.statusBarItem = vs.window.createStatusBarItem("dartStatusFlutterDevice", vs.StatusBarAlignment.Right, 1);
        this.statusBarItem.name = "Flutter Device";
        this.statusBarItem.tooltip = "Flutter";
        this.statusBarItem.command = "flutter.selectDevice";
        this.statusBarItem.show();
        this.updateStatusBar();
        // Force a request for emulators to stash their names, so we can display
        // the better name if the automatically-selected device happens to be an
        // emulator.
        this.getEmulators().then(() => this.updateStatusBar()).catch((e) => console.error(e));
        this.subscriptions.push(this.statusBarItem);
        daemon.registerForDeviceAdded(this.deviceAdded.bind(this));
        daemon.registerForDeviceRemoved(this.deviceRemoved.bind(this));
    }
    dispose() {
        (0, utils_1.disposeAll)(this.subscriptions);
    }
    isSupported(types, device) {
        // If we don't get any types to filter, assume everything is valid.
        return device && (!types || !types.length || !device.platformType || types.indexOf(device.platformType) !== -1);
    }
    deviceAdded(dev) {
        return __awaiter(this, void 0, void 0, function* () {
            dev = Object.assign(Object.assign({}, dev), { type: "device" });
            this.devices.push(dev);
            // undefined is treated as true for backwards compatibility.
            const canAutoSelectDevice = dev.ephemeral !== false;
            const maySelectThisDevice = () => {
                var _a;
                return !this.currentDevice
                    || (this.config.flutterSelectDeviceWhenConnected && canAutoSelectDevice)
                    // HACK: If the Chrome device becomes available and the selected device is
                    // web-server, allow switching because most users would prefer the Chrome device.
                    // We can revert this in future if Flutter changes the order these devices show up
                    // or has some other way of deciding priority.
                    || (((_a = this.currentDevice) === null || _a === void 0 ? void 0 : _a.id) === "web-server" && dev.id === "chrome");
            };
            if (maySelectThisDevice()) {
                // Finally, check if it's valid for the workspace. We don't want to
                // auto-select to a mobile if you have a web-only project open.
                const supportedPlatforms = yield this.getSupportedPlatformsForWorkspace();
                // We need to re-check maySelectThisDevice() as the answer may have changed if
                // another device was selected while we were awaiting (which would prevent us
                // selecting a non-ephemeral device here).
                if (maySelectThisDevice() && this.isSupported(supportedPlatforms, dev)) {
                    this.currentDevice = dev;
                    this.updateStatusBar();
                }
            }
        });
    }
    deviceRemoved(dev) {
        return __awaiter(this, void 0, void 0, function* () {
            this.devices = this.devices.filter((d) => d.id !== dev.id);
            if (this.currentDevice && this.currentDevice.id === dev.id) {
                this.currentDevice = undefined;
                // Try to select the next-best device
                if (this.devices.length) {
                    const supportedPlatforms = yield this.getSupportedPlatformsForWorkspace();
                    const supportedDevices = this.devices.filter((d) => this.isSupported(supportedPlatforms, d));
                    if (supportedDevices && supportedDevices.length)
                        this.currentDevice = supportedDevices[0];
                }
                this.updateStatusBar();
            }
        });
    }
    showDevicePicker(supportedTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            // If we weren't passed any supported types, we should try to get them for
            // the whole workspace.
            if (!supportedTypes && this.daemon.capabilities.providesPlatformTypes) {
                supportedTypes = yield this.getSupportedPlatformsForWorkspace();
            }
            const quickPick = vs.window.createQuickPick();
            quickPick.placeholder = "Select a device to use";
            quickPick.busy = true;
            let quickPickIsValid = true;
            let emulatorDevices;
            const updatePickableDeviceList = () => {
                if (!quickPickIsValid)
                    return;
                quickPick.items = this.getPickableDevices(supportedTypes, emulatorDevices);
            };
            // Kick off a request to get emulators only once.
            this.getPickableEmulators(true, supportedTypes)
                .then((emulators) => emulatorDevices = emulators)
                .finally(() => quickPick.busy = false)
                .finally(() => updatePickableDeviceList())
                .catch((e) => console.error(e));
            // If new devices are attached while the list is open, add them to the end.
            const deviceAddedSubscription = this.daemon.registerForDeviceAdded((d) => updatePickableDeviceList());
            const deviceRemovedSubscription = this.daemon.registerForDeviceRemoved((d) => updatePickableDeviceList());
            // Build the initial list.
            updatePickableDeviceList();
            const selection = yield new Promise((resolve) => {
                quickPick.onDidAccept(() => resolve(quickPick.selectedItems && quickPick.selectedItems[0]));
                quickPick.onDidHide(() => resolve(undefined));
                quickPick.show();
            });
            quickPickIsValid = false;
            quickPick.dispose();
            deviceAddedSubscription.dispose();
            deviceRemovedSubscription.dispose();
            if (selection && (yield this.selectDevice(selection)))
                return this.currentDevice;
            return undefined;
        });
    }
    selectDevice(selection) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const emulatorTypeLabel = this.emulatorLabel(selection.device.platformType);
            switch (selection.device.type) {
                case "emulator-creator":
                    // Clear the current device so we can wait for the new one
                    // to connect.
                    this.currentDevice = undefined;
                    this.statusBarItem.text = `Creating ${emulatorTypeLabel}...`;
                    yield this.createEmulator();
                    this.updateStatusBar();
                    break;
                case "emulator":
                    // Clear the current device so we can wait for the new one
                    // to connect.
                    this.currentDevice = undefined;
                    this.statusBarItem.text = `Launching ${emulatorTypeLabel}...`;
                    const coldBoot = (_a = selection.coldBoot) !== null && _a !== void 0 ? _a : false;
                    yield this.launchEmulator(selection.device, coldBoot);
                    this.updateStatusBar();
                    break;
                case "custom-emulator":
                    // Clear the current device so we can wait for the new one
                    // to connect.
                    this.currentDevice = undefined;
                    this.statusBarItem.text = `Launching ${emulatorTypeLabel}...`;
                    yield this.launchCustomEmulator(selection.device);
                    this.updateStatusBar();
                    break;
                case "platform-enabler":
                    const platformType = selection.device.platformType;
                    const platformNeedsGloballyEnabling = yield this.daemon.checkIfPlatformGloballyDisabled(platformType);
                    const action = yield vs.window.showInformationMessage((0, constants_1.runFlutterCreatePrompt)(platformType, platformNeedsGloballyEnabling), constants_1.yesAction, constants_1.cancelAction);
                    if (action !== constants_1.yesAction)
                        return false;
                    if (platformNeedsGloballyEnabling)
                        yield this.daemon.enablePlatformGlobally(platformType);
                    const createArgs = { platform: selection.device.platformType };
                    yield vs.commands.executeCommand("_flutter.create", createArgs);
                    if (platformNeedsGloballyEnabling) {
                        const restartAction = "Reload";
                        const chosenAction = yield vs.window.showInformationMessage("You must reload after enabling a new platform", restartAction, constants_1.skipAction);
                        if (chosenAction === restartAction)
                            vs.commands.executeCommand("_dart.reloadExtension");
                    }
                    break;
                case "device":
                    this.currentDevice = selection.device;
                    this.updateStatusBar();
                    break;
            }
            return true;
        });
    }
    getDevice(id) {
        return this.devices.find((d) => d.id === id);
    }
    getPickableDevices(supportedTypes, emulatorDevices) {
        const sortedDevices = this.devices.sort(this.deviceSortComparer.bind(this));
        let pickableItems = sortedDevices.filter((d) => this.isSupported(supportedTypes, d))
            .map((d) => ({
            description: d.category || d.platform,
            device: d,
            label: this.labelForDevice(d),
        }));
        // If we've got emulators, add them to the list.
        if (emulatorDevices) {
            // Fliter out any emulators we know are running.
            const emulatorIdsAlreadyRunning = this.devices.map((d) => d.emulatorId).filter((id) => id);
            pickableItems = pickableItems.concat(emulatorDevices.filter((e) => emulatorIdsAlreadyRunning.indexOf(e.device.id) === -1));
        }
        // Add any unsupported platforms that we have devices/emulators for (eg. things that could be
        // enabled) to the bottom.
        const potentialPlatformTypes = (0, utils_1.uniq)([
            ...sortedDevices.map((d) => d),
            ...this.emulators.map((e) => e),
        ]
            .filter((d) => !this.isSupported(supportedTypes, d))
            .map((d) => d.platformType)
            .filter(utils_1.notNullOrUndefined));
        pickableItems = pickableItems.concat(potentialPlatformTypes
            .map((p) => ({
            device: { type: "platform-enabler", platformType: p },
            label: `Enable ${p} for this project`,
        })));
        return pickableItems;
    }
    getSupportedPlatformsForWorkspace() {
        return __awaiter(this, void 0, void 0, function* () {
            // To avoid triggering this lots of times at startup when lots of devices "connect" at
            // the same time, we cache the results for 10 seconds. Every time we set the cache, we
            // set a timer to expire it in 10 seconds.
            if (this.shortCacheForSupportedPlatforms) {
                this.logger.info(`Returning cached promise for getSupportedPlatforms()`);
                return this.shortCacheForSupportedPlatforms;
            }
            this.shortCacheForSupportedPlatforms = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const projectFolders = yield (0, utils_2.getAllProjectFolders)(this.logger, undefined, { requirePubspec: true });
                this.logger.info(`Checking ${projectFolders.length} projects for supported platforms`);
                const getPlatformPromises = projectFolders.map((folder) => this.daemon.getSupportedPlatforms(folder));
                const resps = yield Promise.all(getPlatformPromises).catch((e) => {
                    this.logger.error(e);
                    return [];
                });
                const supportedTypes = (0, array_1.unique)((0, utils_1.flatMap)(resps, (r) => r.platforms));
                this.logger.info(`Supported platforms for the workspace are ${supportedTypes.join(", ")}`);
                resolve(supportedTypes);
                setTimeout(() => this.shortCacheForSupportedPlatforms = undefined, 10000);
            }));
            return this.shortCacheForSupportedPlatforms;
        });
    }
    labelForDevice(device) {
        let icon;
        switch (device.category) {
            case "mobile":
                icon = "$(device-mobile) ";
                break;
            case "web":
                icon = "$(browser) ";
                break;
            case "desktop":
                icon = "$(device-desktop) ";
        }
        const name = device.emulatorId && this.knownEmulatorNames[device.emulatorId] && device.platformType === "android"
            ? this.knownEmulatorNames[device.emulatorId]
            : device.name;
        return `${icon}${name}`;
    }
    deviceSortComparer(d1, d2) {
        // Always consider current device to be first.
        if (d1 === this.currentDevice)
            return -1;
        if (d2 === this.currentDevice)
            return 1;
        // Otherwise, sort by name.
        return d1.name.localeCompare(d2.name);
    }
    updateStatusBar() {
        if (this.currentDevice) {
            const emulatorLabel = this.currentDevice.emulator ? this.emulatorLabel(this.currentDevice.platformType) : "";
            const platformLabel = `${this.currentDevice.platform} ${emulatorLabel}`.trim();
            this.statusBarItem.text = `${this.labelForDevice(this.currentDevice)} (${platformLabel})`.trim();
        }
        else {
            this.statusBarItem.text = "No Device";
        }
        if (this.devices.length > 1) {
            this.statusBarItem.tooltip = `${this.devices.length} Devices Connected`;
        }
        else if (this.devices.length === 1) {
            this.statusBarItem.tooltip = `1 Device Connected`;
        }
        else {
            this.statusBarItem.tooltip = undefined;
        }
    }
    getEmulators() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const emus = yield this.daemon.getEmulators();
                const allEmulatorsByID = {};
                for (const e of emus) {
                    allEmulatorsByID[e.id] = {
                        category: e.category,
                        id: e.id,
                        name: e.name || e.id,
                        platformType: e.platformType,
                        type: "emulator",
                    };
                }
                // Add/update any custom emulators.
                for (const e of this.config.flutterCustomEmulators) {
                    const existing = allEmulatorsByID[e.id];
                    allEmulatorsByID[e.id] = Object.assign(Object.assign(Object.assign({ category: "custom" }, existing), e), { type: "custom-emulator" });
                }
                const emulators = Object.values(allEmulatorsByID);
                this.emulators = emulators;
                // Whenever we see emulators, record all their names.
                for (const e of emulators)
                    this.knownEmulatorNames[e.id] = e.name;
                return emulators;
            }
            catch (e) {
                this.logger.error({ message: e });
                return [];
            }
        });
    }
    promptForAndLaunchEmulator(allowAutomaticSelection = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const emulators = yield this.getPickableEmulators(false);
            // Because the above call is async, it's possible a device was connected while we were calling. If so,
            // just use that instead of showing the prompt.
            if (allowAutomaticSelection && this.currentDevice)
                return true;
            if (emulators.length === 0) {
                return false;
            }
            const cancellationTokenSource = new vs.CancellationTokenSource();
            const waitingForRealDeviceSubscription = this.daemon.registerForDeviceAdded(() => {
                cancellationTokenSource.cancel();
                waitingForRealDeviceSubscription.dispose();
            });
            const selectedEmulator = yield vs.window.showQuickPick(emulators, {
                matchOnDescription: true,
                placeHolder: "Connect a device or select an emulator to launch",
            }, cancellationTokenSource.token);
            waitingForRealDeviceSubscription.dispose();
            if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "emulator-creator") {
                return this.createEmulator();
            }
            else if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "emulator") {
                const coldBoot = (_a = selectedEmulator.coldBoot) !== null && _a !== void 0 ? _a : false;
                return this.launchEmulator(selectedEmulator.device, coldBoot);
            }
            else if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "custom-emulator") {
                return this.launchCustomEmulator(selectedEmulator.device);
            }
            else {
                return !!(this.currentDevice);
            }
        });
    }
    createEmulator() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Allow user to create names when we let them customise the emulator type.
            // const name = await vs.window.showInputBox({
            // 	prompt: "Enter a name for your new Android Emulator",
            // 	validateInput: this.validateEmulatorName,
            // });
            // if (!name) bail() // Pressing ENTER doesn't work, but escape does, so if
            // no name, user probably wanted to cancel
            const name = undefined;
            const create = this.daemon.createEmulator(name);
            vs.window.withProgress({
                location: vs.ProgressLocation.Notification,
                title: `${`Creating emulator ${name ? name : ""}`.trim()}...`,
            }, () => create);
            const res = yield create;
            if (res.success) {
                return this.launchEmulator({
                    id: res.emulatorName,
                    name: res.emulatorName,
                }, false);
            }
            else {
                vs.window.showErrorMessage(res.error);
                return false;
            }
        });
    }
    emulatorLabel(platformType) {
        return platformType && (platformType === "ios" || platformType === "macos")
            ? "simulator"
            : "emulator";
    }
    getPickableEmulators(showAsEmulators, supportedTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.flutterShowEmulators === "local" && !utils_3.isRunningLocally)
                return [];
            const emulators = (yield this.getEmulators())
                .filter((e) => this.isSupported(supportedTypes, e))
                .map((e) => ({
                alwaysShow: false,
                coldBoot: false,
                description: showAsEmulators ? `${e.category || "mobile"} ${this.emulatorLabel(e.platformType)}` : e.platformType || undefined,
                device: e,
                label: showAsEmulators ? "$(play) " + `Start ${e.name}` : e.name,
            }));
            // Add a cold boot option for each android based emulator
            if (this.daemon.capabilities.supportsAvdColdBootLaunch) {
                const androidEmulators = emulators.filter((e) => e.device.platformType && e.device.platformType === "android");
                androidEmulators.forEach((e) => emulators.push({
                    alwaysShow: e.alwaysShow,
                    coldBoot: true,
                    description: `${e.description} (cold boot)`,
                    device: e.device,
                    label: e.label,
                }));
            }
            // Add an option to create a new emulator if the daemon supports it.
            if (this.daemon.capabilities.canCreateEmulators && this.isSupported(supportedTypes, { platformType: "android" })) {
                emulators.push({
                    alwaysShow: true,
                    device: { type: "emulator-creator", platformType: "android", name: "Create Android emulator" },
                    label: "$(plus) " + "Create Android emulator",
                });
            }
            return emulators;
        });
    }
    launchEmulator(emulator, coldBoot) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                }, (progress) => __awaiter(this, void 0, void 0, function* () {
                    progress.report({ message: `Launching ${emulator.name}...` });
                    yield this.daemon.launchEmulator(emulator.id, coldBoot);
                    progress.report({ message: `Waiting for ${emulator.name} to connect...` });
                    // Wait up to 60 seconds for emulator to launch.
                    for (let i = 0; i < 120; i++) {
                        yield new Promise((resolve) => setTimeout(resolve, 500));
                        if (this.currentDevice)
                            return;
                    }
                    throw new Error("Emulator didn't connect within 60 seconds");
                }));
            }
            catch (e) {
                vs.window.showErrorMessage(`Failed to launch ${emulator.name}: ${e}`);
                return false;
            }
            // Wait an additional second to try and void some possible races.
            yield new Promise((resolve) => setTimeout(resolve, 1000));
            return true;
        });
    }
    launchCustomEmulator(emulator) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                }, (progress) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    progress.report({ message: `Launching ${emulator.name}...` });
                    const binPath = (0, fs_1.resolveTildePaths)(emulator.executable);
                    const args = emulator.args || [];
                    const env = (_a = emulator.env) !== null && _a !== void 0 ? _a : {};
                    const customEmulatorProc = (0, processes_1.safeSpawn)(undefined, binPath, args, env);
                    this.logger.info(`(PROC ${customEmulatorProc.pid}) Spawned ${binPath} ${args.join(" ")}`, enums_1.LogCategory.CommandProcesses);
                    (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, customEmulatorProc);
                    progress.report({ message: `Waiting for ${emulator.name} to connect...` });
                    // Wait up to 60 seconds for emulator to launch.
                    for (let i = 0; i < 120; i++) {
                        yield new Promise((resolve) => setTimeout(resolve, 500));
                        if (this.currentDevice)
                            return;
                        if (customEmulatorProc.exitCode !== null && customEmulatorProc.exitCode !== 0) {
                            throw Error(`Exit code ${customEmulatorProc.exitCode}`);
                        }
                    }
                    throw new Error("Emulator didn't connect within 60 seconds");
                }));
            }
            catch (e) {
                vs.window.showErrorMessage(`Failed to launch ${emulator.name}: ${e}`);
                return false;
            }
            // Wait an additional second to try and void some possible races.
            yield new Promise((resolve) => setTimeout(resolve, 1000));
            return true;
        });
    }
}
exports.FlutterDeviceManager = FlutterDeviceManager;


/***/ }),

/***/ 6143:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanDartdoc = exports.checkHasFlutterExtension = exports.readJson = exports.docsIconPathFormat = exports.hasFlutterExtension = exports.isDevExtension = exports.vsCodeVersionConstraint = exports.extensionVersion = exports.extensionPath = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const dartdoc = __webpack_require__(9439);
exports.extensionPath = vscode_1.extensions.getExtension(constants_1.dartCodeExtensionIdentifier).extensionPath;
exports.extensionVersion = getExtensionVersion();
exports.vsCodeVersionConstraint = getVsCodeVersionConstraint();
exports.isDevExtension = checkIsDevExtension();
exports.hasFlutterExtension = checkHasFlutterExtension();
exports.docsIconPathFormat = vscode_1.Uri.file(path.join(exports.extensionPath, "media/doc-icons/")).toString() + "$1%402x.png";
function readJson(file) {
    return JSON.parse(fs.readFileSync(file).toString());
}
exports.readJson = readJson;
function getExtensionVersion() {
    const packageJson = readJson(path.join(exports.extensionPath, "package.json"));
    return packageJson.version;
}
function getVsCodeVersionConstraint() {
    const packageJson = readJson(path.join(exports.extensionPath, "package.json"));
    return packageJson.engines.vscode;
}
function checkIsDevExtension() {
    return exports.extensionVersion.endsWith("-dev");
}
function checkHasFlutterExtension() {
    return vscode_1.extensions.getExtension(constants_1.flutterExtensionIdentifier) !== undefined;
}
exports.checkHasFlutterExtension = checkHasFlutterExtension;
function cleanDartdoc(doc) {
    return dartdoc.cleanDartdoc(doc, exports.docsIconPathFormat);
}
exports.cleanDartdoc = cleanDartdoc;


/***/ }),

/***/ 3150:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFlutterSampleInTempFolder = void 0;
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const fs_1 = __webpack_require__(300);
const projects_1 = __webpack_require__(3953);
function createFlutterSampleInTempFolder(flutterCapabilities, sampleID, flutterSdkOverride) {
    // Ensure we're on at least Flutter v1 so we know creating samples works.
    if (!flutterCapabilities.supportsCreatingSamples) {
        vs.window.showErrorMessage("Opening sample projects requires Flutter v1.0 or later");
        return;
    }
    // Create a temp folder for the sample.
    const tempSamplePath = path.join(os.tmpdir(), constants_1.dartCodeExtensionIdentifier, "flutter", "sample", sampleID, (0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16));
    // Create the empty folder so we can open it.
    (0, fs_1.mkDirRecursive)(tempSamplePath);
    const triggerData = { sample: sampleID };
    (0, projects_1.writeFlutterTriggerFile)(tempSamplePath, triggerData);
    // If we're using a custom SDK, we need to apply it to the new project too.
    if (flutterSdkOverride)
        (0, projects_1.writeFlutterSdkSettingIntoProject)(flutterSdkOverride, tempSamplePath);
    const folderUri = vs.Uri.file(tempSamplePath);
    vs.commands.executeCommand("vscode.openFolder", folderUri);
    return folderUri;
}
exports.createFlutterSampleInTempFolder = createFlutterSampleInTempFolder;


/***/ }),

/***/ 7731:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IconRangeComputerLsp = exports.IconRangeComputer = void 0;
const flutter_outline_1 = __webpack_require__(359);
const utils_1 = __webpack_require__(7220);
class IconRangeComputer {
    constructor(logger) {
        this.logger = logger;
    }
    compute(document, outline) {
        const iconVisitor = new FlutterOutlineIconVisitor(this.logger);
        iconVisitor.visit(outline);
        // Now build a map of all possible decorations, with those in this file. We need to include all
        // icons so if any were removed, we will clear their decorations.
        const decs = {};
        iconVisitor.icons.forEach((icon) => {
            const iconFile = `${icon.type}/${icon.iconName}`;
            if (!decs[iconFile])
                decs[iconFile] = [];
            decs[iconFile].push((0, utils_1.toRange)(document, icon.offset, icon.length));
        });
        return decs;
    }
}
exports.IconRangeComputer = IconRangeComputer;
class FlutterOutlineIconVisitor extends flutter_outline_1.FlutterOutlineVisitor {
    constructor() {
        super(...arguments);
        this.icons = [];
        this.materialIconValuePattern = new RegExp("^Icons\\.([\\w_]+)$");
        this.cupertinoIconValuePattern = new RegExp("^CupertinoIcons\\.([\\w_]+)$");
    }
    visitAttribute(attribute) {
        if (attribute.label && attribute.valueLocation) {
            let match = this.materialIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], offset: attribute.valueLocation.offset, type: "material", length: attribute.valueLocation.length });
            match = this.cupertinoIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], offset: attribute.valueLocation.offset, type: "cupertino", length: attribute.valueLocation.length });
        }
    }
}
class IconRangeComputerLsp {
    constructor(logger) {
        this.logger = logger;
    }
    compute(outline) {
        const iconVisitor = new FlutterOutlineIconVisitorLsp(this.logger);
        iconVisitor.visit(outline);
        // Now build a map of all possible decorations, with those in this file. We need to include all
        // icons so if any were removed, we will clear their decorations.
        const decs = {};
        iconVisitor.icons.forEach((icon) => {
            const iconFile = `${icon.type}/${icon.iconName}`;
            if (!decs[iconFile])
                decs[iconFile] = [];
            decs[iconFile].push((0, utils_1.lspToRange)(icon.range));
        });
        return decs;
    }
}
exports.IconRangeComputerLsp = IconRangeComputerLsp;
class FlutterOutlineIconVisitorLsp extends flutter_outline_1.FlutterOutlineVisitorLsp {
    constructor() {
        super(...arguments);
        this.icons = [];
        this.materialIconValuePattern = new RegExp("^Icons\\.([\\w_]+)$");
        this.cupertinoIconValuePattern = new RegExp("^CupertinoIcons\\.([\\w_]+)$");
    }
    visitAttribute(attribute) {
        if (attribute.label && attribute.valueRange) {
            let match = this.materialIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], range: attribute.valueRange, type: "material" });
            match = this.cupertinoIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], range: attribute.valueRange, type: "cupertino" });
        }
    }
}


/***/ }),

/***/ 3978:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIconForSymbolKind = void 0;
const vs = __webpack_require__(9496);
const iconsForKind = {
    [vs.SymbolKind.Array]: "indexer",
    [vs.SymbolKind.Boolean]: "boolean",
    [vs.SymbolKind.Class]: "class",
    [vs.SymbolKind.Constant]: "constant",
    [vs.SymbolKind.Constructor]: "method",
    [vs.SymbolKind.Enum]: "enumerator",
    [vs.SymbolKind.EnumMember]: "enumerator-item",
    [vs.SymbolKind.Event]: "event",
    [vs.SymbolKind.Field]: "field",
    [vs.SymbolKind.File]: "file",
    [vs.SymbolKind.Function]: "method",
    [vs.SymbolKind.Interface]: "interface",
    [vs.SymbolKind.Key]: "string",
    [vs.SymbolKind.Method]: "method",
    [vs.SymbolKind.Module]: "namespace",
    [vs.SymbolKind.Namespace]: "namespace",
    [vs.SymbolKind.Null]: "boolean",
    [vs.SymbolKind.Number]: "numeric",
    [vs.SymbolKind.Object]: "namespace",
    [vs.SymbolKind.Operator]: "operator",
    [vs.SymbolKind.Package]: "namespace",
    [vs.SymbolKind.Property]: "property",
    [vs.SymbolKind.String]: "string",
    [vs.SymbolKind.Struct]: "structure",
    [vs.SymbolKind.TypeParameter]: "type-parameter",
    [vs.SymbolKind.Variable]: "variable",
};
function getIconForSymbolKind(kind) {
    return iconsForKind[kind] || "field";
}
exports.getIconForSymbolKind = getIconForSymbolKind;


/***/ }),

/***/ 4191:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentOffsetTracker = exports.DocumentPositionTracker = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
class DocumentPositionTracker {
    constructor() {
        this.disposables = [];
        this.tracker = new DocumentOffsetTracker();
        this.positionMap = new Map();
        this.onPositionsChangedEmitter = new vs.EventEmitter();
        this.onPositionsChanged = this.onPositionsChangedEmitter.event;
        this.disposables.push(this.tracker);
        this.tracker.onOffsetsChanged(([doc, offsets]) => {
            // Map all our original positions onto new positions based on their
            // new offsets.
            const newPositions = new Map();
            for (const position of this.positionMap.keys()) {
                const currentOffset = this.positionMap.get(position);
                const newOffset = offsets.get(currentOffset);
                if (newOffset)
                    newPositions.set(position, doc.positionAt(newOffset));
                else
                    newPositions.delete(position);
            }
            this.onPositionsChangedEmitter.fire([doc, newPositions]);
        });
    }
    clear() {
        this.positionMap.clear();
        this.tracker.clear();
    }
    trackDoc(document, positions) {
        // Stash all positions as offsets.
        this.positionMap.clear();
        for (const position of positions)
            this.positionMap.set(position, document.offsetAt(position));
        // Track via the offset tracker.
        this.tracker.trackDoc(document, [...this.positionMap.values()]);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DocumentPositionTracker = DocumentPositionTracker;
class DocumentOffsetTracker {
    constructor() {
        this.disposables = [];
        this.offsetMap = new Map();
        this.onOffsetsChangedEmitter = new vs.EventEmitter();
        this.onOffsetsChanged = this.onOffsetsChangedEmitter.event;
        this.disposables.push(vs.workspace.onDidChangeTextDocument((e) => this.handleUpdate(e)));
    }
    trackDoc(document, offsets) {
        this.document = document;
        // Set all offsets to just point to themeselves.
        this.offsetMap.clear();
        for (const offset of offsets)
            this.offsetMap.set(offset, offset);
    }
    clear() {
        this.document = undefined;
        this.offsetMap.clear();
    }
    handleUpdate(e) {
        if (e.document !== this.document)
            return;
        for (const offset of [...this.offsetMap.keys()]) {
            // The key (offset) is the original offset, which we must use in the
            // map to track the current offset.
            // updateOffset takes the *value*, since we need to map the "current" (not
            // original) value, and then updates the value in the map.
            const currentOffset = this.offsetMap.get(offset);
            const newOffset = this.updateOffset(currentOffset, e);
            if (newOffset)
                this.offsetMap.set(offset, newOffset);
            else
                this.offsetMap.delete(offset);
        }
        this.onOffsetsChangedEmitter.fire([e.document, this.offsetMap]);
    }
    updateOffset(offset, change) {
        // If any edit spans us, consider us deleted.
        if (change.contentChanges.find((edit) => edit.rangeOffset < offset && edit.rangeOffset + edit.rangeLength > offset)) {
            return undefined;
        }
        // Otherwise, shift us along to account for any edits before us.
        const totalDiff = change.contentChanges
            // Edits that end before us.
            .filter((edit) => edit.rangeOffset + edit.rangeLength <= offset)
            // Get the difference in lengths to know if we inserted or removed.
            .map((edit) => edit.text.length - edit.rangeLength)
            .reduce((total, n) => total + n, 0);
        return offset + totalDiff;
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DocumentOffsetTracker = DocumentOffsetTracker;


/***/ }),

/***/ 4068:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterSampleUriHandler = void 0;
const vs = __webpack_require__(9496);
const flutter_samples_1 = __webpack_require__(3150);
class FlutterSampleUriHandler {
    constructor(flutterCapabilities) {
        this.flutterCapabilities = flutterCapabilities;
        this.validSampleIdentifierPattern = new RegExp("^[\\w\\.]+$");
    }
    handle(sampleID) {
        if (!this.isValidSampleName(sampleID)) {
            vs.window.showErrorMessage(`${sampleID} is not a valid Flutter sample identifier`);
            return;
        }
        (0, flutter_samples_1.createFlutterSampleInTempFolder)(this.flutterCapabilities, sampleID);
    }
    isValidSampleName(name) {
        return this.validSampleIdentifierPattern.test(name);
    }
}
exports.FlutterSampleUriHandler = FlutterSampleUriHandler;


/***/ }),

/***/ 5652:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartUriHandler = void 0;
const vs = __webpack_require__(9496);
const flutter_sample_handler_1 = __webpack_require__(4068);
class DartUriHandler {
    constructor(flutterCapabilities) {
        this.handlers = {
            "/flutter/sample/": new flutter_sample_handler_1.FlutterSampleUriHandler(flutterCapabilities),
        };
    }
    handleUri(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            const handlerPrefix = Object.keys(this.handlers).find((key) => uri.path.startsWith(key));
            if (handlerPrefix) {
                yield this.handlers[handlerPrefix].handle(uri.path.substr(handlerPrefix.length));
            }
            else {
                vs.window.showErrorMessage(`No handler for '${uri.path}'. Check you have the latest version of the Dart plugin and try again.`);
            }
        });
    }
}
exports.DartUriHandler = DartUriHandler;


/***/ }),

/***/ 7622:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showDevToolsNotificationIfAppropriate = exports.showFlutterSurveyNotificationIfAppropriate = void 0;
const fs = __webpack_require__(7147);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(7068);
const constants_1 = __webpack_require__(5628);
/// Shows Survey notification if appropriate. Returns whether a notification was shown
/// (not whether it was clicked/opened).
function showFlutterSurveyNotificationIfAppropriate(context, webClient, openInBrowser, now, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        let surveyData;
        try {
            const rawSurveyJson = yield webClient.fetch(constants_1.flutterSurveyDataUrl);
            const rawSurveyData = JSON.parse(rawSurveyJson);
            surveyData = Object.assign(Object.assign({}, rawSurveyData), { endDate: new Date(rawSurveyData.endDate).getTime(), startDate: new Date(rawSurveyData.startDate).getTime() });
            if (!surveyData.uniqueId || !surveyData.title || !surveyData.url)
                throw new Error(`Survey data did not include ID, Title or URL:\n${rawSurveyJson}`);
        }
        catch (e) {
            logger.error(e);
            return false;
        }
        if (now <= surveyData.startDate || now >= surveyData.endDate)
            return false;
        const lastShown = context.getFlutterSurveyNotificationLastShown(surveyData.uniqueId);
        const doNotShow = context.getFlutterSurveyNotificationDoNotShow(surveyData.uniqueId);
        // Don't show this notification if user previously said not to.
        if (doNotShow)
            return false;
        // Don't show this notification if we've shown it in the last 40 hours.
        if (lastShown && now - lastShown < constants_1.longRepeatPromptThreshold)
            return false;
        // Work out the URL and prompt to show.
        let clientID;
        try {
            const flutterSettingsFolder = constants_1.isWin ?
                process.env.APPDATA || os.homedir()
                : os.homedir();
            const flutterSettingsPath = path.join(flutterSettingsFolder, ".flutter");
            if (fs.existsSync(flutterSettingsPath)) {
                const json = fs.readFileSync(flutterSettingsPath).toString();
                const settings = JSON.parse(json);
                if (settings.enabled !== false) {
                    clientID = settings.clientId;
                }
            }
        }
        catch (_a) {
            logger.warn("Unable to read Flutter settings for preparing survey link");
        }
        const prompt = clientID ? `${surveyData.title} ${constants_1.flutterSurveyAnalyticsText}` : surveyData.title;
        const firstQsSep = surveyData.url.indexOf("?") !== -1 ? "&" : "?";
        const surveyUrl = `${surveyData.url}${firstQsSep}Source=VSCode${clientID ? `&ClientID=${encodeURIComponent(clientID)}` : ""}`;
        // Mark the last time we've shown it (now) so we can avoid showing again for
        // 40 hours.
        context.setFlutterSurveyNotificationLastShown(surveyData.uniqueId, Date.now());
        // Prompt to show and handle response.
        vs.window.showInformationMessage(prompt, constants_1.takeSurveyAction, constants_1.skipThisSurveyAction).then((choice) => __awaiter(this, void 0, void 0, function* () {
            if (choice === constants_1.skipThisSurveyAction) {
                context.setFlutterSurveyNotificationDoNotShow(surveyData.uniqueId, true);
            }
            else if (choice === constants_1.takeSurveyAction) {
                // Mark as do-not-show-again if they answer it, since it seems silly
                // to show them again if they already completed it.
                context.setFlutterSurveyNotificationDoNotShow(surveyData.uniqueId, true);
                yield openInBrowser(surveyUrl);
            }
        }));
        // Return true because we showed the notification and don't want to cause more
        // than one notification per activation.
        return true;
    });
}
exports.showFlutterSurveyNotificationIfAppropriate = showFlutterSurveyNotificationIfAppropriate;
function showDevToolsNotificationIfAppropriate(context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!vscode_1.vsCodeVersion.supportsDevTools)
            return { didOpen: false };
        const lastShown = context.devToolsNotificationLastShown;
        const doNotShow = context.devToolsNotificationDoNotShow;
        // Don't show this notification more than 10 times or if user said not to.
        if (doNotShow)
            return { didOpen: false };
        // Don't show this notification if we've shown it in the last 20 hours.
        if (lastShown && Date.now() - lastShown < constants_1.noRepeatPromptThreshold)
            return { didOpen: false };
        context.devToolsNotificationLastShown = Date.now();
        const choice = yield vs.window.showInformationMessage(constants_1.wantToTryDevToolsPrompt, constants_1.openDevToolsAction, constants_1.alwaysOpenAction, constants_1.notTodayAction, constants_1.doNotAskAgainAction);
        if (choice === constants_1.doNotAskAgainAction) {
            context.devToolsNotificationDoNotShow = true;
            return { didOpen: false };
        }
        else if (choice === constants_1.alwaysOpenAction) {
            vs.commands.executeCommand("dart.openDevTools");
            return { didOpen: true, shouldAlwaysOpen: true };
        }
        else if (choice === constants_1.openDevToolsAction) {
            vs.commands.executeCommand("dart.openDevTools");
            return { didOpen: true };
        }
        else {
            // No thanks.
            return { didOpen: false };
        }
    });
}
exports.showDevToolsNotificationIfAppropriate = showDevToolsNotificationIfAppropriate;


/***/ }),

/***/ 7220:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createWatcher = exports.firstEditorColumn = exports.firstNonEditorColumn = exports.envUtils = exports.treeLabel = exports.warnIfPathCaseMismatch = exports.trimTrailingSlashes = exports.showCode = exports.toRangeOnLine = exports.lspToPosition = exports.toPosition = exports.lspToRange = exports.toRange = exports.isDartWorkspaceFolder = exports.getAllProjectFolders = exports.getDartWorkspaceFolders = exports.isRunningLocally = exports.SourceSortMembersCodeActionKind = void 0;
const fs = __webpack_require__(7147);
const url_1 = __webpack_require__(7310);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_cloud_1 = __webpack_require__(9492);
exports.SourceSortMembersCodeActionKind = vscode_1.CodeActionKind.Source.append("sortMembers");
const dartExtension = vscode_1.extensions.getExtension(constants_1.dartCodeExtensionIdentifier);
// The extension kind is declared as Workspace, but VS Code will return UI in the
// case that there is no remote extension host.
exports.isRunningLocally = 
// Some cloud IDEs mis-report the extension kind, so if we _know_ something is a cloud IDE,
// override that.
!utils_cloud_1.isKnownCloudIde
    && (!dartExtension || dartExtension.extensionKind === vscode_1.ExtensionKind.UI);
function getDartWorkspaceFolders() {
    if (!vscode_1.workspace.workspaceFolders)
        return [];
    return vscode_1.workspace.workspaceFolders.filter(isDartWorkspaceFolder);
}
exports.getDartWorkspaceFolders = getDartWorkspaceFolders;
function getAllProjectFolders(logger, getExcludedFolders, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const workspaceFolders = getDartWorkspaceFolders();
        const topLevelFolders = workspaceFolders.map((w) => (0, fs_1.fsPath)(w.uri));
        const allExcludedFolders = getExcludedFolders ? (0, utils_1.flatMap)(workspaceFolders, getExcludedFolders) : [];
        return (0, fs_1.findProjectFolders)(logger, topLevelFolders, allExcludedFolders, options);
    });
}
exports.getAllProjectFolders = getAllProjectFolders;
function isDartWorkspaceFolder(folder) {
    if (!folder || folder.uri.scheme !== "file")
        return false;
    // Currently we don't have good logic to know what's a Dart folder.
    // We could require a pubspec, but it's valid to just write scripts without them.
    // For now, nothing calls this that will do bad things if the folder isn't a Dart
    // project so we can review amend this in future if required.
    return true;
}
exports.isDartWorkspaceFolder = isDartWorkspaceFolder;
function toRange(document, offset, length) {
    return new vscode_1.Range(document.positionAt(offset), document.positionAt(offset + length));
}
exports.toRange = toRange;
function lspToRange(range) {
    return new vscode_1.Range(lspToPosition(range.start), lspToPosition(range.end));
}
exports.lspToRange = lspToRange;
function toPosition(location) {
    return new vscode_1.Position(location.startLine - 1, location.startColumn - 1);
}
exports.toPosition = toPosition;
function lspToPosition(position) {
    return new vscode_1.Position(position.line, position.character);
}
exports.lspToPosition = lspToPosition;
// Translates an offset/length to a Range.
// NOTE: Does not wrap lines because it does not have access to a TextDocument to know
// where the line ends.
function toRangeOnLine(location) {
    const startPos = toPosition(location);
    return new vscode_1.Range(startPos, startPos.translate(0, location.length));
}
exports.toRangeOnLine = toRangeOnLine;
function showCode(editor, displayRange, highlightRange, selectionRange) {
    if (selectionRange)
        editor.selection = new vscode_1.Selection(selectionRange.start, selectionRange.end);
    // Ensure the code is visible on screen.
    editor.revealRange(displayRange, vscode_1.TextEditorRevealType.InCenterIfOutsideViewport);
    // TODO: Implement highlighting
    // See https://github.com/Microsoft/vscode/issues/45059
}
exports.showCode = showCode;
function trimTrailingSlashes(s) {
    return s.replace(/[\/\\]+$/, "");
}
exports.trimTrailingSlashes = trimTrailingSlashes;
function warnIfPathCaseMismatch(logger, p, pathDescription, helpText) {
    const userPath = trimTrailingSlashes((0, fs_1.forceWindowsDriveLetterToUppercase)(p));
    const realPath = fs.existsSync(userPath) && trimTrailingSlashes((0, fs_1.forceWindowsDriveLetterToUppercase)(fs.realpathSync.native(userPath)));
    // Since realpathSync.native will resolve symlinks, we'll only show these warnings
    // when there was no symlink (eg. the lowercase version of both paths match).
    if (userPath && realPath && userPath.toLowerCase() === realPath.toLowerCase() && userPath !== realPath) {
        const message = `The casing of ${pathDescription} does not match the casing on disk; please ${helpText}. `
            + `Expected ${realPath} but got ${userPath}`;
        logger.warn(message);
        vs.window.showWarningMessage(message);
        return true;
    }
    return false;
}
exports.warnIfPathCaseMismatch = warnIfPathCaseMismatch;
class EnvUtils {
    openInBrowser(url, logger = logging_1.nullLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info(`Opening external URL: ${url}`);
            return vscode_1.env.openExternal(vscode_1.Uri.parse(url));
        });
    }
    exposeUrl(uri, logger = logging_1.nullLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info(`Exposing URL: ${uri.toString()}`);
            const isWebSocket = uri.scheme === "ws" || uri.scheme === "wss";
            const isSecure = uri.scheme === "wss" || uri.scheme === "https";
            // TODO: Remove this scheme mapping when https://github.com/microsoft/vscode/issues/84819
            // is resolved.
            let fakeScheme = uri.scheme;
            if (isWebSocket)
                fakeScheme = isSecure ? "https" : "http";
            const url = new url_1.URL(uriToString(uri));
            // Ensure the URL always has a port, as some cloud providers fail to expose URLs correctly
            // that don't have explicit port numbers.
            //
            // Additionally, on some cloud providers we get an IPv6 loopback which fails to connect
            // correctly. Assume that if we get this, it's safe to use the "localhost" hostname.
            const fakeHostname = url.hostname === "[::]" ? "localhost" : url.hostname;
            const fakePort = url.port || (isSecure ? "443" : "80"); // Don't change to ??, port can be empty string!
            const fakeAuthority = `${fakeHostname}:${fakePort}`;
            const uriToMap = uri.with({ scheme: fakeScheme, authority: fakeAuthority });
            logger.info(`Mapping URL: ${uriToMap.toString()}`);
            const mappedUri = yield vscode_1.env.asExternalUri(uriToMap);
            logger.info(`Mapped URL: ${mappedUri.toString()}`);
            // Now we need to map the scheme back to WS if that's what was originally asked for, however
            // we need to take into account whether asExternalUri pushed is up to secure, so use
            // the http/https to decide which to go back to.
            let newScheme = mappedUri.scheme;
            if (isWebSocket)
                // Note: We use mappedUri.scheme here and not isSecure because we
                // care if the *exposed* URI is secure.
                newScheme = mappedUri.scheme === "https" ? "wss" : "ws";
            const finalUri = uriToString(mappedUri.with({ scheme: newScheme }));
            logger.info(`Final URI: ${finalUri}`);
            const finalUrl = new url_1.URL(finalUri).toString();
            logger.info(`Final URL: ${finalUrl}`);
            return finalUrl;
        });
    }
}
function uriToString(uri) {
    return uri.toString()
        .replace(/%24/g, "$")
        .replace(/%5B/g, "[");
}
function treeLabel(item) {
    if (!item.label || typeof item.label === "string")
        return item.label;
    return item.label.label;
}
exports.treeLabel = treeLabel;
exports.envUtils = new EnvUtils();
function usedEditorColumns() {
    return new Set(vs.window.visibleTextEditors.map((e) => e.viewColumn).filter(utils_1.notUndefined));
}
function firstNonEditorColumn() {
    const usedColumns = usedEditorColumns();
    for (let i = 1; i <= 9; i++) {
        if (!usedColumns.has(i))
            return i;
    }
}
exports.firstNonEditorColumn = firstNonEditorColumn;
function firstEditorColumn() {
    const usedColumns = usedEditorColumns();
    for (let i = 1; i <= 9; i++) {
        if (usedColumns.has(i))
            return i;
    }
}
exports.firstEditorColumn = firstEditorColumn;
function createWatcher(pattern, emitter) {
    const watcher = vs.workspace.createFileSystemWatcher(pattern);
    watcher.onDidChange((uri) => emitter.fire(uri));
    watcher.onDidCreate((uri) => emitter.fire(uri));
    watcher.onDidDelete((uri) => emitter.fire(uri));
    return watcher;
}
exports.createWatcher = createWatcher;


/***/ }),

/***/ 9492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isKnownCloudIde = exports.isCloudShell = exports.isTheia = void 0;
const vs = __webpack_require__(9496);
exports.isTheia = (_b = (_a = vs.env.appName) === null || _a === void 0 ? void 0 : _a.includes("Theia")) !== null && _b !== void 0 ? _b : false;
exports.isCloudShell = (_d = (_c = vs.env.appName) === null || _c === void 0 ? void 0 : _c.includes("Cloud Shell")) !== null && _d !== void 0 ? _d : false;
exports.isKnownCloudIde = exports.isTheia || exports.isCloudShell;


/***/ }),

/***/ 6105:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = void 0;
const fs_1 = __webpack_require__(300);
class Context {
    constructor(context) {
        this.context = context;
    }
    static for(context) {
        return new Context(context);
    }
    get extensionStoragePath() {
        const uri = this.context.globalStorageUri;
        const path = uri.scheme === "file" ? (0, fs_1.fsPath)(uri) : undefined;
        if (path)
            (0, fs_1.mkDirRecursive)(path);
        return path;
    }
    get devToolsNotificationLastShown() { return this.context.globalState.get("devToolsNotificationLastShown"); }
    set devToolsNotificationLastShown(value) { this.context.globalState.update("devToolsNotificationLastShown", value); }
    get devToolsNotificationDoNotShow() { return !!this.context.globalState.get("devToolsNotificationDoNotShowAgain"); }
    set devToolsNotificationDoNotShow(value) { this.context.globalState.update("devToolsNotificationDoNotShowAgain", value); }
    get breakpointOutsideWorkspaceDoNotShow() { return !!this.context.globalState.get("breakpointOutsideWorkspaceDoNotShowAgain"); }
    set breakpointOutsideWorkspaceDoNotShow(value) { this.context.globalState.update("breakpointOutsideWorkspaceDoNotShowAgain", value); }
    getFlutterSurveyNotificationLastShown(id) { return this.context.globalState.get(`flutterSurvey${id}NotificationLastShown`); }
    setFlutterSurveyNotificationLastShown(id, value) { this.context.globalState.update(`flutterSurvey${id}NotificationLastShown`, value); }
    getFlutterSurveyNotificationDoNotShow(id) { return !!this.context.globalState.get(`flutterSurvey${id}NotificationDoNotShowAgain`); }
    setFlutterSurveyNotificationDoNotShow(id, value) { this.context.globalState.update(`flutterSurvey${id}NotificationDoNotShowAgain`, value); }
    get hasWarnedAboutFormatterSyntaxLimitation() { return !!this.context.globalState.get("hasWarnedAboutFormatterSyntaxLimitation"); }
    set hasWarnedAboutFormatterSyntaxLimitation(value) { this.context.globalState.update("hasWarnedAboutFormatterSyntaxLimitation", value); }
    get hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation() { return !!this.context.globalState.get("hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation"); }
    set hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation(value) { this.context.globalState.update("hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation", value); }
    get hasNotifiedAboutProfileModeDefaultConfiguration() { return !!this.context.globalState.get("hasNotifiedAboutProfileModeDefaultConfiguration"); }
    set hasNotifiedAboutProfileModeDefaultConfiguration(value) { this.context.globalState.update("hasNotifiedAboutProfileModeDefaultConfiguration", value); }
    get lastSeenVersion() { return this.context.globalState.get("lastSeenVersion"); }
    set lastSeenVersion(value) { this.context.globalState.update("lastSeenVersion", value); }
    get lastUsedNewProjectPath() { return this.context.globalState.get("lastUsedNewProjectPath"); }
    set lastUsedNewProjectPath(value) { this.context.globalState.update("lastUsedNewProjectPath", value); }
    getPackageLastCheckedForUpdates(packageID) { return this.context.globalState.get(`packageLastCheckedForUpdates:${packageID}`); }
    setPackageLastCheckedForUpdates(packageID, value) { this.context.globalState.update(`packageLastCheckedForUpdates:${packageID}`, value); }
    update(key, value) {
        return this.context.globalState.update(key, value);
    }
    get(key) {
        return this.context.globalState.get(key);
    }
    asAbsolutePath(relativePath) {
        return this.context.asAbsolutePath(relativePath);
    }
}
exports.Context = Context;


/***/ }),

/***/ 2329:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceContext = void 0;
const events_1 = __webpack_require__(3254);
class WorkspaceContext {
    // TODO: Move things from Sdks to this class that aren't related to the SDKs.
    constructor(sdks, config, hasAnyFlutterMobileProjects, hasAnyWebProjects, hasAnyStandardDartProjects, hasProjectsInFuchsiaTree) {
        this.sdks = sdks;
        this.config = config;
        this.hasAnyFlutterMobileProjects = hasAnyFlutterMobileProjects;
        this.hasAnyWebProjects = hasAnyWebProjects;
        this.hasAnyStandardDartProjects = hasAnyStandardDartProjects;
        this.hasProjectsInFuchsiaTree = hasProjectsInFuchsiaTree;
        this.events = new WorkspaceEvents();
        this.workspaceTypeDescription = this.buildWorkspaceTypeDescription();
    }
    get hasAnyFlutterProjects() { return this.hasAnyFlutterMobileProjects; }
    get shouldLoadFlutterExtension() { return this.hasAnyFlutterProjects; }
    /// Used only for display (for ex stats), not behaviour.
    buildWorkspaceTypeDescription() {
        const types = [];
        // Don't re-order these, else stats won't easily combine as we could have
        // Dart, Flutter and also Flutter, Dart.
        if (this.hasAnyStandardDartProjects)
            types.push("Dart");
        if (this.hasAnyFlutterMobileProjects)
            types.push("Flutter");
        if (this.hasProjectsInFuchsiaTree)
            types.push("Fuchsia");
        // If we didn't detect any projects, record as unknown, but include info
        // on the type of SDK we had found.
        if (types.length === 0) {
            if (this.sdks && this.sdks.dartSdkIsFromFlutter)
                types.push("Unknown (Flutter SDK)");
            else if (this.sdks && this.sdks.dart)
                types.push("Unknown (Dart SDK)");
            else
                types.push("Unknown (No SDK)");
        }
        return types.join(", ");
    }
    dispose() {
        this.events.dispose();
    }
}
exports.WorkspaceContext = WorkspaceContext;
class WorkspaceEvents {
    constructor() {
        this.onPackageMapChange = new events_1.EventEmitter();
    }
    dispose() {
        this.onPackageMapChange.dispose();
    }
}


/***/ }),

/***/ 3870:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.RAL = void 0;
exports.CancellationStrategy = void 0;
const messages_1 = __webpack_require__(839);
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const disposable_1 = __webpack_require__(3911);
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(7135);
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(3881);
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const messageReader_1 = __webpack_require__(6525);
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(6654);
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const connection_1 = __webpack_require__(1343);
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
const ral_1 = __webpack_require__(147);
exports.RAL = ral_1.default;
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 3881:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(147);
const Is = __webpack_require__(7574);
const events_1 = __webpack_require__(7135);
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { ral_1.default().timer.clearTimeout(handle); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
//# sourceMappingURL=cancellation.js.map

/***/ }),

/***/ 1343:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;
const ral_1 = __webpack_require__(147);
const Is = __webpack_require__(7574);
const messages_1 = __webpack_require__(839);
const linkedMap_1 = __webpack_require__(6184);
const events_1 = __webpack_require__(7135);
const cancellation_1 = __webpack_require__(3881);
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    const notificationHandlers = Object.create(null);
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                const key = createRequestQueueKey(message.params.id);
                const toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = String(requestMessage.id);
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but recevied none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = String(responseMessage.id);
            const responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            notificationHandler = (params) => {
                const id = params.id;
                const source = requestTokens[String(id)];
                if (source) {
                    source.cancel();
                }
            };
        }
        else {
            const element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but recevied none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        if (type !== undefined) {
                            if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                            }
                            if (type.numberOfParams !== message.params.length) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} argumennts`);
                            }
                        }
                        notificationHandler(...message.params);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = String(responseMessage.id);
            const responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
                break;
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Recevied parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    method = type.method;
                    notificationHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        delete notificationHandlers[method];
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    cancellationStrategy.sender.sendCancellation(connection, id);
                });
            }
            const result = new Promise((resolve, reject) => {
                const requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers[type] = { handler: handler, type: undefined };
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        delete requestHandlers[method];
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            ral_1.default().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ 3911:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
//# sourceMappingURL=disposable.js.map

/***/ }),

/***/ 7135:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(147);
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                ral_1.default().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };
//# sourceMappingURL=events.js.map

/***/ }),

/***/ 7574:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ 6184:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this[Symbol.toStringTag] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        var _a;
        return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;
    }
    get last() {
        var _a;
        return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happend if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happend if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;
//# sourceMappingURL=linkedMap.js.map

/***/ }),

/***/ 5530:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;
//# sourceMappingURL=messageBuffer.js.map

/***/ }),

/***/ 6525:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(147);
const Is = __webpack_require__(7574);
const events_1 = __webpack_require__(7135);
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        var _a;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options !== null && options !== void 0 ? options : 'utf-8';
        }
        else {
            charset = (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = ral_1.default().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                const contentLength = headers.get('Content-Length');
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === undefined) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== undefined) {
                p = this.options.contentDecoder.decode(body);
            }
            else {
                p = Promise.resolve(body);
            }
            p.then((value) => {
                this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                    this.callback(msg);
                }, (error) => {
                    this.fireError(error);
                });
            }, (error) => {
                this.fireError(error);
            });
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            ral_1.default().timer.clearTimeout(this.partialMessageTimer);
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
//# sourceMappingURL=messageReader.js.map

/***/ }),

/***/ 6654:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(147);
const Is = __webpack_require__(7574);
const semaphore_1 = __webpack_require__(142);
const events_1 = __webpack_require__(7135);
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        var _a, _b;
        if (options === undefined || typeof options === 'string') {
            return { charset: options !== null && options !== void 0 ? options : 'utf-8', contentTypeEncoder: ral_1.default().applicationJson.encoder };
        }
        else {
            return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
//# sourceMappingURL=messageWriter.js.map

/***/ }),

/***/ 839:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isResponseMessage = exports.isNotificationMessage = exports.isRequestMessage = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(7574);
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = ErrorCodes.jsonrpcReservedErrorRangeStart;
    ErrorCodes.MessageWriteError = -32099;
    ErrorCodes.MessageReadError = -32098;
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = ErrorCodes.jsonrpcReservedErrorRangeEnd;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        return {
            code: this.code,
            message: this.message,
            data: this.data,
        };
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    const candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ 147:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;
//# sourceMappingURL=ral.js.map

/***/ }),

/***/ 142:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(147);
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
//# sourceMappingURL=semaphore.js.map

/***/ }),

/***/ 4389:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(3034);
// Install the node runtime abstract.
ril_1.default.install();
const api_1 = __webpack_require__(3870);
const path = __webpack_require__(1017);
const os = __webpack_require__(2037);
const crypto_1 = __webpack_require__(6113);
const net_1 = __webpack_require__(1808);
__exportStar(__webpack_require__(3870), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(ril_1.default().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super(ril_1.default().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readble, encoding) {
        super(ril_1.default().stream.asReadableStream(readble), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super(ril_1.default().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length >= limit) {
        ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return api_1.createMessageConnection(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 3034:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ral_1 = __webpack_require__(147);
const util_1 = __webpack_require__(3837);
const disposable_1 = __webpack_require__(3911);
const messageBuffer_1 = __webpack_require__(5530);
class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return disposable_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            return setTimeout(callback, ms, ...args);
        },
        clearTimeout(handle) {
            clearTimeout(handle);
        },
        setImmediate(callback, ...args) {
            return setImmediate(callback, ...args);
        },
        clearImmediate(handle) {
            clearImmediate(handle);
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        ral_1.default.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;
//# sourceMappingURL=ril.js.map

/***/ }),

/***/ 5028:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(4389);

/***/ }),

/***/ 5734:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(273), exports);
__exportStar(__webpack_require__(4384), exports);
__exportStar(__webpack_require__(7225), exports);
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 5578:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const client_1 = __webpack_require__(4384);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class CallHierarchyProvider {
    constructor(client) {
        this.client = client;
        this.middleware = client.clientOptions.middleware;
    }
    prepareCallHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareCallHierarchy = (document, position, token) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token).then((result) => {
                return client.protocol2CodeConverter.asCallHierarchyItems(result);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, error, null);
            });
        };
        return middleware.prepareCallHierarchy
            ? middleware.prepareCallHierarchy(document, position, token, prepareCallHierarchy)
            : prepareCallHierarchy(document, position, token);
    }
    provideCallHierarchyIncomingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyIncomingCalls = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asCallHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token).then((result) => {
                return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, error, null);
            });
        };
        return middleware.provideCallHierarchyIncomingCalls
            ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls)
            : provideCallHierarchyIncomingCalls(item, token);
    }
    provideCallHierarchyOutgoingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyOutgoingCalls = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asCallHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token).then((result) => {
                return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, error, null);
            });
        };
        return middleware.provideCallHierarchyOutgoingCalls
            ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls)
            : provideCallHierarchyOutgoingCalls(item, token);
    }
}
class CallHierarchyFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = ensure(ensure(capabilities, 'textDocument'), 'callHierarchy');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const client = this._client;
        const provider = new CallHierarchyProvider(client);
        return [vscode_1.languages.registerCallHierarchyProvider(options.documentSelector, provider), provider];
    }
}
exports.CallHierarchyFeature = CallHierarchyFeature;
//# sourceMappingURL=callHierarchy.js.map

/***/ }),

/***/ 4384:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseLanguageClient = exports.MessageTransports = exports.TextDocumentFeature = exports.State = exports.RevealOutputChannelOn = exports.CloseAction = exports.ErrorAction = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const configuration_1 = __webpack_require__(6495);
const c2p = __webpack_require__(71);
const p2c = __webpack_require__(8785);
const Is = __webpack_require__(9763);
const async_1 = __webpack_require__(4904);
const UUID = __webpack_require__(1980);
const progressPart_1 = __webpack_require__(8071);
class ConsoleLogger {
    error(message) {
        vscode_languageserver_protocol_1.RAL().console.error(message);
    }
    warn(message) {
        vscode_languageserver_protocol_1.RAL().console.warn(message);
    }
    info(message) {
        vscode_languageserver_protocol_1.RAL().console.info(message);
    }
    log(message) {
        vscode_languageserver_protocol_1.RAL().console.log(message);
    }
}
function createConnection(input, output, errorHandler, closeHandler, options) {
    let logger = new ConsoleLogger();
    let connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger, options);
    connection.onError((data) => { errorHandler(data[0], data[1], data[2]); });
    connection.onClose(closeHandler);
    let result = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(Is.string(type) ? type : type.method, handler),
        sendNotification: (type, params) => connection.sendNotification(Is.string(type) ? type : type.method, params),
        onNotification: (type, handler) => connection.onNotification(Is.string(type) ? type : type.method, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
            const defaultTraceOptions = {
                sendNotification: false,
                traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
            };
            if (sendNotificationOrTraceOptions === undefined) {
                connection.trace(value, tracer, defaultTraceOptions);
            }
            else if (Is.boolean(sendNotificationOrTraceOptions)) {
                connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
            else {
                connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
        },
        initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),
        shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined),
        exit: () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),
        onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),
        onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),
        onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),
        didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),
        didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),
        didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),
        didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),
        didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),
        didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),
        onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),
        end: () => connection.end(),
        dispose: () => connection.dispose()
    };
    return result;
}
/**
 * An action to be performed when the connection is producing errors.
 */
var ErrorAction;
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
/**
 * An action to be performed when the connection to a server got closed.
 */
var CloseAction;
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
class DefaultErrorHandler {
    constructor(name, maxRestartCount) {
        this.name = name;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
    }
    error(_error, _message, count) {
        if (count && count <= 3) {
            return ErrorAction.Continue;
        }
        return ErrorAction.Shutdown;
    }
    closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length <= this.maxRestartCount) {
            return CloseAction.Restart;
        }
        else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                vscode_1.window.showErrorMessage(`The ${this.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted.`);
                return CloseAction.DoNotRestart;
            }
            else {
                this.restarts.shift();
                return CloseAction.Restart;
            }
        }
    }
}
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
var State;
(function (State) {
    State[State["Stopped"] = 1] = "Stopped";
    State[State["Starting"] = 3] = "Starting";
    State[State["Running"] = 2] = "Running";
})(State = exports.State || (exports.State = {}));
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Initial"] = 0] = "Initial";
    ClientState[ClientState["Starting"] = 1] = "Starting";
    ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
    ClientState[ClientState["Running"] = 3] = "Running";
    ClientState[ClientState["Stopping"] = 4] = "Stopping";
    ClientState[ClientState["Stopped"] = 5] = "Stopped";
})(ClientState || (ClientState = {}));
const SupportedSymbolKinds = [
    vscode_languageserver_protocol_1.SymbolKind.File,
    vscode_languageserver_protocol_1.SymbolKind.Module,
    vscode_languageserver_protocol_1.SymbolKind.Namespace,
    vscode_languageserver_protocol_1.SymbolKind.Package,
    vscode_languageserver_protocol_1.SymbolKind.Class,
    vscode_languageserver_protocol_1.SymbolKind.Method,
    vscode_languageserver_protocol_1.SymbolKind.Property,
    vscode_languageserver_protocol_1.SymbolKind.Field,
    vscode_languageserver_protocol_1.SymbolKind.Constructor,
    vscode_languageserver_protocol_1.SymbolKind.Enum,
    vscode_languageserver_protocol_1.SymbolKind.Interface,
    vscode_languageserver_protocol_1.SymbolKind.Function,
    vscode_languageserver_protocol_1.SymbolKind.Variable,
    vscode_languageserver_protocol_1.SymbolKind.Constant,
    vscode_languageserver_protocol_1.SymbolKind.String,
    vscode_languageserver_protocol_1.SymbolKind.Number,
    vscode_languageserver_protocol_1.SymbolKind.Boolean,
    vscode_languageserver_protocol_1.SymbolKind.Array,
    vscode_languageserver_protocol_1.SymbolKind.Object,
    vscode_languageserver_protocol_1.SymbolKind.Key,
    vscode_languageserver_protocol_1.SymbolKind.Null,
    vscode_languageserver_protocol_1.SymbolKind.EnumMember,
    vscode_languageserver_protocol_1.SymbolKind.Struct,
    vscode_languageserver_protocol_1.SymbolKind.Event,
    vscode_languageserver_protocol_1.SymbolKind.Operator,
    vscode_languageserver_protocol_1.SymbolKind.TypeParameter
];
const SupportedCompletionItemKinds = [
    vscode_languageserver_protocol_1.CompletionItemKind.Text,
    vscode_languageserver_protocol_1.CompletionItemKind.Method,
    vscode_languageserver_protocol_1.CompletionItemKind.Function,
    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
    vscode_languageserver_protocol_1.CompletionItemKind.Field,
    vscode_languageserver_protocol_1.CompletionItemKind.Variable,
    vscode_languageserver_protocol_1.CompletionItemKind.Class,
    vscode_languageserver_protocol_1.CompletionItemKind.Interface,
    vscode_languageserver_protocol_1.CompletionItemKind.Module,
    vscode_languageserver_protocol_1.CompletionItemKind.Property,
    vscode_languageserver_protocol_1.CompletionItemKind.Unit,
    vscode_languageserver_protocol_1.CompletionItemKind.Value,
    vscode_languageserver_protocol_1.CompletionItemKind.Enum,
    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
    vscode_languageserver_protocol_1.CompletionItemKind.Color,
    vscode_languageserver_protocol_1.CompletionItemKind.File,
    vscode_languageserver_protocol_1.CompletionItemKind.Reference,
    vscode_languageserver_protocol_1.CompletionItemKind.Folder,
    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
    vscode_languageserver_protocol_1.CompletionItemKind.Constant,
    vscode_languageserver_protocol_1.CompletionItemKind.Struct,
    vscode_languageserver_protocol_1.CompletionItemKind.Event,
    vscode_languageserver_protocol_1.CompletionItemKind.Operator,
    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
];
const SupportedSymbolTags = [
    vscode_languageserver_protocol_1.SymbolTag.Deprecated
];
function ensure(target, key) {
    if (target[key] === undefined) {
        target[key] = {};
    }
    return target[key];
}
var FileFormattingOptions;
(function (FileFormattingOptions) {
    function fromConfiguration(document) {
        const filesConfig = vscode_1.workspace.getConfiguration('files', document);
        return {
            trimTrailingWhitespace: filesConfig.get('trimTrailingWhitespace'),
            trimFinalNewlines: filesConfig.get('trimFinalNewlines'),
            insertFinalNewline: filesConfig.get('insertFinalNewline'),
        };
    }
    FileFormattingOptions.fromConfiguration = fromConfiguration;
})(FileFormattingOptions || (FileFormattingOptions = {}));
var DynamicFeature;
(function (DynamicFeature) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.register) && Is.func(candidate.unregister) && Is.func(candidate.dispose) && candidate.registrationType !== undefined;
    }
    DynamicFeature.is = is;
})(DynamicFeature || (DynamicFeature = {}));
class DocumentNotifications {
    constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._middleware = _middleware;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = new Map();
    }
    static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
            if (vscode_1.languages.match(selector, textDocument)) {
                return true;
            }
        }
        return false;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(data) {
        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
            if (this._middleware) {
                this._middleware(data, (data) => this._client.sendNotification(this._type, this._createParams(data)));
            }
            else {
                this._client.sendNotification(this._type, this._createParams(data));
            }
            this.notificationSent(data);
        }
    }
    notificationSent(_data) {
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getProvider(document) {
        for (const selector of this._selectors.values()) {
            if (vscode_1.languages.match(selector, document)) {
                return {
                    send: (data) => {
                        this.callback(data);
                    }
                };
            }
        }
        return undefined;
    }
}
class DidOpenTextDocumentFeature extends DocumentNotifications {
    constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), DocumentNotifications.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
    }
    register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let documentSelector = data.registerOptions.documentSelector;
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
            let uri = textDocument.uri.toString();
            if (this._syncedDocuments.has(uri)) {
                return;
            }
            if (vscode_1.languages.match(documentSelector, textDocument)) {
                let middleware = this._client.clientOptions.middleware;
                let didOpen = (textDocument) => {
                    this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                if (middleware.didOpen) {
                    middleware.didOpen(textDocument, didOpen);
                }
                else {
                    didOpen(textDocument);
                }
                this._syncedDocuments.set(uri, textDocument);
            }
        });
    }
    notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
    }
}
class DidCloseTextDocumentFeature extends DocumentNotifications {
    constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), DocumentNotifications.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.delete(textDocument.uri.toString());
    }
    unregister(id) {
        let selector = this._selectors.get(id);
        // The super call removed the selector from the map
        // of selectors.
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
            if (vscode_1.languages.match(selector, textDocument) && !this._selectorFilter(selectors, textDocument)) {
                let middleware = this._client.clientOptions.middleware;
                let didClose = (textDocument) => {
                    this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                this._syncedDocuments.delete(textDocument.uri.toString());
                if (middleware.didClose) {
                    middleware.didClose(textDocument, didClose);
                }
                else {
                    didClose(textDocument);
                }
            }
        });
    }
}
class DidChangeTextDocumentFeature {
    constructor(_client) {
        this._client = _client;
        this._changeData = new Map();
        this._forcingDelivery = false;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== undefined && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            documentSelector: data.registerOptions.documentSelector,
            syncKind: data.registerOptions.syncKind
        });
    }
    callback(event) {
        // Text document changes are send for dirty changes as well. We don't
        // have dirty / un-dirty events in the LSP so we ignore content changes
        // with length zero.
        if (event.contentChanges.length === 0) {
            return;
        }
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, event.document)) {
                let middleware = this._client.clientOptions.middleware;
                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                    let params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event);
                    if (middleware.didChange) {
                        middleware.didChange(event, () => this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params));
                    }
                    else {
                        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                    }
                }
                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                    let didChange = (event) => {
                        if (this._changeDelayer) {
                            if (this._changeDelayer.uri !== event.document.uri.toString()) {
                                // Use this force delivery to track boolean state. Otherwise we might call two times.
                                this.forceDelivery();
                                this._changeDelayer.uri = event.document.uri.toString();
                            }
                            this._changeDelayer.delayer.trigger(() => {
                                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));
                            });
                        }
                        else {
                            this._changeDelayer = {
                                uri: event.document.uri.toString(),
                                delayer: new async_1.Delayer(200)
                            };
                            this._changeDelayer.delayer.trigger(() => {
                                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));
                            }, -1);
                        }
                    };
                    if (middleware.didChange) {
                        middleware.didChange(event, didChange);
                    }
                    else {
                        didChange(event);
                    }
                }
            }
        }
    }
    unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._changeDelayer = undefined;
        this._forcingDelivery = false;
        this._changeData.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    forceDelivery() {
        if (this._forcingDelivery || !this._changeDelayer) {
            return;
        }
        try {
            this._forcingDelivery = true;
            this._changeDelayer.delayer.forceDelivery();
        }
        finally {
            this._forcingDelivery = false;
        }
    }
    getProvider(document) {
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, document)) {
                return {
                    send: (event) => {
                        this.callback(event);
                    }
                };
            }
        }
        return undefined;
    }
}
class WillSaveFeature extends DocumentNotifications {
    constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifications.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
}
class WillSaveWaitUntilFeature {
    constructor(_client) {
        this._client = _client;
        this._selectors = new Map();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSaveWaitUntil = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(event) {
        if (DocumentNotifications.textDocumentFilter(this._selectors.values(), event.document)) {
            let middleware = this._client.clientOptions.middleware;
            let willSaveWaitUntil = (event) => {
                return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then((edits) => {
                    let vEdits = this._client.protocol2CodeConverter.asTextEdits(edits);
                    return vEdits === undefined ? [] : vEdits;
                });
            };
            event.waitUntil(middleware.willSaveWaitUntil
                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)
                : willSaveWaitUntil(event));
        }
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
class DidSaveTextDocumentFeature extends DocumentNotifications {
    constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifications.textDocumentFilter);
        this._includeText = false;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').didSave = true;
    }
    initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            const saveOptions = typeof textDocumentSyncOptions.save === 'boolean'
                ? { includeText: false }
                : { includeText: !!textDocumentSyncOptions.save.includeText };
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, saveOptions)
            });
        }
    }
    register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
    }
}
class FileSystemWatcherFeature {
    constructor(_client, _notifyFileEvent) {
        this._client = _client;
        this._notifyFileEvent = _notifyFileEvent;
        this._watchers = new Map();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;
    }
    initialize(_capabilities, _documentSelector) {
    }
    register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
            return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
            if (!Is.string(watcher.globPattern)) {
                continue;
            }
            let watchCreate = true, watchChange = true, watchDelete = true;
            if (watcher.kind !== undefined && watcher.kind !== null) {
                watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
                watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
                watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
            }
            let fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete);
            disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
    }
    registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
            this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
    }
    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
            fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Created
            }), null, listeners);
        }
        if (watchChange) {
            fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }), null, listeners);
        }
        if (watchDelete) {
            fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }), null, listeners);
        }
    }
    unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        }
    }
    dispose() {
        this._watchers.forEach((disposables) => {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        });
        this._watchers.clear();
    }
}
class TextDocumentFeature {
    constructor(_client, _registrationType) {
        this._client = _client;
        this._registrationType = _registrationType;
        this._registrations = new Map();
    }
    get registrationType() {
        return this._registrationType;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((value) => {
            value.disposable.dispose();
        });
        this._registrations.clear();
    }
    getRegistration(documentSelector, capability) {
        if (!capability) {
            return [undefined, undefined];
        }
        else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
            const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            const selector = capability.documentSelector || documentSelector;
            if (selector) {
                return [id, Object.assign({}, capability, { documentSelector: selector })];
            }
        }
        else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
            if (!documentSelector) {
                return [undefined, undefined];
            }
            let options = (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
            return [UUID.generateUuid(), options];
        }
        return [undefined, undefined];
    }
    getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
            return undefined;
        }
        return (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
    }
    getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
            let selector = registration.data.registerOptions.documentSelector;
            if (selector !== null && vscode_1.languages.match(selector, textDocument)) {
                return registration.provider;
            }
        }
        return undefined;
    }
    getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
            result.push(item.provider);
        }
        return result;
    }
}
exports.TextDocumentFeature = TextDocumentFeature;
class WorkspaceFeature {
    constructor(_client, _registrationType) {
        this._client = _client;
        this._registrationType = _registrationType;
        this._registrations = new Map();
    }
    get registrationType() {
        return this._registrationType;
    }
    register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((registration) => {
            registration.disposable.dispose();
        });
        this._registrations.clear();
    }
    getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
            result.push(registration.provider);
        }
        return result;
    }
}
class CompletionItemFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let completion = ensure(ensure(capabilities, 'textDocument'), 'completion');
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
            snippetSupport: true,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true,
            tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
            insertReplaceSupport: true,
            resolveSupport: {
                properties: ['documentation', 'detail', 'additionalTextEdits']
            },
            insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] }
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const triggerCharacters = options.triggerCharacters || [];
        const provider = {
            provideCompletionItems: (document, position, token, context) => {
                const client = this._client;
                const middleware = this._client.clientOptions.middleware;
                const provideCompletionItems = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document, position, context), token).then(client.protocol2CodeConverter.asCompletionResult, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, error, null);
                    });
                };
                return middleware.provideCompletionItem
                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)
                    : provideCompletionItems(document, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.clientOptions.middleware;
                    const resolveCompletionItem = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item), token).then(client.protocol2CodeConverter.asCompletionItem, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, error, item);
                        });
                    };
                    return middleware.resolveCompletionItem
                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)
                        : resolveCompletionItem(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCompletionItemProvider(options.documentSelector, provider, ...triggerCharacters), provider];
    }
}
class HoverFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const hoverCapability = (ensure(ensure(capabilities, 'textDocument'), 'hover'));
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideHover: (document, position, token) => {
                const client = this._client;
                const provideHover = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asHover, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideHover
                    ? middleware.provideHover(document, position, token, provideHover)
                    : provideHover(document, position, token);
            }
        };
        return [vscode_1.languages.registerHoverProvider(options.documentSelector, provider), provider];
    }
}
class SignatureHelpFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let config = ensure(ensure(capabilities, 'textDocument'), 'signatureHelp');
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
        config.signatureInformation.activeParameterSupport = true;
        config.contextSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSignatureHelp: (document, position, token, context) => {
                const client = this._client;
                const providerSignatureHelp = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document, position, context), token).then(client.protocol2CodeConverter.asSignatureHelp, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideSignatureHelp
                    ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp)
                    : providerSignatureHelp(document, position, context, token);
            }
        };
        let disposable;
        if (options.retriggerCharacters === undefined) {
            const triggerCharacters = options.triggerCharacters || [];
            disposable = vscode_1.languages.registerSignatureHelpProvider(options.documentSelector, provider, ...triggerCharacters);
        }
        else {
            const metaData = {
                triggerCharacters: options.triggerCharacters || [],
                retriggerCharacters: options.retriggerCharacters || []
            };
            disposable = vscode_1.languages.registerSignatureHelpProvider(options.documentSelector, provider, metaData);
        }
        return [disposable, provider];
    }
}
class DefinitionFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let definitionSupport = ensure(ensure(capabilities, 'textDocument'), 'definition');
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDefinition: (document, position, token) => {
                const client = this._client;
                const provideDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDefinition
                    ? middleware.provideDefinition(document, position, token, provideDefinition)
                    : provideDefinition(document, position, token);
            }
        };
        return [vscode_1.languages.registerDefinitionProvider(options.documentSelector, provider), provider];
    }
}
class ReferencesFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'references').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideReferences: (document, position, options, token) => {
                const client = this._client;
                const _providerReferences = (document, position, options, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document, position, options), token).then(client.protocol2CodeConverter.asReferences, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideReferences
                    ? middleware.provideReferences(document, position, options, token, _providerReferences)
                    : _providerReferences(document, position, options, token);
            }
        };
        return [vscode_1.languages.registerReferenceProvider(options.documentSelector, provider), provider];
    }
}
class DocumentHighlightFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'documentHighlight').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentHighlights: (document, position, token) => {
                const client = this._client;
                const _provideDocumentHighlights = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDocumentHighlights, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentHighlights
                    ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights)
                    : _provideDocumentHighlights(document, position, token);
            }
        };
        return [vscode_1.languages.registerDocumentHighlightProvider(options.documentSelector, provider), provider];
    }
}
class DocumentSymbolFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, 'textDocument'), 'documentSymbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
            valueSet: SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentSymbols: (document, token) => {
                const client = this._client;
                const _provideDocumentSymbols = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document), token).then((data) => {
                        if (data === null) {
                            return undefined;
                        }
                        if (data.length === 0) {
                            return [];
                        }
                        else {
                            let element = data[0];
                            if (vscode_languageserver_protocol_1.DocumentSymbol.is(element)) {
                                return client.protocol2CodeConverter.asDocumentSymbols(data);
                            }
                            else {
                                return client.protocol2CodeConverter.asSymbolInformations(data);
                            }
                        }
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentSymbols
                    ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols)
                    : _provideDocumentSymbols(document, token);
            }
        };
        const metaData = options.label !== undefined ? { label: options.label } : undefined;
        return [vscode_1.languages.registerDocumentSymbolProvider(options.documentSelector, provider, metaData), provider];
    }
}
class WorkspaceSymbolFeature extends WorkspaceFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, 'workspace'), 'symbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
            valueSet: SupportedSymbolTags
        };
    }
    initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
    }
    registerLanguageProvider(_options) {
        const provider = {
            provideWorkspaceSymbols: (query, token) => {
                const client = this._client;
                const provideWorkspaceSymbols = (query, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query }, token).then(client.protocol2CodeConverter.asSymbolInformations, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideWorkspaceSymbols
                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)
                    : provideWorkspaceSymbols(query, token);
            }
        };
        return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
    }
}
class CodeActionFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const cap = ensure(ensure(capabilities, 'textDocument'), 'codeAction');
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        // We can only resolve the edit property.
        cap.resolveSupport = {
            properties: ['edit']
        };
        cap.codeActionLiteralSupport = {
            codeActionKind: {
                valueSet: [
                    vscode_languageserver_protocol_1.CodeActionKind.Empty,
                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                    vscode_languageserver_protocol_1.CodeActionKind.Source,
                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
                ]
            }
        };
        cap.honorsChangeAnnotations = false;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideCodeActions: (document, range, context, token) => {
                const client = this._client;
                const _provideCodeActions = (document, range, context, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        context: client.code2ProtocolConverter.asCodeActionContext(context)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then((values) => {
                        if (values === null) {
                            return undefined;
                        }
                        const result = [];
                        for (let item of values) {
                            if (vscode_languageserver_protocol_1.Command.is(item)) {
                                result.push(client.protocol2CodeConverter.asCommand(item));
                            }
                            else {
                                result.push(client.protocol2CodeConverter.asCodeAction(item));
                            }
                        }
                        return result;
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideCodeActions
                    ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions)
                    : _provideCodeActions(document, range, context, token);
            },
            resolveCodeAction: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.clientOptions.middleware;
                    const resolveCodeAction = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, client.code2ProtocolConverter.asCodeAction(item), token).then(client.protocol2CodeConverter.asCodeAction, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, error, item);
                        });
                    };
                    return middleware.resolveCodeAction
                        ? middleware.resolveCodeAction(item, token, resolveCodeAction)
                        : resolveCodeAction(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeActionsProvider(options.documentSelector, provider, (options.codeActionKinds
                ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) }
                : undefined)), provider];
    }
}
class CodeLensFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'codeLens').dynamicRegistration = true;
        ensure(ensure(capabilities, 'workspace'), 'codeLens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeCodeLensEmitter.fire();
            }
        });
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeCodeLenses: eventEmitter.event,
            provideCodeLenses: (document, token) => {
                const client = this._client;
                const provideCodeLenses = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document), token).then(client.protocol2CodeConverter.asCodeLenses, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideCodeLenses
                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)
                    : provideCodeLenses(document, token);
            },
            resolveCodeLens: (options.resolveProvider)
                ? (codeLens, token) => {
                    const client = this._client;
                    const resolveCodeLens = (codeLens, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens), token).then(client.protocol2CodeConverter.asCodeLens, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, error, codeLens);
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.resolveCodeLens
                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)
                        : resolveCodeLens(codeLens, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeLensProvider(options.documentSelector, provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
    }
}
class DocumentFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'formatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentFormattingEdits: (document, options, token) => {
                const client = this._client;
                const provideDocumentFormattingEdits = (document, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentFormattingEdits
                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)
                    : provideDocumentFormattingEdits(document, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentFormattingEditProvider(options.documentSelector, provider), provider];
    }
}
class DocumentRangeFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentRangeFormattingEdits: (document, range, options, token) => {
                const client = this._client;
                const provideDocumentRangeFormattingEdits = (document, range, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentRangeFormattingEdits
                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)
                    : provideDocumentRangeFormattingEdits(document, range, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(options.documentSelector, provider), provider];
    }
}
class DocumentOnTypeFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideOnTypeFormattingEdits: (document, position, ch, options, token) => {
                const client = this._client;
                const provideOnTypeFormattingEdits = (document, position, ch, options, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        ch: ch,
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideOnTypeFormattingEdits
                    ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)
                    : provideOnTypeFormattingEdits(document, position, ch, options, token);
            }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        return [vscode_1.languages.registerOnTypeFormattingEditProvider(options.documentSelector, provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
    }
}
class RenameFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let rename = ensure(ensure(capabilities, 'textDocument'), 'rename');
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
        rename.honorsChangeAnnotations = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
            return;
        }
        if (Is.boolean(capabilities.renameProvider)) {
            options.prepareProvider = false;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideRenameEdits: (document, position, newName, token) => {
                const client = this._client;
                const provideRenameEdits = (document, position, newName, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        newName: newName
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then(client.protocol2CodeConverter.asWorkspaceEdit, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideRenameEdits
                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)
                    : provideRenameEdits(document, position, newName, token);
            },
            prepareRename: options.prepareProvider
                ? (document, position, token) => {
                    const client = this._client;
                    const prepareRename = (document, position, token) => {
                        let params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            position: client.code2ProtocolConverter.asPosition(position),
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token).then((result) => {
                            if (vscode_languageserver_protocol_1.Range.is(result)) {
                                return client.protocol2CodeConverter.asRange(result);
                            }
                            else if (this.isDefaultBehavior(result)) {
                                return result.defaultBehavior === true
                                    ? null
                                    : Promise.reject(new Error(`The element can't be renamed.`));
                            }
                            else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                                return {
                                    range: client.protocol2CodeConverter.asRange(result.range),
                                    placeholder: result.placeholder
                                };
                            }
                            // To cancel the rename vscode API expects a rejected promise.
                            return Promise.reject(new Error(`The element can't be renamed.`));
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, error, undefined);
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.prepareRename
                        ? middleware.prepareRename(document, position, token, prepareRename)
                        : prepareRename(document, position, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerRenameProvider(options.documentSelector, provider), provider];
    }
    isDefaultBehavior(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.defaultBehavior);
    }
}
class DocumentLinkFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = ensure(ensure(capabilities, 'textDocument'), 'documentLink');
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentLinks: (document, token) => {
                const client = this._client;
                const provideDocumentLinks = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document), token).then(client.protocol2CodeConverter.asDocumentLinks, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentLinks
                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)
                    : provideDocumentLinks(document, token);
            },
            resolveDocumentLink: options.resolveProvider
                ? (link, token) => {
                    const client = this._client;
                    let resolveDocumentLink = (link, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link), token).then(client.protocol2CodeConverter.asDocumentLink, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, error, link);
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.resolveDocumentLink
                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)
                        : resolveDocumentLink(link, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerDocumentLinkProvider(options.documentSelector, provider), provider];
    }
}
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;
    }
    initialize() {
        let section = this._client.clientOptions.synchronize.configurationSection;
        if (section !== undefined) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: {
                    section: section
                }
            });
        }
    }
    register(data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
            this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== undefined) {
            this.onDidChangeConfiguration(data.registerOptions.section, undefined);
        }
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
        }
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    onDidChangeConfiguration(configurationSection, event) {
        let sections;
        if (Is.string(configurationSection)) {
            sections = [configurationSection];
        }
        else {
            sections = configurationSection;
        }
        if (sections !== undefined && event !== undefined) {
            let affected = sections.some((section) => event.affectsConfiguration(section));
            if (!affected) {
                return;
            }
        }
        let didChangeConfiguration = (sections) => {
            if (sections === undefined) {
                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
                return;
            }
            this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections) });
        };
        let middleware = this.getMiddleware();
        middleware
            ? middleware(sections, didChangeConfiguration)
            : didChangeConfiguration(sections);
    }
    extractSettingsInformation(keys) {
        function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
                let obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        let resource = this._client.clientOptions.workspaceFolder
            ? this._client.clientOptions.workspaceFolder.uri
            : undefined;
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf('.');
            let config = null;
            if (index >= 0) {
                config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
            }
            else {
                config = vscode_1.workspace.getConfiguration(undefined, resource).get(key);
            }
            if (config) {
                let path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = configuration_1.toJSONObject(config);
            }
        }
        return result;
    }
    getMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
            return middleware.workspace.didChangeConfiguration;
        }
        else {
            return undefined;
        }
    }
}
class ExecuteCommandFeature {
    constructor(_client) {
        this._client = _client;
        this._commands = new Map();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;
    }
    initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
    }
    register(data) {
        const client = this._client;
        const middleware = client.clientOptions.middleware;
        const executeCommand = (command, args) => {
            let params = {
                command,
                arguments: args
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, error, undefined);
            });
        };
        if (data.registerOptions.commands) {
            const disposables = [];
            for (const command of data.registerOptions.commands) {
                disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
                    return middleware.executeCommand
                        ? middleware.executeCommand(command, args, executeCommand)
                        : executeCommand(command, args);
                }));
            }
            this._commands.set(data.id, disposables);
        }
    }
    unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
            disposables.forEach(disposable => disposable.dispose());
        }
    }
    dispose() {
        this._commands.forEach((value) => {
            value.forEach(disposable => disposable.dispose());
        });
        this._commands.clear();
    }
}
var MessageTransports;
(function (MessageTransports) {
    function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
    }
    MessageTransports.is = is;
})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
class OnReady {
    constructor(_resolve, _reject) {
        this._resolve = _resolve;
        this._reject = _reject;
        this._used = false;
    }
    get isUsed() {
        return this._used;
    }
    resolve() {
        this._used = true;
        this._resolve();
    }
    reject(error) {
        this._used = true;
        this._reject(error);
    }
}
class BaseLanguageClient {
    constructor(id, name, clientOptions) {
        var _a;
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._features = [];
        this._dynamicFeatures = new Map();
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        const markdown = { isTrusted: false };
        if (clientOptions.markdown !== undefined && clientOptions.markdown.isTrusted === true) {
            markdown.isTrusted = true;
        }
        this._clientOptions = {
            documentSelector: clientOptions.documentSelector || [],
            synchronize: clientOptions.synchronize || {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: clientOptions.outputChannelName || this._name,
            revealOutputChannelOn: clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Error,
            stdioEncoding: clientOptions.stdioEncoding || 'utf8',
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            progressOnInitialization: !!clientOptions.progressOnInitialization,
            errorHandler: clientOptions.errorHandler || this.createDefaultErrorHandler((_a = clientOptions.connectionOptions) === null || _a === void 0 ? void 0 : _a.maxRestartCount),
            middleware: clientOptions.middleware || {},
            uriConverters: clientOptions.uriConverters,
            workspaceFolder: clientOptions.workspaceFolder,
            connectionOptions: clientOptions.connectionOptions,
            markdown
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._state = ClientState.Initial;
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        this._initializeResult = undefined;
        if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
            this._disposeOutputChannel = false;
        }
        else {
            this._outputChannel = undefined;
            this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._listeners = undefined;
        this._providers = undefined;
        this._diagnostics = undefined;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise((resolve, reject) => {
            this._onReadyCallbacks = new OnReady(resolve, reject);
        });
        this._onStop = undefined;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
        this._tracer = {
            log: (messageOrDataObject, data) => {
                if (Is.string(messageOrDataObject)) {
                    this.logTrace(messageOrDataObject, data);
                }
                else {
                    this.logObjectTrace(messageOrDataObject);
                }
            },
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined, this._clientOptions.markdown.isTrusted);
        this._syncedDocuments = new Map();
        this.registerBuiltinFeatures();
    }
    get state() {
        return this._state;
    }
    set state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
        }
    }
    getPublicState() {
        if (this.state === ClientState.Running) {
            return State.Running;
        }
        else if (this.state === ClientState.Starting) {
            return State.Starting;
        }
        else {
            return State.Stopped;
        }
    }
    get initializeResult() {
        return this._initializeResult;
    }
    sendRequest(type, ...params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            return this._resolvedConnection.sendRequest(type, ...params);
        }
        catch (error) {
            this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onRequest(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            return this._resolvedConnection.onRequest(type, handler);
        }
        catch (error) {
            this.error(`Registering request handler ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    sendNotification(type, params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            this._resolvedConnection.sendNotification(type, params);
        }
        catch (error) {
            this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onNotification(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            return this._resolvedConnection.onNotification(type, handler);
        }
        catch (error) {
            this.error(`Registering notification handler ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onProgress(type, token, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            if (vscode_languageserver_protocol_1.WorkDoneProgress.is(type)) {
                const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
                if (handleWorkDoneProgress !== undefined) {
                    return this._resolvedConnection.onProgress(type, token, (params) => {
                        handleWorkDoneProgress(token, params, () => handler(params));
                    });
                }
            }
            return this._resolvedConnection.onProgress(type, token, handler);
        }
        catch (error) {
            this.error(`Registering progress handler for token ${token} failed.`, error);
            throw error;
        }
    }
    sendProgress(type, token, value) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            this._resolvedConnection.sendProgress(type, token, value);
        }
        catch (error) {
            this.error(`Sending progress for token ${token} failed.`, error);
            throw error;
        }
    }
    get clientOptions() {
        return this._clientOptions;
    }
    get protocol2CodeConverter() {
        return this._p2c;
    }
    get code2ProtocolConverter() {
        return this._c2p;
    }
    get onTelemetry() {
        return this._telemetryEmitter.event;
    }
    get onDidChangeState() {
        return this._stateChangeEmitter.event;
    }
    get outputChannel() {
        if (!this._outputChannel) {
            this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
    }
    get traceOutputChannel() {
        if (this._traceOutputChannel) {
            return this._traceOutputChannel;
        }
        return this.outputChannel;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    createDefaultErrorHandler(maxRestartCount) {
        if (maxRestartCount !== undefined && maxRestartCount < 0) {
            throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
        }
        return new DefaultErrorHandler(this._name, maxRestartCount !== null && maxRestartCount !== void 0 ? maxRestartCount : 4);
    }
    set trace(value) {
        this._trace = value;
        this.onReady().then(() => {
            this.resolveConnection().then((connection) => {
                connection.trace(this._trace, this._tracer, {
                    sendNotification: false,
                    traceFormat: this._traceFormat
                });
            });
        }, () => {
        });
    }
    data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}\n  Code: ${responseError.code} ${responseError.data ? '\n' + responseError.data.toString() : ''}`;
        }
        if (data instanceof Error) {
            if (Is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (Is.string(data)) {
            return data;
        }
        return data.toString();
    }
    info(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Info  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.showNotificationMessage();
        }
    }
    warn(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Warn  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.showNotificationMessage();
        }
    }
    error(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Error - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
            this.showNotificationMessage();
        }
    }
    showNotificationMessage() {
        vscode_1.window.showInformationMessage('A request has failed. See the output for more information.', 'Go to output').then(() => {
            this.outputChannel.show(true);
        });
    }
    logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.traceOutputChannel.appendLine(this.data2String(data));
        }
    }
    logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
            this.traceOutputChannel.append(`[LSP   - ${(new Date().toLocaleTimeString())}] `);
        }
        else {
            this.traceOutputChannel.append(`[Trace - ${(new Date().toLocaleTimeString())}] `);
        }
        if (data) {
            this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
    }
    needsStart() {
        return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;
    }
    needsStop() {
        return this.state === ClientState.Starting || this.state === ClientState.Running;
    }
    onReady() {
        return this._onReady;
    }
    isConnectionActive() {
        return this.state === ClientState.Running && !!this._resolvedConnection;
    }
    start() {
        if (this._onReadyCallbacks.isUsed) {
            this._onReady = new Promise((resolve, reject) => {
                this._onReadyCallbacks = new OnReady(resolve, reject);
            });
        }
        this._listeners = [];
        this._providers = [];
        // If we restart then the diagnostics collection is reused.
        if (!this._diagnostics) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName
                ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)
                : vscode_1.languages.createDiagnosticCollection();
        }
        this.state = ClientState.Starting;
        this.resolveConnection().then((connection) => {
            connection.onLogMessage((message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        this.error(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        this.warn(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        this.info(message.message, undefined, false);
                        break;
                    default:
                        this.outputChannel.appendLine(message.message);
                }
            });
            connection.onShowMessage((message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        vscode_1.window.showErrorMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        vscode_1.window.showWarningMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        vscode_1.window.showInformationMessage(message.message);
                        break;
                    default:
                        vscode_1.window.showInformationMessage(message.message);
                }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
                let messageFunc;
                switch (params.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        messageFunc = vscode_1.window.showErrorMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        messageFunc = vscode_1.window.showWarningMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        messageFunc = vscode_1.window.showInformationMessage;
                        break;
                    default:
                        messageFunc = vscode_1.window.showInformationMessage;
                }
                let actions = params.actions || [];
                return messageFunc(params.message, ...actions);
            });
            connection.onTelemetry((data) => {
                this._telemetryEmitter.fire(data);
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
                var _a;
                const showDocument = async (params) => {
                    const uri = this.protocol2CodeConverter.asUri(params.uri);
                    try {
                        if (params.external === true) {
                            const success = await vscode_1.env.openExternal(uri);
                            return { success };
                        }
                        else {
                            const options = {};
                            if (params.selection !== undefined) {
                                options.selection = this.protocol2CodeConverter.asRange(params.selection);
                            }
                            if (params.takeFocus === undefined || params.takeFocus === false) {
                                options.preserveFocus = true;
                            }
                            else if (params.takeFocus === true) {
                                options.preserveFocus = false;
                            }
                            await vscode_1.window.showTextDocument(uri, options);
                            return { success: true };
                        }
                    }
                    catch (error) {
                        return { success: true };
                    }
                };
                const middleware = (_a = this._clientOptions.middleware.window) === null || _a === void 0 ? void 0 : _a.showDocument;
                if (middleware !== undefined) {
                    return middleware(params, showDocument);
                }
                else {
                    return showDocument(params);
                }
            });
            connection.listen();
            // Error is handled in the initialize call.
            return this.initialize(connection);
        }).then(undefined, (error) => {
            this.state = ClientState.StartFailed;
            this._onReadyCallbacks.reject(error);
            this.error('Starting client failed', error);
            vscode_1.window.showErrorMessage(`Couldn't start client ${this._name}`);
        });
        return new vscode_1.Disposable(() => {
            if (this.needsStop()) {
                this.stop();
            }
        });
    }
    resolveConnection() {
        if (!this._connectionPromise) {
            this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
    }
    initialize(connection) {
        this.refreshTrace(connection, false);
        let initOption = this._clientOptions.initializationOptions;
        let rootPath = this._clientOptions.workspaceFolder
            ? this._clientOptions.workspaceFolder.uri.fsPath
            : this._clientGetRootPath();
        let initParams = {
            processId: null,
            clientInfo: {
                name: vscode_1.env.appName,
                version: vscode_1.version
            },
            locale: this.getLocale(),
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initOption) ? initOption() : initOption,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders: null
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
            const token = UUID.generateUuid();
            const part = new progressPart_1.ProgressPart(connection, token);
            initParams.workDoneToken = token;
            return this.doInitialize(connection, initParams).then((result) => {
                part.done();
                return result;
            }, (error) => {
                part.cancel();
                throw error;
            });
        }
        else {
            return this.doInitialize(connection, initParams);
        }
    }
    doInitialize(connection, initParams) {
        return connection.initialize(initParams).then((result) => {
            this._resolvedConnection = connection;
            this._initializeResult = result;
            this.state = ClientState.Running;
            let textDocumentSyncOptions = undefined;
            if (Is.number(result.capabilities.textDocumentSync)) {
                if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                    textDocumentSyncOptions = {
                        openClose: false,
                        change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                        save: undefined
                    };
                }
                else {
                    textDocumentSyncOptions = {
                        openClose: true,
                        change: result.capabilities.textDocumentSync,
                        save: {
                            includeText: false
                        }
                    };
                }
            }
            else if (result.capabilities.textDocumentSync !== undefined && result.capabilities.textDocumentSync !== null) {
                textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onDiagnostics(params => this.handleDiagnostics(params));
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
            connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            this._onReadyCallbacks.resolve();
            return result;
        }).then(undefined, (error) => {
            if (this._clientOptions.initializationFailedHandler) {
                if (this._clientOptions.initializationFailedHandler(error)) {
                    this.initialize(connection);
                }
                else {
                    this.stop();
                    this._onReadyCallbacks.reject(error);
                }
            }
            else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
                vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: 'retry' }).then(item => {
                    if (item && item.id === 'retry') {
                        this.initialize(connection);
                    }
                    else {
                        this.stop();
                        this._onReadyCallbacks.reject(error);
                    }
                });
            }
            else {
                if (error && error.message) {
                    vscode_1.window.showErrorMessage(error.message);
                }
                this.error('Server initialization failed.', error);
                this.stop();
                this._onReadyCallbacks.reject(error);
            }
            throw error;
        });
    }
    _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    stop() {
        this._initializeResult = undefined;
        if (!this._connectionPromise) {
            this.state = ClientState.Stopped;
            return Promise.resolve();
        }
        if (this.state === ClientState.Stopping && this._onStop) {
            return this._onStop;
        }
        this.state = ClientState.Stopping;
        this.cleanUp(false);
        // unhook listeners
        return this._onStop = this.resolveConnection().then(connection => {
            return connection.shutdown().then(() => {
                connection.exit();
                connection.end();
                connection.dispose();
                this.state = ClientState.Stopped;
                this.cleanUpChannel();
                this._onStop = undefined;
                this._connectionPromise = undefined;
                this._resolvedConnection = undefined;
            });
        });
    }
    cleanUp(channel = true, diagnostics = true) {
        if (this._listeners) {
            this._listeners.forEach(listener => listener.dispose());
            this._listeners = undefined;
        }
        if (this._providers) {
            this._providers.forEach(provider => provider.dispose());
            this._providers = undefined;
        }
        if (this._syncedDocuments) {
            this._syncedDocuments.clear();
        }
        for (const feature of this._features.values()) {
            feature.dispose();
        }
        if (channel) {
            this.cleanUpChannel();
        }
        if (diagnostics && this._diagnostics) {
            this._diagnostics.dispose();
            this._diagnostics = undefined;
        }
    }
    cleanUpChannel() {
        if (this._outputChannel && this._disposeOutputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = undefined;
        }
    }
    notifyFileEvent(event) {
        var _a;
        const client = this;
        function didChangeWatchedFile(event) {
            client._fileEvents.push(event);
            client._fileEventDelayer.trigger(() => {
                client.onReady().then(() => {
                    client.resolveConnection().then(connection => {
                        if (client.isConnectionActive()) {
                            client.forceDocumentSync();
                            connection.didChangeWatchedFiles({ changes: client._fileEvents });
                        }
                        client._fileEvents = [];
                    });
                }, (error) => {
                    client.error(`Notify file events failed.`, error);
                });
            });
        }
        const workSpaceMiddleware = (_a = this.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        (workSpaceMiddleware === null || workSpaceMiddleware === void 0 ? void 0 : workSpaceMiddleware.didChangeWatchedFile) ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event);
    }
    forceDocumentSync() {
        if (this._didChangeTextDocumentFeature === undefined) {
            this._didChangeTextDocumentFeature = this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method);
        }
        this._didChangeTextDocumentFeature.forceDelivery();
    }
    handleDiagnostics(params) {
        if (!this._diagnostics) {
            return;
        }
        let uri = this._p2c.asUri(params.uri);
        let diagnostics = this._p2c.asDiagnostics(params.diagnostics);
        let middleware = this.clientOptions.middleware;
        if (middleware.handleDiagnostics) {
            middleware.handleDiagnostics(uri, diagnostics, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));
        }
        else {
            this.setDiagnostics(uri, diagnostics);
        }
    }
    setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
            return;
        }
        this._diagnostics.set(uri, diagnostics);
    }
    createConnection() {
        let errorHandler = (error, message, count) => {
            this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
            this.handleConnectionClosed();
        };
        return this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8').then((transports) => {
            return createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        });
    }
    handleConnectionClosed() {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.state === ClientState.Stopping || this.state === ClientState.Stopped) {
            return;
        }
        try {
            if (this._resolvedConnection) {
                this._resolvedConnection.dispose();
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        let action = CloseAction.DoNotRestart;
        try {
            action = this._clientOptions.errorHandler.closed();
        }
        catch (error) {
            // Ignore errors coming from the error handler.
        }
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        if (action === CloseAction.DoNotRestart) {
            this.error('Connection to server got closed. Server will not be restarted.');
            if (this.state === ClientState.Starting) {
                this._onReadyCallbacks.reject(new Error(`Connection to server got closed. Server will not be restarted.`));
                this.state = ClientState.StartFailed;
            }
            else {
                this.state = ClientState.Stopped;
            }
            this.cleanUp(false, true);
        }
        else if (action === CloseAction.Restart) {
            this.info('Connection to server got closed. Server will restart.');
            this.cleanUp(false, false);
            this.state = ClientState.Initial;
            this.start();
        }
    }
    handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === ErrorAction.Shutdown) {
            this.error('Connection to server is erroring. Shutting down server.');
            this.stop();
        }
    }
    hookConfigurationChanged(connection) {
        vscode_1.workspace.onDidChangeConfiguration(() => {
            this.refreshTrace(connection, true);
        });
    }
    refreshTrace(connection, sendNotification = false) {
        let config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
            const traceConfig = config.get('trace.server', 'off');
            if (typeof traceConfig === 'string') {
                trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
            }
            else {
                trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));
                traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));
            }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
        });
    }
    hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        let watchers;
        if (Is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
    }
    registerFeatures(features) {
        for (let feature of features) {
            this.registerFeature(feature);
        }
    }
    registerFeature(feature) {
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
            const registrationType = feature.registrationType;
            this._dynamicFeatures.set(registrationType.method, feature);
        }
    }
    getFeature(request) {
        return this._dynamicFeatures.get(request);
    }
    registerBuiltinFeatures() {
        this.registerFeature(new ConfigurationFeature(this));
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new DidChangeTextDocumentFeature(this));
        this.registerFeature(new WillSaveFeature(this));
        this.registerFeature(new WillSaveWaitUntilFeature(this));
        this.registerFeature(new DidSaveTextDocumentFeature(this));
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new CompletionItemFeature(this));
        this.registerFeature(new HoverFeature(this));
        this.registerFeature(new SignatureHelpFeature(this));
        this.registerFeature(new DefinitionFeature(this));
        this.registerFeature(new ReferencesFeature(this));
        this.registerFeature(new DocumentHighlightFeature(this));
        this.registerFeature(new DocumentSymbolFeature(this));
        this.registerFeature(new WorkspaceSymbolFeature(this));
        this.registerFeature(new CodeActionFeature(this));
        this.registerFeature(new CodeLensFeature(this));
        this.registerFeature(new DocumentFormattingFeature(this));
        this.registerFeature(new DocumentRangeFormattingFeature(this));
        this.registerFeature(new DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new RenameFeature(this));
        this.registerFeature(new DocumentLinkFeature(this));
        this.registerFeature(new ExecuteCommandFeature(this));
    }
    fillInitializeParams(params) {
        for (let feature of this._features) {
            if (Is.func(feature.fillInitializeParams)) {
                feature.fillInitializeParams(params);
            }
        }
    }
    computeClientCapabilities() {
        const result = {};
        ensure(result, 'workspace').applyEdit = true;
        const workspaceEdit = ensure(ensure(result, 'workspace'), 'workspaceEdit');
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
            groupsOnLabel: true
        };
        const diagnostics = ensure(ensure(result, 'textDocument'), 'publishDiagnostics');
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = ensure(result, 'window');
        const showMessage = ensure(windowCapabilities, 'showMessage');
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = ensure(windowCapabilities, 'showDocument');
        showDocument.support = true;
        const generalCapabilities = ensure(result, 'general');
        generalCapabilities.regularExpressions = { engine: 'ECMAScript', version: 'ES2020' };
        generalCapabilities.markdown = { parser: 'marked', version: '1.1.0' };
        for (let feature of this._features) {
            feature.fillClientCapabilities(result);
        }
        return result;
    }
    initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
        }
    }
    handleRegistrationRequest(params) {
        return new Promise((resolve, reject) => {
            for (const registration of params.registrations) {
                const feature = this._dynamicFeatures.get(registration.method);
                if (feature === undefined) {
                    reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
                    return;
                }
                const options = registration.registerOptions || {};
                options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;
                const data = {
                    id: registration.id,
                    registerOptions: options
                };
                try {
                    feature.register(data);
                }
                catch (err) {
                    reject(err);
                    return;
                }
            }
            resolve();
        });
    }
    handleUnregistrationRequest(params) {
        return new Promise((resolve, reject) => {
            for (let unregistration of params.unregisterations) {
                const feature = this._dynamicFeatures.get(unregistration.method);
                if (!feature) {
                    reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
                    return;
                }
                feature.unregister(unregistration.id);
            }
            resolve();
        });
    }
    handleApplyWorkspaceEdit(params) {
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        let workspaceEdit = params.edit;
        let openTextDocuments = new Map();
        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    let textDocument = openTextDocuments.get(change.textDocument.uri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        versionMismatch = true;
                        break;
                    }
                }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return Is.asPromise(vscode_1.workspace.applyEdit(this._p2c.asWorkspaceEdit(params.edit)).then((value) => { return { applied: value }; }));
    }
    handleFailedRequest(type, error, defaultValue) {
        // If we get a request cancel or a content modified don't log anything.
        if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
            if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled) {
                throw this.makeCancelError();
            }
            else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
                return defaultValue;
            }
        }
        this.error(`Request ${type.method} failed.`, error);
        throw error;
    }
    makeCancelError() {
        const result = new Error(BaseLanguageClient.Canceled);
        result.name = BaseLanguageClient.Canceled;
        return result;
    }
}
exports.BaseLanguageClient = BaseLanguageClient;
BaseLanguageClient.Canceled = 'Canceled';
//# sourceMappingURL=client.js.map

/***/ }),

/***/ 71:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(9496);
const proto = __webpack_require__(273);
const Is = __webpack_require__(9763);
const protocolCompletionItem_1 = __webpack_require__(1807);
const protocolCodeLens_1 = __webpack_require__(583);
const protocolDocumentLink_1 = __webpack_require__(8705);
const protocolCodeAction_1 = __webpack_require__(6434);
const protocolDiagnostic_1 = __webpack_require__(6640);
const protocolCallHierarchyItem_1 = __webpack_require__(8714);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
var InsertReplaceRange;
(function (InsertReplaceRange) {
    function is(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
    }
    InsertReplaceRange.is = is;
})(InsertReplaceRange || (InsertReplaceRange = {}));
function createConverter(uriConverter) {
    const nullConverter = (value) => value.toString();
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri)
        };
    }
    function asVersionedTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
        };
    }
    function asOpenTextDocumentParams(textDocument) {
        return {
            textDocument: {
                uri: _uriConverter(textDocument.uri),
                languageId: textDocument.languageId,
                version: textDocument.version,
                text: textDocument.getText()
            }
        };
    }
    function isTextDocumentChangeEvent(value) {
        let candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
    }
    function isTextDocument(value) {
        let candidate = value;
        return !!candidate.uri && !!candidate.version;
    }
    function asChangeTextDocumentParams(arg) {
        if (isTextDocument(arg)) {
            let result = {
                textDocument: {
                    uri: _uriConverter(arg.uri),
                    version: arg.version
                },
                contentChanges: [{ text: arg.getText() }]
            };
            return result;
        }
        else if (isTextDocumentChangeEvent(arg)) {
            let document = arg.document;
            let result = {
                textDocument: {
                    uri: _uriConverter(document.uri),
                    version: document.version
                },
                contentChanges: arg.contentChanges.map((change) => {
                    let range = change.range;
                    return {
                        range: {
                            start: { line: range.start.line, character: range.start.character },
                            end: { line: range.end.line, character: range.end.character }
                        },
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            };
            return result;
        }
        else {
            throw Error('Unsupported text document change parameter');
        }
    }
    function asCloseTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
            result.text = textDocument.getText();
        }
        return result;
    }
    function asTextDocumentSaveReason(reason) {
        switch (reason) {
            case code.TextDocumentSaveReason.Manual:
                return proto.TextDocumentSaveReason.Manual;
            case code.TextDocumentSaveReason.AfterDelay:
                return proto.TextDocumentSaveReason.AfterDelay;
            case code.TextDocumentSaveReason.FocusOut:
                return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
    }
    function asWillSaveTextDocumentParams(event) {
        return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: asTextDocumentSaveReason(event.reason)
        };
    }
    function asDidCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asDidRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asDidDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asWillDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asTextDocumentPositionParams(textDocument, position) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
        };
    }
    function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.CompletionTriggerKind.TriggerCharacter:
                return proto.CompletionTriggerKind.TriggerCharacter;
            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
                return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
                return proto.CompletionTriggerKind.Invoked;
        }
    }
    function asCompletionParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                triggerKind: asCompletionTriggerKind(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            }
        };
    }
    function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.SignatureHelpTriggerKind.Invoke:
                return proto.SignatureHelpTriggerKind.Invoked;
            case code.SignatureHelpTriggerKind.TriggerCharacter:
                return proto.SignatureHelpTriggerKind.TriggerCharacter;
            case code.SignatureHelpTriggerKind.ContentChange:
                return proto.SignatureHelpTriggerKind.ContentChange;
        }
    }
    function asParameterInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label
        };
    }
    function asParameterInformations(values) {
        return values.map(asParameterInformation);
    }
    function asSignatureInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label,
            parameters: asParameterInformations(value.parameters)
        };
    }
    function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
    }
    function asSignatureHelp(value) {
        if (value === undefined) {
            return value;
        }
        return {
            signatures: asSignatureInformations(value.signatures),
            activeSignature: value.activeSignature,
            activeParameter: value.activeParameter
        };
    }
    function asSignatureHelpParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                isRetrigger: context.isRetrigger,
                triggerCharacter: context.triggerCharacter,
                triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
                activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
            }
        };
    }
    function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
    }
    function asPosition(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { line: value.line, character: value.character };
    }
    function asPositions(value) {
        let result = [];
        for (let elem of value) {
            result.push(asPosition(elem));
        }
        return result;
    }
    function asRange(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
    }
    function asLocation(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return proto.Location.create(asUri(value.uri), asRange(value.range));
    }
    function asDiagnosticSeverity(value) {
        switch (value) {
            case code.DiagnosticSeverity.Error:
                return proto.DiagnosticSeverity.Error;
            case code.DiagnosticSeverity.Warning:
                return proto.DiagnosticSeverity.Warning;
            case code.DiagnosticSeverity.Information:
                return proto.DiagnosticSeverity.Information;
            case code.DiagnosticSeverity.Hint:
                return proto.DiagnosticSeverity.Hint;
        }
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case code.DiagnosticTag.Unnecessary:
                return proto.DiagnosticTag.Unnecessary;
            case code.DiagnosticTag.Deprecated:
                return proto.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asRelatedInformation(item) {
        return {
            message: item.message,
            location: asLocation(item.location)
        };
    }
    function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
    }
    function asDiagnosticCode(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        if (Is.number(value) || Is.string(value)) {
            return value;
        }
        return { value: value.value, target: asUri(value.target) };
    }
    function asDiagnostic(item) {
        const result = proto.Diagnostic.create(asRange(item.range), item.message);
        const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : undefined;
        if (protocolDiagnostic !== undefined && protocolDiagnostic.data !== undefined) {
            result.data = protocolDiagnostic.data;
        }
        const code = asDiagnosticCode(item.code);
        if (protocolDiagnostic_1.DiagnosticCode.is(code)) {
            if (protocolDiagnostic !== undefined && protocolDiagnostic.hasDiagnosticCode) {
                result.code = code;
            }
            else {
                result.code = code.value;
                result.codeDescription = { href: code.target };
            }
        }
        else {
            result.code = code;
        }
        if (Is.number(item.severity)) {
            result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Array.isArray(item.tags)) {
            result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
            result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
            result.source = item.source;
        }
        return result;
    }
    function asDiagnostics(items) {
        if (items === undefined || items === null) {
            return items;
        }
        return items.map(asDiagnostic);
    }
    function asDocumentation(format, documentation) {
        switch (format) {
            case '$string':
                return documentation;
            case proto.MarkupKind.PlainText:
                return { kind: format, value: documentation };
            case proto.MarkupKind.Markdown:
                return { kind: format, value: documentation.value };
            default:
                return `Unsupported Markup content received. Kind is: ${format}`;
        }
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case code.CompletionItemTag.Deprecated:
                return proto.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined) {
            return tags;
        }
        const result = [];
        for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItemKind(value, original) {
        if (original !== undefined) {
            return original;
        }
        return value + 1;
    }
    function asCompletionItem(item) {
        let result = { label: item.label };
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : undefined;
        if (item.detail) {
            result.detail = item.detail;
        }
        // We only send items back we created. So this can't be something else than
        // a string right now.
        if (item.documentation) {
            if (!protocolItem || protocolItem.documentationFormat === '$string') {
                result.documentation = item.documentation;
            }
            else {
                result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
            if (protocolItem.data !== undefined) {
                result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
                if (protocolItem.deprecated === true && tags !== undefined && tags.length > 0) {
                    const index = tags.indexOf(code.CompletionItemTag.Deprecated);
                    if (index !== -1) {
                        tags.splice(index, 1);
                    }
                }
                result.deprecated = protocolItem.deprecated;
            }
            if (protocolItem.insertTextMode !== undefined) {
                result.insertTextMode = protocolItem.insertTextMode;
            }
        }
        if (tags !== undefined && tags.length > 0) {
            result.tags = tags;
        }
        if (result.insertTextMode === undefined && item.keepWhitespace === true) {
            result.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        }
        return result;
    }
    function fillPrimaryInsertText(target, source) {
        let format = proto.InsertTextFormat.PlainText;
        let text = undefined;
        let range = undefined;
        if (source.textEdit) {
            text = source.textEdit.newText;
            range = source.textEdit.range;
        }
        else if (source.insertText instanceof code.SnippetString) {
            format = proto.InsertTextFormat.Snippet;
            text = source.insertText.value;
        }
        else {
            text = source.insertText;
        }
        if (source.range) {
            range = source.range;
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text !== undefined && range !== undefined) {
            target.textEdit = asCompletionTextEdit(text, range);
        }
        else {
            target.insertText = text;
        }
    }
    function asCompletionTextEdit(newText, range) {
        if (InsertReplaceRange.is(range)) {
            return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
        }
        else {
            return { newText, range: asRange(range) };
        }
    }
    function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
    }
    function asTextEdits(edits) {
        if (edits === undefined || edits === null) {
            return edits;
        }
        return edits.map(asTextEdit);
    }
    function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return (item + 1);
        }
        return proto.SymbolKind.Property;
    }
    function asSymbolTag(item) {
        return item;
    }
    function asSymbolTags(items) {
        return items.map(asSymbolTag);
    }
    function asReferenceParams(textDocument, position, options) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
        };
    }
    function asCodeAction(item) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== undefined) {
            result.data = item.data;
        }
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit !== undefined) {
            throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    function asCodeActionContext(context) {
        if (context === undefined || context === null) {
            return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
            only = [context.only.value];
        }
        return proto.CodeActionContext.create(asDiagnostics(context.diagnostics), only);
    }
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        return item.value;
    }
    function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
            if (item.data) {
                result.data = item.data;
            }
        }
        return result;
    }
    function asFormattingOptions(options, fileOptions) {
        const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        if (fileOptions.trimTrailingWhitespace) {
            result.trimTrailingWhitespace = true;
        }
        if (fileOptions.trimFinalNewlines) {
            result.trimFinalNewlines = true;
        }
        if (fileOptions.insertFinalNewline) {
            result.insertFinalNewline = true;
        }
        return result;
    }
    function asDocumentSymbolParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCodeLensParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
            result.target = asUri(item.target);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : undefined;
        if (protocolItem && protocolItem.data) {
            result.data = protocolItem.data;
        }
        return result;
    }
    function asDocumentLinkParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCallHierarchyItem(value) {
        const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== undefined && value.detail.length > 0) {
            result.detail = value.detail;
        }
        if (value.tags !== undefined) {
            result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolCallHierarchyItem_1.default && value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    return {
        asUri,
        asTextDocumentIdentifier,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asDidCreateFilesParams,
        asDidRenameFilesParams,
        asDidDeleteFilesParams,
        asWillCreateFilesParams,
        asWillRenameFilesParams,
        asWillDeleteFilesParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asPositions,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeAction,
        asCodeActionContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams,
        asCallHierarchyItem
    };
}
exports.createConverter = createConverter;
//# sourceMappingURL=codeConverter.js.map

/***/ }),

/***/ 3069:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorProviderFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const client_1 = __webpack_require__(4384);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class ColorProviderFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'colorProvider').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideColorPresentations: (color, context, token) => {
                const client = this._client;
                const provideColorPresentations = (color, context, token) => {
                    const requestParams = {
                        color,
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context.document),
                        range: client.code2ProtocolConverter.asRange(context.range)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token).then(this.asColorPresentations.bind(this), (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideColorPresentations
                    ? middleware.provideColorPresentations(color, context, token, provideColorPresentations)
                    : provideColorPresentations(color, context, token);
            },
            provideDocumentColors: (document, token) => {
                const client = this._client;
                const provideDocumentColors = (document, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token).then(this.asColorInformations.bind(this), (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentColors
                    ? middleware.provideDocumentColors(document, token, provideDocumentColors)
                    : provideDocumentColors(document, token);
            }
        };
        return [vscode_1.languages.registerColorProvider(options.documentSelector, provider), provider];
    }
    asColor(color) {
        return new vscode_1.Color(color.red, color.green, color.blue, color.alpha);
    }
    asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
            return colorInformation.map(ci => {
                return new vscode_1.ColorInformation(this._client.protocol2CodeConverter.asRange(ci.range), this.asColor(ci.color));
            });
        }
        return [];
    }
    asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
            return colorPresentations.map(cp => {
                let presentation = new vscode_1.ColorPresentation(cp.label);
                presentation.additionalTextEdits = this._client.protocol2CodeConverter.asTextEdits(cp.additionalTextEdits);
                presentation.textEdit = this._client.protocol2CodeConverter.asTextEdit(cp.textEdit);
                return presentation;
            });
        }
        return [];
    }
}
exports.ColorProviderFeature = ColorProviderFeature;
//# sourceMappingURL=colorProvider.js.map

/***/ }),

/***/ 7225:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProposedFeatures = exports.CommonLanguageClient = void 0;
const client_1 = __webpack_require__(4384);
const colorProvider_1 = __webpack_require__(3069);
const configuration_1 = __webpack_require__(6495);
const implementation_1 = __webpack_require__(9889);
const typeDefinition_1 = __webpack_require__(328);
const workspaceFolders_1 = __webpack_require__(9565);
const foldingRange_1 = __webpack_require__(6454);
const declaration_1 = __webpack_require__(707);
const selectionRange_1 = __webpack_require__(750);
const progress_1 = __webpack_require__(3603);
const callHierarchy_1 = __webpack_require__(5578);
const semanticTokens_1 = __webpack_require__(9957);
const fileOperations_1 = __webpack_require__(8406);
const linkedEditingRange_1 = __webpack_require__(3483);
class CommonLanguageClient extends client_1.BaseLanguageClient {
    constructor(id, name, clientOptions) {
        super(id, name, clientOptions);
    }
    registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
    }
    registerBuiltinFeatures() {
        super.registerBuiltinFeatures();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
        this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
        this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
    }
}
exports.CommonLanguageClient = CommonLanguageClient;
// Exporting proposed protocol.
var ProposedFeatures;
(function (ProposedFeatures) {
    function createAll(_client) {
        let result = [];
        return result;
    }
    ProposedFeatures.createAll = createAll;
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
//# sourceMappingURL=commonClient.js.map

/***/ }),

/***/ 6495:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toJSONObject = exports.ConfigurationFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = (params) => {
                let result = [];
                for (let item of params.items) {
                    let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : undefined;
                    result.push(this.getConfiguration(resource, item.section !== null ? item.section : undefined));
                }
                return result;
            };
            let middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.configuration
                ? middleware.configuration(params, token, configuration)
                : configuration(params, token);
        });
    }
    getConfiguration(resource, section) {
        let result = null;
        if (section) {
            let index = section.lastIndexOf('.');
            if (index === -1) {
                result = toJSONObject(vscode_1.workspace.getConfiguration(undefined, resource).get(section));
            }
            else {
                let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
                if (config) {
                    result = toJSONObject(config.get(section.substr(index + 1)));
                }
            }
        }
        else {
            let config = vscode_1.workspace.getConfiguration(undefined, resource);
            result = {};
            for (let key of Object.keys(config)) {
                if (config.has(key)) {
                    result[key] = toJSONObject(config.get(key));
                }
            }
        }
        if (result === undefined) {
            result = null;
        }
        return result;
    }
    dispose() {
    }
}
exports.ConfigurationFeature = ConfigurationFeature;
function toJSONObject(obj) {
    if (obj) {
        if (Array.isArray(obj)) {
            return obj.map(toJSONObject);
        }
        else if (typeof obj === 'object') {
            const res = Object.create(null);
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    res[key] = toJSONObject(obj[key]);
                }
            }
            return res;
        }
    }
    return obj;
}
exports.toJSONObject = toJSONObject;
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ 707:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const client_1 = __webpack_require__(4384);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class DeclarationFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const declarationSupport = ensure(ensure(capabilities, 'textDocument'), 'declaration');
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDeclaration: (document, position, token) => {
                const client = this._client;
                const provideDeclaration = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDeclarationResult, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDeclaration
                    ? middleware.provideDeclaration(document, position, token, provideDeclaration)
                    : provideDeclaration(document, position, token);
            }
        };
        return [vscode_1.languages.registerDeclarationProvider(options.documentSelector, provider), provider];
    }
}
exports.DeclarationFeature = DeclarationFeature;
//# sourceMappingURL=declaration.js.map

/***/ }),

/***/ 8406:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;
const code = __webpack_require__(9496);
const minimatch = __webpack_require__(1171);
const proto = __webpack_require__(273);
const UUID = __webpack_require__(1980);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
function access(target, key) {
    return target[key];
}
function assign(target, key, value) {
    target[key] = value;
}
class FileOperationFeature {
    constructor(client, event, registrationType, clientCapability, serverCapability) {
        this._filters = new Map();
        this._client = client;
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
    }
    get registrationType() {
        return this._registrationType;
    }
    fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, 'workspace'), 'fileOperations');
        // this happens n times but it is the same value so we tolerate this.
        assign(value, 'dynamicRegistration', true);
        assign(value, this._clientCapability, true);
    }
    initialize(capabilities) {
        var _a;
        const options = (_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.fileOperations;
        const capability = options !== undefined ? access(options, this._serverCapability) : undefined;
        if ((capability === null || capability === void 0 ? void 0 : capability.filters) !== undefined) {
            try {
                this.register({
                    id: UUID.generateUuid(),
                    registerOptions: { filters: capability.filters }
                });
            }
            catch (e) {
                this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
            }
        }
    }
    register(data) {
        if (!this._listener) {
            this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter) => {
            const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
            if (!matcher.makeRe()) {
                throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
            }
            return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
    }
    unregister(id) {
        this._filters.delete(id);
        if (this._filters.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._filters.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    async filter(event, prop) {
        // (Asynchronously) map each file onto a boolean of whether it matches
        // any of the globs.
        const fileMatches = await Promise.all(event.files.map(async (item) => {
            const uri = prop(item);
            // Use fsPath to make this consistent with file system watchers but help
            // minimatch to use '/' instead of `\\` if present.
            const path = uri.fsPath.replace(/\\/g, '/');
            for (const filters of this._filters.values()) {
                for (const filter of filters) {
                    if (filter.scheme !== undefined && filter.scheme !== uri.scheme) {
                        continue;
                    }
                    if (filter.matcher.match(path)) {
                        // The pattern matches. If kind is undefined then everything is ok
                        if (filter.kind === undefined) {
                            return true;
                        }
                        const fileType = await FileOperationFeature.getFileType(uri);
                        // If we can't determine the file type than we treat it as a match.
                        // Dropping it would be another alternative.
                        if (fileType === undefined) {
                            this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                            return true;
                        }
                        if ((fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file) || (fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder)) {
                            return true;
                        }
                    }
                    else if (filter.kind === proto.FileOperationPatternKind.folder) {
                        const fileType = await FileOperationFeature.getFileType(uri);
                        if (fileType === code.FileType.Directory && filter.matcher.match(`${path}/`)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }));
        // Filter the files to those that matched.
        const files = event.files.filter((_, index) => fileMatches[index]);
        return Object.assign(Object.assign({}, event), { files });
    }
    static async getFileType(uri) {
        try {
            return (await code.workspace.fs.stat(uri)).type;
        }
        catch (e) {
            return undefined;
        }
    }
    static asMinimatchOptions(options) {
        if (options === undefined) {
            return undefined;
        }
        if (options.ignoreCase === true) {
            return { nocase: true };
        }
        return undefined;
    }
}
class NotificationFileOperationFeature extends FileOperationFeature {
    constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = async (event) => {
                this._client.sendNotification(this._notificationType, this._createParams(event));
            };
            this.doSend(filteredEvent, next);
        }
    }
}
class DidCreateFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, 'didCreate', 'didCreate', (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.didCreateFiles) ? middleware.didCreateFiles(event, next)
            : next(event);
    }
}
exports.DidCreateFilesFeature = DidCreateFilesFeature;
class DidRenameFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, 'didRename', 'didRename', (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.didRenameFiles) ? middleware.didRenameFiles(event, next)
            : next(event);
    }
}
exports.DidRenameFilesFeature = DidRenameFilesFeature;
class DidDeleteFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, 'didDelete', 'didDelete', (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.didDeleteFiles) ? middleware.didDeleteFiles(event, next)
            : next(event);
    }
}
exports.DidDeleteFilesFeature = DidDeleteFilesFeature;
class RequestFileOperationFeature extends FileOperationFeature {
    constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
    }
    async waitUntil(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = (event) => {
                return this._client.sendRequest(this._requestType, this._createParams(event))
                    .then(this._client.protocol2CodeConverter.asWorkspaceEdit);
            };
            return this.doSend(filteredEvent, next);
        }
        else {
            return undefined;
        }
    }
}
class WillCreateFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, 'willCreate', 'willCreate', (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.willCreateFiles) ? middleware.willCreateFiles(event, next)
            : next(event);
    }
}
exports.WillCreateFilesFeature = WillCreateFilesFeature;
class WillRenameFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, 'willRename', 'willRename', (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.willRenameFiles) ? middleware.willRenameFiles(event, next)
            : next(event);
    }
}
exports.WillRenameFilesFeature = WillRenameFilesFeature;
class WillDeleteFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, 'willDelete', 'willDelete', (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.willDeleteFiles) ? middleware.willDeleteFiles(event, next)
            : next(event);
    }
}
exports.WillDeleteFilesFeature = WillDeleteFilesFeature;
//# sourceMappingURL=fileOperations.js.map

/***/ }),

/***/ 6454:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const client_1 = __webpack_require__(4384);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class FoldingRangeFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, 'textDocument'), 'foldingRange');
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5000;
        capability.lineFoldingOnly = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideFoldingRanges: (document, context, token) => {
                const client = this._client;
                const provideFoldingRanges = (document, _, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token).then(FoldingRangeFeature.asFoldingRanges, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideFoldingRanges
                    ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges)
                    : provideFoldingRanges(document, context, token);
            }
        };
        return [vscode_1.languages.registerFoldingRangeProvider(options.documentSelector, provider), provider];
    }
    static asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case vscode_languageserver_protocol_1.FoldingRangeKind.Comment:
                    return vscode_1.FoldingRangeKind.Comment;
                case vscode_languageserver_protocol_1.FoldingRangeKind.Imports:
                    return vscode_1.FoldingRangeKind.Imports;
                case vscode_languageserver_protocol_1.FoldingRangeKind.Region:
                    return vscode_1.FoldingRangeKind.Region;
            }
        }
        return void 0;
    }
    static asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
            return foldingRanges.map(r => {
                return new vscode_1.FoldingRange(r.startLine, r.endLine, FoldingRangeFeature.asFoldingRangeKind(r.kind));
            });
        }
        return [];
    }
}
exports.FoldingRangeFeature = FoldingRangeFeature;
//# sourceMappingURL=foldingRange.js.map

/***/ }),

/***/ 9889:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const client_1 = __webpack_require__(4384);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class ImplementationFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let implementationSupport = ensure(ensure(capabilities, 'textDocument'), 'implementation');
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideImplementation: (document, position, token) => {
                const client = this._client;
                const provideImplementation = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideImplementation
                    ? middleware.provideImplementation(document, position, token, provideImplementation)
                    : provideImplementation(document, position, token);
            }
        };
        return [vscode_1.languages.registerImplementationProvider(options.documentSelector, provider), provider];
    }
}
exports.ImplementationFeature = ImplementationFeature;
//# sourceMappingURL=implementation.js.map

/***/ }),

/***/ 3483:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/vscode-proposed.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingFeature = void 0;
const code = __webpack_require__(9496);
const proto = __webpack_require__(273);
const client_1 = __webpack_require__(4384);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class LinkedEditingFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, proto.LinkedEditingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const linkedEditingSupport = ensure(ensure(capabilities, 'textDocument'), 'linkedEditingRange');
        linkedEditingSupport.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideLinkedEditingRanges: (document, position, token) => {
                const client = this._client;
                const provideLinkedEditing = (document, position, token) => {
                    return client.sendRequest(proto.LinkedEditingRangeRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asLinkedEditingRanges, (error) => {
                        return client.handleFailedRequest(proto.LinkedEditingRangeRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideLinkedEditingRange
                    ? middleware.provideLinkedEditingRange(document, position, token, provideLinkedEditing)
                    : provideLinkedEditing(document, position, token);
            }
        };
        return [code.languages.registerLinkedEditingRangeProvider(options.documentSelector, provider), provider];
    }
}
exports.LinkedEditingFeature = LinkedEditingFeature;
//# sourceMappingURL=linkedEditingRange.js.map

/***/ }),

/***/ 3603:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const progressPart_1 = __webpack_require__(8071);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class ProgressFeature {
    constructor(_client) {
        this._client = _client;
        this.activeParts = new Set();
    }
    fillClientCapabilities(capabilities) {
        ensure(capabilities, 'window').workDoneProgress = true;
    }
    initialize() {
        const client = this._client;
        const deleteHandler = (part) => {
            this.activeParts.delete(part);
        };
        const createHandler = (params) => {
            this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
    }
    dispose() {
        for (const part of this.activeParts) {
            part.done();
        }
        this.activeParts.clear();
    }
}
exports.ProgressFeature = ProgressFeature;
//# sourceMappingURL=progress.js.map

/***/ }),

/***/ 8071:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressPart = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const Is = __webpack_require__(9763);
class ProgressPart {
    constructor(_client, _token, done) {
        this._client = _client;
        this._token = _token;
        this._reported = 0;
        this._disposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
            switch (value.kind) {
                case 'begin':
                    this.begin(value);
                    break;
                case 'report':
                    this.report(value);
                    break;
                case 'end':
                    this.done();
                    done && done(this);
                    break;
            }
        });
    }
    begin(params) {
        // Since we don't use commands this will be a silent window progress with a hidden notification.
        vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
            this._progress = progress;
            this._infinite = params.percentage === undefined;
            this._cancellationToken = cancellationToken;
            this._cancellationToken.onCancellationRequested(() => {
                this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
            });
            this.report(params);
            return new Promise((resolve, reject) => {
                this._resolve = resolve;
                this._reject = reject;
            });
        });
    }
    report(params) {
        if (this._infinite && Is.string(params.message)) {
            this._progress.report({ message: params.message });
        }
        else if (Is.number(params.percentage)) {
            let percentage = Math.max(0, Math.min(params.percentage, 100));
            let delta = Math.max(0, percentage - this._reported);
            this._progress.report({ message: params.message, increment: delta });
            this._reported += delta;
        }
    }
    cancel() {
        if (this._disposable) {
            this._disposable.dispose();
            this._disposable = undefined;
        }
        if (this._reject) {
            this._reject();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    done() {
        if (this._disposable) {
            this._disposable.dispose();
            this._disposable = undefined;
        }
        if (this._resolve) {
            this._resolve();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
}
exports.ProgressPart = ProgressPart;
//# sourceMappingURL=progressPart.js.map

/***/ }),

/***/ 8714:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class ProtocolCallHierarchyItem extends code.CallHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = ProtocolCallHierarchyItem;
//# sourceMappingURL=protocolCallHierarchyItem.js.map

/***/ }),

/***/ 6434:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode = __webpack_require__(9496);
class ProtocolCodeAction extends vscode.CodeAction {
    constructor(title, data) {
        super(title);
        this.data = data;
    }
}
exports["default"] = ProtocolCodeAction;
//# sourceMappingURL=protocolCodeAction.js.map

/***/ }),

/***/ 583:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class ProtocolCodeLens extends code.CodeLens {
    constructor(range) {
        super(range);
    }
}
exports["default"] = ProtocolCodeLens;
//# sourceMappingURL=protocolCodeLens.js.map

/***/ }),

/***/ 1807:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class ProtocolCompletionItem extends code.CompletionItem {
    constructor(label) {
        super(label);
    }
}
exports["default"] = ProtocolCompletionItem;
//# sourceMappingURL=protocolCompletionItem.js.map

/***/ }),

/***/ 8785:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/vscode-proposed.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(9496);
const ls = __webpack_require__(273);
const Is = __webpack_require__(9763);
const protocolCompletionItem_1 = __webpack_require__(1807);
const protocolCodeLens_1 = __webpack_require__(583);
const protocolDocumentLink_1 = __webpack_require__(8705);
const protocolCodeAction_1 = __webpack_require__(6434);
const protocolDiagnostic_1 = __webpack_require__(6640);
const protocolCallHierarchyItem_1 = __webpack_require__(8714);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
var CodeBlock;
(function (CodeBlock) {
    function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
    }
    CodeBlock.is = is;
})(CodeBlock || (CodeBlock = {}));
function createConverter(uriConverter, trustMarkdown) {
    const nullConverter = (value) => code.Uri.parse(value);
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asDiagnostics(diagnostics) {
        return diagnostics.map(asDiagnostic);
    }
    function asDiagnostic(diagnostic) {
        let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
        if (diagnostic.code !== undefined) {
            if (ls.CodeDescription.is(diagnostic.codeDescription)) {
                result.code = {
                    value: diagnostic.code,
                    target: asUri(diagnostic.codeDescription.href)
                };
            }
            else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
                result.hasDiagnosticCode = true;
                result.code = {
                    value: diagnostic.code.value,
                    target: asUri(diagnostic.code.target)
                };
            }
            else {
                result.code = diagnostic.code;
            }
        }
        if (diagnostic.source) {
            result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
            result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
    }
    function asRelatedInformation(relatedInformation) {
        return relatedInformation.map(asDiagnosticRelatedInformation);
    }
    function asDiagnosticRelatedInformation(information) {
        return new code.DiagnosticRelatedInformation(asLocation(information.location), information.message);
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case ls.DiagnosticTag.Unnecessary:
                return code.DiagnosticTag.Unnecessary;
            case ls.DiagnosticTag.Deprecated:
                return code.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asPosition(value) {
        if (!value) {
            return undefined;
        }
        return new code.Position(value.line, value.character);
    }
    function asRange(value) {
        if (!value) {
            return undefined;
        }
        return new code.Range(asPosition(value.start), asPosition(value.end));
    }
    function asRanges(value) {
        return value.map(value => asRange(value));
    }
    function asDiagnosticSeverity(value) {
        if (value === undefined || value === null) {
            return code.DiagnosticSeverity.Error;
        }
        switch (value) {
            case ls.DiagnosticSeverity.Error:
                return code.DiagnosticSeverity.Error;
            case ls.DiagnosticSeverity.Warning:
                return code.DiagnosticSeverity.Warning;
            case ls.DiagnosticSeverity.Information:
                return code.DiagnosticSeverity.Information;
            case ls.DiagnosticSeverity.Hint:
                return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
    }
    function asHoverContent(value) {
        if (Is.string(value)) {
            return asMarkdownString(value);
        }
        else if (CodeBlock.is(value)) {
            let result = asMarkdownString();
            return result.appendCodeblock(value.value, value.language);
        }
        else if (Array.isArray(value)) {
            let result = [];
            for (let element of value) {
                let item = asMarkdownString();
                if (CodeBlock.is(element)) {
                    item.appendCodeblock(element.value, element.language);
                }
                else {
                    item.appendMarkdown(element);
                }
                result.push(item);
            }
            return result;
        }
        else {
            let result;
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return asMarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    result = asMarkdownString();
                    result.appendText(value.value);
                    return result;
                default:
                    result = asMarkdownString();
                    result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
                    return result;
            }
        }
    }
    function asDocumentation(value) {
        if (Is.string(value)) {
            return value;
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return asMarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    return value.value;
                default:
                    return `Unsupported Markup content received. Kind is: ${value.kind}`;
            }
        }
    }
    function asMarkdownString(value) {
        const result = new code.MarkdownString(value);
        if (trustMarkdown === true) {
            result.isTrusted = trustMarkdown;
        }
        return result;
    }
    function asHover(hover) {
        if (!hover) {
            return undefined;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
    }
    function asCompletionResult(result) {
        if (!result) {
            return undefined;
        }
        if (Array.isArray(result)) {
            let items = result;
            return items.map(asCompletionItem);
        }
        let list = result;
        return new code.CompletionList(list.items.map(asCompletionItem), list.isIncomplete);
    }
    function asCompletionItemKind(value) {
        // Protocol item kind is 1 based, codes item kind is zero based.
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
            return [value - 1, undefined];
        }
        return [code.CompletionItemKind.Text, value];
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case ls.CompletionItemTag.Deprecated:
                return code.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined || tags === null) {
            return [];
        }
        const result = [];
        for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItem(item) {
        let tags = asCompletionItemTags(item.tags);
        let result = new protocolCompletionItem_1.default(item.label);
        if (item.detail) {
            result.detail = item.detail;
        }
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
            result.documentationFormat = Is.string(item.documentation) ? '$string' : item.documentation.kind;
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        let insertText = asCompletionInsertText(item);
        if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
            let [itemKind, original] = asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
                result.originalItemKind = original;
            }
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (Is.stringArray(item.commitCharacters)) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
            if (item.deprecated === true) {
                tags.push(code.CompletionItemTag.Deprecated);
            }
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        if (item.data !== undefined) {
            result.data = item.data;
        }
        if (tags.length > 0) {
            result.tags = tags;
        }
        if (item.insertTextMode !== undefined) {
            result.insertTextMode = item.insertTextMode;
            if (item.insertTextMode === vscode_languageserver_protocol_1.InsertTextMode.asIs) {
                result.keepWhitespace = true;
            }
        }
        return result;
    }
    function asCompletionInsertText(item) {
        if (item.textEdit) {
            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.textEdit.newText), range: asCompletionRange(item.textEdit), fromEdit: true };
            }
            else {
                return { text: item.textEdit.newText, range: asCompletionRange(item.textEdit), fromEdit: true };
            }
        }
        else if (item.insertText) {
            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.insertText), fromEdit: false };
            }
            else {
                return { text: item.insertText, fromEdit: false };
            }
        }
        else {
            return undefined;
        }
    }
    function asCompletionRange(value) {
        if (ls.InsertReplaceEdit.is(value)) {
            return { inserting: asRange(value.insert), replacing: asRange(value.replace) };
        }
        else {
            return asRange(value.range);
        }
    }
    function asTextEdit(edit) {
        if (!edit) {
            return undefined;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
    }
    function asTextEdits(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asTextEdit);
    }
    function asSignatureHelp(item) {
        if (!item) {
            return undefined;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
        }
        else {
            // activeSignature was optional in the past
            result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
        }
        else {
            // activeParameter was optional in the past
            result.activeParameter = 0;
        }
        if (item.signatures) {
            result.signatures = asSignatureInformations(item.signatures);
        }
        return result;
    }
    function asSignatureInformations(items) {
        return items.map(asSignatureInformation);
    }
    function asSignatureInformation(item) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation !== undefined) {
            result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters !== undefined) {
            result.parameters = asParameterInformations(item.parameters);
        }
        if (item.activeParameter !== undefined) {
            result.activeParameter = item.activeParameter;
        }
        {
            return result;
        }
    }
    function asParameterInformations(item) {
        return item.map(asParameterInformation);
    }
    function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
        }
        return result;
    }
    function asLocation(item) {
        if (!item) {
            return undefined;
        }
        return new code.Location(_uriConverter(item.uri), asRange(item.range));
    }
    function asDeclarationResult(item) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item);
    }
    function asDefinitionResult(item) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item);
    }
    function asLocationLink(item) {
        if (!item) {
            return undefined;
        }
        let result = {
            targetUri: _uriConverter(item.targetUri),
            targetRange: asRange(item.targetRange),
            originSelectionRange: asRange(item.originSelectionRange),
            targetSelectionRange: asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
            throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
    }
    function asLocationResult(item) {
        if (!item) {
            return undefined;
        }
        if (Is.array(item)) {
            if (item.length === 0) {
                return [];
            }
            else if (ls.LocationLink.is(item[0])) {
                let links = item;
                return links.map((link) => asLocationLink(link));
            }
            else {
                let locations = item;
                return locations.map((location) => asLocation(location));
            }
        }
        else if (ls.LocationLink.is(item)) {
            return [asLocationLink(item)];
        }
        else {
            return asLocation(item);
        }
    }
    function asReferences(values) {
        if (!values) {
            return undefined;
        }
        return values.map(location => asLocation(location));
    }
    function asDocumentHighlights(values) {
        if (!values) {
            return undefined;
        }
        return values.map(asDocumentHighlight);
    }
    function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is.number(item.kind)) {
            result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
    }
    function asDocumentHighlightKind(item) {
        switch (item) {
            case ls.DocumentHighlightKind.Text:
                return code.DocumentHighlightKind.Text;
            case ls.DocumentHighlightKind.Read:
                return code.DocumentHighlightKind.Read;
            case ls.DocumentHighlightKind.Write:
                return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
    }
    function asSymbolInformations(values, uri) {
        if (!values) {
            return undefined;
        }
        return values.map(information => asSymbolInformation(information, uri));
    }
    function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return item - 1;
        }
        return code.SymbolKind.Property;
    }
    function asSymbolTag(value) {
        switch (value) {
            case ls.SymbolTag.Deprecated:
                return code.SymbolTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asSymbolTags(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        const result = [];
        for (const item of items) {
            const converted = asSymbolTag(item);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length === 0 ? undefined : result;
    }
    function asSymbolInformation(item, uri) {
        // Symbol kind is one based in the protocol and zero based in code.
        let result = new code.SymbolInformation(item.name, asSymbolKind(item.kind), asRange(item.location.range), item.location.uri ? _uriConverter(item.location.uri) : uri);
        fillTags(result, item);
        if (item.containerName) {
            result.containerName = item.containerName;
        }
        return result;
    }
    function asDocumentSymbols(values) {
        if (values === undefined || values === null) {
            return undefined;
        }
        return values.map(asDocumentSymbol);
    }
    function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || '', asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        fillTags(result, value);
        if (value.children !== undefined && value.children.length > 0) {
            let children = [];
            for (let child of value.children) {
                children.push(asDocumentSymbol(child));
            }
            result.children = children;
        }
        return result;
    }
    function fillTags(result, value) {
        result.tags = asSymbolTags(value.tags);
        if (value.deprecated) {
            if (!result.tags) {
                result.tags = [code.SymbolTag.Deprecated];
            }
            else {
                if (!result.tags.includes(code.SymbolTag.Deprecated)) {
                    result.tags = result.tags.concat(code.SymbolTag.Deprecated);
                }
            }
        }
    }
    function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCommands(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asCommand);
    }
    const kindMapping = new Map();
    kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
    kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
    kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
    kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
    kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
    kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
    kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
    kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = kindMapping.get(item);
        if (result) {
            return result;
        }
        let parts = item.split('.');
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
            result = result.append(part);
        }
        return result;
    }
    function asCodeActionKinds(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        return items.map(kind => asCodeActionKind(kind));
    }
    function asCodeAction(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = new protocolCodeAction_1.default(item.title, item.data);
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit !== undefined) {
            result.edit = asWorkspaceEdit(item.edit);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    function asCodeLens(item) {
        if (!item) {
            return undefined;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.data !== undefined && item.data !== null) {
            result.data = item.data;
        }
        return result;
    }
    function asCodeLenses(items) {
        if (!items) {
            return undefined;
        }
        return items.map((codeLens) => asCodeLens(codeLens));
    }
    function asWorkspaceEdit(item) {
        if (!item) {
            return undefined;
        }
        const sharedMetadata = new Map();
        if (item.changeAnnotations !== undefined) {
            for (const key of Object.keys(item.changeAnnotations)) {
                const metaData = asWorkspaceEditEntryMetadata(item.changeAnnotations[key]);
                sharedMetadata.set(key, metaData);
            }
        }
        const asMetadata = (annotation) => {
            if (annotation === undefined) {
                return undefined;
            }
            else {
                return sharedMetadata.get(annotation);
            }
        };
        const result = new code.WorkspaceEdit();
        if (item.documentChanges) {
            for (const change of item.documentChanges) {
                if (ls.CreateFile.is(change)) {
                    result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.RenameFile.is(change)) {
                    result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.DeleteFile.is(change)) {
                    result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.TextDocumentEdit.is(change)) {
                    const uri = _uriConverter(change.textDocument.uri);
                    for (const edit of change.edits) {
                        if (vscode_languageserver_protocol_1.AnnotatedTextEdit.is(edit)) {
                            result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                        }
                        else {
                            result.replace(uri, asRange(edit.range), edit.newText);
                        }
                    }
                }
                else {
                    throw new Error(`Unknown workspace edit change received:\n${JSON.stringify(change, undefined, 4)}`);
                }
            }
        }
        else if (item.changes) {
            Object.keys(item.changes).forEach(key => {
                result.set(_uriConverter(key), asTextEdits(item.changes[key]));
            });
        }
        return result;
    }
    function asWorkspaceEditEntryMetadata(annotation) {
        if (annotation === undefined) {
            return undefined;
        }
        return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
    }
    function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : undefined;
        // target must be optional in DocumentLink
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== undefined) {
            link.tooltip = item.tooltip;
        }
        if (item.data !== undefined && item.data !== null) {
            link.data = item.data;
        }
        return link;
    }
    function asDocumentLinks(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asDocumentLink);
    }
    function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
    }
    function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
    }
    function asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
            return colorInformation.map(asColorInformation);
        }
        return undefined;
    }
    function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEdits(cp.additionalTextEdits);
        if (cp.textEdit) {
            presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
    }
    function asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
            return colorPresentations.map(asColorPresentation);
        }
        return undefined;
    }
    function asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case ls.FoldingRangeKind.Comment:
                    return code.FoldingRangeKind.Comment;
                case ls.FoldingRangeKind.Imports:
                    return code.FoldingRangeKind.Imports;
                case ls.FoldingRangeKind.Region:
                    return code.FoldingRangeKind.Region;
            }
        }
        return undefined;
    }
    function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
    }
    function asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
            return foldingRanges.map(asFoldingRange);
        }
        return undefined;
    }
    function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : undefined);
    }
    function asSelectionRanges(selectionRanges) {
        if (!Array.isArray(selectionRanges)) {
            return [];
        }
        let result = [];
        for (let range of selectionRanges) {
            result.push(asSelectionRange(range));
        }
        return result;
    }
    function asCallHierarchyItem(item) {
        if (item === null) {
            return undefined;
        }
        let result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || '', asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        return result;
    }
    function asCallHierarchyItems(items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyItem(item));
    }
    function asCallHierarchyIncomingCall(item) {
        return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), asRanges(item.fromRanges));
    }
    function asCallHierarchyIncomingCalls(items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyIncomingCall(item));
    }
    function asCallHierarchyOutgoingCall(item) {
        return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), asRanges(item.fromRanges));
    }
    function asCallHierarchyOutgoingCalls(items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyOutgoingCall(item));
    }
    function asSemanticTokens(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
    }
    function asSemanticTokensEdit(value) {
        return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== undefined ? new Uint32Array(value.data) : undefined);
    }
    function asSemanticTokensEdits(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
    }
    function asSemanticTokensLegend(value) {
        return value;
    }
    function asLinkedEditingRanges(value) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new code.LinkedEditingRanges(asRanges(value.ranges), asRegularExpression(value.wordPattern));
    }
    function asRegularExpression(value) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new RegExp(value);
    }
    return {
        asUri,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asRanges,
        asPosition,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges,
        asSemanticTokensLegend,
        asSemanticTokens,
        asSemanticTokensEdit,
        asSemanticTokensEdits,
        asCallHierarchyItem,
        asCallHierarchyItems,
        asCallHierarchyIncomingCall,
        asCallHierarchyIncomingCalls,
        asCallHierarchyOutgoingCall,
        asCallHierarchyOutgoingCalls,
        asLinkedEditingRanges: asLinkedEditingRanges
    };
}
exports.createConverter = createConverter;
//# sourceMappingURL=protocolConverter.js.map

/***/ }),

/***/ 6640:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolDiagnostic = exports.DiagnosticCode = void 0;
const vscode = __webpack_require__(9496);
const Is = __webpack_require__(9763);
var DiagnosticCode;
(function (DiagnosticCode) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);
    }
    DiagnosticCode.is = is;
})(DiagnosticCode = exports.DiagnosticCode || (exports.DiagnosticCode = {}));
class ProtocolDiagnostic extends vscode.Diagnostic {
    constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
    }
}
exports.ProtocolDiagnostic = ProtocolDiagnostic;
//# sourceMappingURL=protocolDiagnostic.js.map

/***/ }),

/***/ 8705:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class ProtocolDocumentLink extends code.DocumentLink {
    constructor(range, target) {
        super(range, target);
    }
}
exports["default"] = ProtocolDocumentLink;
//# sourceMappingURL=protocolDocumentLink.js.map

/***/ }),

/***/ 750:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const client_1 = __webpack_require__(4384);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class SelectionRangeFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, 'textDocument'), 'selectionRange');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSelectionRanges: (document, positions, token) => {
                const client = this._client;
                const provideSelectionRanges = (document, positions, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        positions: client.code2ProtocolConverter.asPositions(positions)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token).then((ranges) => client.protocol2CodeConverter.asSelectionRanges(ranges), (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideSelectionRanges
                    ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges)
                    : provideSelectionRanges(document, positions, token);
            }
        };
        return [vscode_1.languages.registerSelectionRangeProvider(options.documentSelector, provider), provider];
    }
}
exports.SelectionRangeFeature = SelectionRangeFeature;
//# sourceMappingURL=selectionRange.js.map

/***/ }),

/***/ 9957:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensFeature = void 0;
const vscode = __webpack_require__(9496);
const client_1 = __webpack_require__(4384);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const Is = __webpack_require__(9763);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class SemanticTokensFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, 'textDocument'), 'semanticTokens');
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
            vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
            vscode_languageserver_protocol_1.SemanticTokenTypes.type,
            vscode_languageserver_protocol_1.SemanticTokenTypes.class,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
            vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
            vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
            vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
            vscode_languageserver_protocol_1.SemanticTokenTypes.property,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
            vscode_languageserver_protocol_1.SemanticTokenTypes.event,
            vscode_languageserver_protocol_1.SemanticTokenTypes.function,
            vscode_languageserver_protocol_1.SemanticTokenTypes.method,
            vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
            vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
            vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
            vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
            vscode_languageserver_protocol_1.SemanticTokenTypes.string,
            vscode_languageserver_protocol_1.SemanticTokenTypes.number,
            vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
            vscode_languageserver_protocol_1.SemanticTokenTypes.operator
        ];
        capability.tokenModifiers = [
            vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
        capability.requests = {
            range: true,
            full: {
                delta: true
            }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        ensure(ensure(capabilities, 'workspace'), 'semanticTokens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeSemanticTokensEmitter.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const fullProvider = Is.boolean(options.full) ? options.full : options.full !== undefined;
        const hasEditProvider = options.full !== undefined && typeof options.full !== 'boolean' && options.full.delta === true;
        const eventEmitter = new vscode.EventEmitter();
        const documentProvider = fullProvider
            ? {
                onDidChangeSemanticTokens: eventEmitter.event,
                provideDocumentSemanticTokens: (document, token) => {
                    const client = this._client;
                    const middleware = client.clientOptions.middleware;
                    const provideDocumentSemanticTokens = (document, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token).then((result) => {
                            return client.protocol2CodeConverter.asSemanticTokens(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, error, null);
                        });
                    };
                    return middleware.provideDocumentSemanticTokens
                        ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens)
                        : provideDocumentSemanticTokens(document, token);
                },
                provideDocumentSemanticTokensEdits: hasEditProvider
                    ? (document, previousResultId, token) => {
                        const client = this._client;
                        const middleware = client.clientOptions.middleware;
                        const provideDocumentSemanticTokensEdits = (document, previousResultId, token) => {
                            const params = {
                                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                                previousResultId
                            };
                            return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token).then((result) => {
                                if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                                    return client.protocol2CodeConverter.asSemanticTokens(result);
                                }
                                else {
                                    return client.protocol2CodeConverter.asSemanticTokensEdits(result);
                                }
                            }, (error) => {
                                return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, error, null);
                            });
                        };
                        return middleware.provideDocumentSemanticTokensEdits
                            ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits)
                            : provideDocumentSemanticTokensEdits(document, previousResultId, token);
                    }
                    : undefined
            }
            : undefined;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider
            ? {
                provideDocumentRangeSemanticTokens: (document, range, token) => {
                    const client = this._client;
                    const middleware = client.clientOptions.middleware;
                    const provideDocumentRangeSemanticTokens = (document, range, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            range: client.code2ProtocolConverter.asRange(range)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token).then((result) => {
                            return client.protocol2CodeConverter.asSemanticTokens(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, error, null);
                        });
                    };
                    return middleware.provideDocumentRangeSemanticTokens
                        ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens)
                        : provideDocumentRangeSemanticTokens(document, range, token);
                }
            }
            : undefined;
        const disposables = [];
        const client = this._client;
        const legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
        if (documentProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(options.documentSelector, documentProvider, legend));
        }
        if (rangeProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(options.documentSelector, rangeProvider, legend));
        }
        return [new vscode.Disposable(() => disposables.forEach(item => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
    }
}
exports.SemanticTokensFeature = SemanticTokensFeature;
//# sourceMappingURL=semanticTokens.js.map

/***/ }),

/***/ 328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const client_1 = __webpack_require__(4384);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class TypeDefinitionFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'typeDefinition').dynamicRegistration = true;
        let typeDefinitionSupport = ensure(ensure(capabilities, 'textDocument'), 'typeDefinition');
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideTypeDefinition: (document, position, token) => {
                const client = this._client;
                const provideTypeDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideTypeDefinition
                    ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition)
                    : provideTypeDefinition(document, position, token);
            }
        };
        return [vscode_1.languages.registerTypeDefinitionProvider(options.documentSelector, provider), provider];
    }
}
exports.TypeDefinitionFeature = TypeDefinitionFeature;
//# sourceMappingURL=typeDefinition.js.map

/***/ }),

/***/ 4904:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Delayer = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(273);
class Delayer {
    constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = undefined;
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
    }
    trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
            this.cancelTimeout();
        }
        if (!this.completionPromise) {
            this.completionPromise = new Promise((resolve) => {
                this.onSuccess = resolve;
            }).then(() => {
                this.completionPromise = undefined;
                this.onSuccess = undefined;
                var result = this.task();
                this.task = undefined;
                return result;
            });
        }
        if (delay >= 0 || this.timeout === void 0) {
            this.timeout = vscode_languageserver_protocol_1.RAL().timer.setTimeout(() => {
                this.timeout = undefined;
                this.onSuccess(undefined);
            }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
    }
    forceDelivery() {
        if (!this.completionPromise) {
            return undefined;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
        return result;
    }
    isTriggered() {
        return this.timeout !== void 0;
    }
    cancel() {
        this.cancelTimeout();
        this.completionPromise = undefined;
    }
    cancelTimeout() {
        if (this.timeout !== void 0) {
            vscode_languageserver_protocol_1.RAL().timer.clearTimeout(this.timeout);
            this.timeout = undefined;
        }
    }
}
exports.Delayer = Delayer;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ 9763:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asPromise = exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
function asPromise(value) {
    if (value instanceof Promise) {
        return value;
    }
    else if (thenable(value)) {
        return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
        });
    }
    else {
        return Promise.resolve(value);
    }
}
exports.asPromise = asPromise;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ 1980:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ 9565:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFoldersFeature = exports.arrayDiff = void 0;
const UUID = __webpack_require__(1980);
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
function access(target, key) {
    if (target === void 0) {
        return undefined;
    }
    return target[key];
}
function arrayDiff(left, right) {
    return left.filter(element => right.indexOf(element) < 0);
}
exports.arrayDiff = arrayDiff;
class WorkspaceFoldersFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    fillInitializeParams(params) {
        const folders = vscode_1.workspace.workspaceFolders;
        this.initializeWithFolders(folders);
        if (folders === void 0) {
            params.workspaceFolders = null;
        }
        else {
            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));
        }
    }
    initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
    }
    initialize(capabilities) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
            const workspaceFolders = () => {
                const folders = vscode_1.workspace.workspaceFolders;
                if (folders === undefined) {
                    return null;
                }
                const result = folders.map((folder) => {
                    return this.asProtocol(folder);
                });
                return result;
            };
            const middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.workspaceFolders
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');
        let id;
        if (typeof value === 'string') {
            id = value;
        }
        else if (value === true) {
            id = UUID.generateUuid();
        }
        if (id) {
            this.register({ id: id, registerOptions: undefined });
        }
    }
    sendInitialEvent(currentWorkspaceFolders) {
        if (this._initialFolders && currentWorkspaceFolders) {
            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
            if (added.length > 0 || removed.length > 0) {
                this.doSendEvent(added, removed);
            }
        }
        else if (this._initialFolders) {
            this.doSendEvent([], this._initialFolders);
        }
        else if (currentWorkspaceFolders) {
            this.doSendEvent(currentWorkspaceFolders, []);
        }
    }
    doSendEvent(addedFolders, removedFolders) {
        let params = {
            event: {
                added: addedFolders.map(folder => this.asProtocol(folder)),
                removed: removedFolders.map(folder => this.asProtocol(folder))
            }
        };
        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
    }
    register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
            let didChangeWorkspaceFolders = (event) => {
                this.doSendEvent(event.added, event.removed);
            };
            let middleware = client.clientOptions.middleware.workspace;
            middleware && middleware.didChangeWorkspaceFolders
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
            return;
        }
        this._listeners.delete(id);
        disposable.dispose();
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
            return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
    }
}
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
//# sourceMappingURL=workspaceFolders.js.map

/***/ }),

/***/ 2850:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingMonitor = exports.LanguageClient = exports.TransportKind = void 0;
const cp = __webpack_require__(2081);
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const SemVer = __webpack_require__(1249);
const vscode_1 = __webpack_require__(9496);
const Is = __webpack_require__(9763);
const commonClient_1 = __webpack_require__(7225);
const client_1 = __webpack_require__(4384);
const processes_1 = __webpack_require__(794);
const node_1 = __webpack_require__(6560);
__exportStar(__webpack_require__(6560), exports);
__exportStar(__webpack_require__(5734), exports);
const REQUIRED_VSCODE_VERSION = '^1.52.0'; // do not change format, updated by `updateVSCode` script
var Executable;
(function (Executable) {
    function is(value) {
        return Is.string(value.command);
    }
    Executable.is = is;
})(Executable || (Executable = {}));
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
    TransportKind[TransportKind["socket"] = 3] = "socket";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
var Transport;
(function (Transport) {
    function isSocket(value) {
        let candidate = value;
        return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);
    }
    Transport.isSocket = isSocket;
})(Transport || (Transport = {}));
var NodeModule;
(function (NodeModule) {
    function is(value) {
        return Is.string(value.module);
    }
    NodeModule.is = is;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function (StreamInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
    }
    StreamInfo.is = is;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function (ChildProcessInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === 'boolean';
    }
    ChildProcessInfo.is = is;
})(ChildProcessInfo || (ChildProcessInfo = {}));
class LanguageClient extends commonClient_1.CommonLanguageClient {
    constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
            id = arg1;
            name = arg2;
            serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = !!arg5;
        }
        else {
            id = arg1.toLowerCase();
            name = arg1;
            serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        if (forceDebug === void 0) {
            forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        try {
            this.checkVersion();
        }
        catch (error) {
            if (Is.string(error.message)) {
                this.outputChannel.appendLine(error.message);
            }
            throw error;
        }
    }
    checkVersion() {
        let codeVersion = SemVer.parse(vscode_1.version);
        if (!codeVersion) {
            throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
        }
        // Remove the insider pre-release since we stay API compatible.
        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {
            codeVersion.prerelease = [];
        }
        if (!SemVer.satisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {
            throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
        }
    }
    stop() {
        return super.stop().then(() => {
            if (this._serverProcess) {
                let toCheck = this._serverProcess;
                this._serverProcess = undefined;
                if (this._isDetached === void 0 || !this._isDetached) {
                    this.checkProcessDied(toCheck);
                }
                this._isDetached = undefined;
            }
        });
    }
    checkProcessDied(childProcess) {
        if (!childProcess) {
            return;
        }
        setTimeout(() => {
            // Test if the process is still alive. Throws an exception if not
            try {
                process.kill(childProcess.pid, 0);
                processes_1.terminate(childProcess);
            }
            catch (error) {
                // All is fine.
            }
        }, 2000);
    }
    handleConnectionClosed() {
        this._serverProcess = undefined;
        super.handleConnectionClosed();
    }
    fillInitializeParams(params) {
        super.fillInitializeParams(params);
        if (params.processId === null) {
            params.processId = process.pid;
        }
    }
    createMessageTransports(encoding) {
        function getEnvironment(env, fork) {
            if (!env && !fork) {
                return undefined;
            }
            let result = Object.create(null);
            Object.keys(process.env).forEach(key => result[key] = process.env[key]);
            if (fork) {
                result['ELECTRON_RUN_AS_NODE'] = '1';
                result['ELECTRON_NO_ASAR'] = '1';
            }
            if (env) {
                Object.keys(env).forEach(key => result[key] = env[key]);
            }
            return result;
        }
        const debugStartWith = ['--debug=', '--debug-brk=', '--inspect=', '--inspect-brk='];
        const debugEquals = ['--debug', '--debug-brk', '--inspect', '--inspect-brk'];
        function startedInDebugMode() {
            let args = process.execArgv;
            if (args) {
                return args.some((arg) => {
                    return debugStartWith.some(value => arg.startsWith(value)) ||
                        debugEquals.some(value => arg === value);
                });
            }
            return false;
        }
        function assertStdio(process) {
            if (process.stdin === null || process.stdout === null || process.stderr === null) {
                throw new Error('Process created without stdio streams');
            }
        }
        let server = this._serverOptions;
        // We got a function.
        if (Is.func(server)) {
            return server().then((result) => {
                if (client_1.MessageTransports.is(result)) {
                    this._isDetached = !!result.detached;
                    return result;
                }
                else if (StreamInfo.is(result)) {
                    this._isDetached = !!result.detached;
                    return { reader: new node_1.StreamMessageReader(result.reader), writer: new node_1.StreamMessageWriter(result.writer) };
                }
                else {
                    let cp;
                    if (ChildProcessInfo.is(result)) {
                        cp = result.process;
                        this._isDetached = result.detached;
                    }
                    else {
                        cp = result;
                        this._isDetached = false;
                    }
                    cp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    return { reader: new node_1.StreamMessageReader(cp.stdout), writer: new node_1.StreamMessageWriter(cp.stdin) };
                }
            });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
            if (this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
            }
            else {
                json = runDebug.run;
            }
        }
        else {
            json = server;
        }
        return this._getServerWorkingDir(json.options).then(serverWorkingDir => {
            if (NodeModule.is(json) && json.module) {
                let node = json;
                let transport = node.transport || TransportKind.stdio;
                if (node.runtime) {
                    let args = [];
                    let options = node.options || Object.create(null);
                    if (options.execArgv) {
                        options.execArgv.forEach(element => args.push(element));
                    }
                    args.push(node.module);
                    if (node.args) {
                        node.args.forEach(element => args.push(element));
                    }
                    const execOptions = Object.create(null);
                    execOptions.cwd = serverWorkingDir;
                    execOptions.env = getEnvironment(options.env, false);
                    const runtime = this._getRuntimePath(node.runtime, serverWorkingDir);
                    let pipeName = undefined;
                    if (transport === TransportKind.ipc) {
                        // exec options not correctly typed in lib
                        execOptions.stdio = [null, null, null, 'ipc'];
                        args.push('--node-ipc');
                    }
                    else if (transport === TransportKind.stdio) {
                        args.push('--stdio');
                    }
                    else if (transport === TransportKind.pipe) {
                        pipeName = node_1.generateRandomPipeName();
                        args.push(`--pipe=${pipeName}`);
                    }
                    else if (Transport.isSocket(transport)) {
                        args.push(`--socket=${transport.port}`);
                    }
                    args.push(`--clientProcessId=${process.pid.toString()}`);
                    if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                        let serverProcess = cp.spawn(runtime, args, execOptions);
                        if (!serverProcess || !serverProcess.pid) {
                            return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        if (transport === TransportKind.ipc) {
                            serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return Promise.resolve({ reader: new node_1.IPCMessageReader(serverProcess), writer: new node_1.IPCMessageWriter(serverProcess) });
                        }
                        else {
                            return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                        }
                    }
                    else if (transport === TransportKind.pipe) {
                        return node_1.createClientPipeTransport(pipeName).then((transport) => {
                            let process = cp.spawn(runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                    else if (Transport.isSocket(transport)) {
                        return node_1.createClientSocketTransport(transport.port).then((transport) => {
                            let process = cp.spawn(runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                }
                else {
                    let pipeName = undefined;
                    return new Promise((resolve, _reject) => {
                        let args = node.args && node.args.slice() || [];
                        if (transport === TransportKind.ipc) {
                            args.push('--node-ipc');
                        }
                        else if (transport === TransportKind.stdio) {
                            args.push('--stdio');
                        }
                        else if (transport === TransportKind.pipe) {
                            pipeName = node_1.generateRandomPipeName();
                            args.push(`--pipe=${pipeName}`);
                        }
                        else if (Transport.isSocket(transport)) {
                            args.push(`--socket=${transport.port}`);
                        }
                        args.push(`--clientProcessId=${process.pid.toString()}`);
                        let options = node.options || Object.create(null);
                        options.env = getEnvironment(options.env, true);
                        options.execArgv = options.execArgv || [];
                        options.cwd = serverWorkingDir;
                        options.silent = true;
                        if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                            let sp = cp.fork(node.module, args || [], options);
                            assertStdio(sp);
                            this._serverProcess = sp;
                            sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            if (transport === TransportKind.ipc) {
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                resolve({ reader: new node_1.IPCMessageReader(this._serverProcess), writer: new node_1.IPCMessageWriter(this._serverProcess) });
                            }
                            else {
                                resolve({ reader: new node_1.StreamMessageReader(sp.stdout), writer: new node_1.StreamMessageWriter(sp.stdin) });
                            }
                        }
                        else if (transport === TransportKind.pipe) {
                            node_1.createClientPipeTransport(pipeName).then((transport) => {
                                let sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                });
                            });
                        }
                        else if (Transport.isSocket(transport)) {
                            node_1.createClientSocketTransport(transport.port).then((transport) => {
                                let sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                });
                            });
                        }
                    });
                }
            }
            else if (Executable.is(json) && json.command) {
                let command = json;
                let args = command.args || [];
                let options = Object.assign({}, command.options);
                options.cwd = options.cwd || serverWorkingDir;
                let serverProcess = cp.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                    return Promise.reject(`Launching server using command ${command.command} failed.`);
                }
                serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
            }
            return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));
        });
    }
    _getRuntimePath(runtime, serverWorkingDirectory) {
        if (path.isAbsolute(runtime)) {
            return runtime;
        }
        const mainRootPath = this._mainGetRootPath();
        if (mainRootPath !== undefined) {
            const result = path.join(mainRootPath, runtime);
            if (fs.existsSync(result)) {
                return result;
            }
        }
        if (serverWorkingDirectory !== undefined) {
            const result = path.join(serverWorkingDirectory, runtime);
            if (fs.existsSync(result)) {
                return result;
            }
        }
        return runtime;
    }
    _mainGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (!cwd) {
            cwd = this.clientOptions.workspaceFolder
                ? this.clientOptions.workspaceFolder.uri.fsPath
                : this._mainGetRootPath();
        }
        if (cwd) {
            // make sure the folder exists otherwise creating the process will fail
            return new Promise(s => {
                fs.lstat(cwd, (err, stats) => {
                    s(!err && stats.isDirectory() ? cwd : undefined);
                });
            });
        }
        return Promise.resolve(undefined);
    }
    getLocale() {
        const envValue = process.env['VSCODE_NLS_CONFIG'];
        if (envValue === undefined) {
            return 'en';
        }
        let config = undefined;
        try {
            config = JSON.parse(envValue);
        }
        catch (err) {
        }
        if (config === undefined || typeof config.locale !== 'string') {
            return 'en';
        }
        return config.locale;
    }
}
exports.LanguageClient = LanguageClient;
class SettingMonitor {
    constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    start() {
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(() => {
            if (this._client.needsStop()) {
                this._client.stop();
            }
        });
    }
    onDidChangeConfiguration() {
        let index = this._setting.indexOf('.');
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start();
        }
        else if (!enabled && this._client.needsStop()) {
            this._client.stop();
        }
    }
}
exports.SettingMonitor = SettingMonitor;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 794:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.terminate = void 0;
const cp = __webpack_require__(2081);
const path_1 = __webpack_require__(1017);
const isWindows = (process.platform === 'win32');
const isMacintosh = (process.platform === 'darwin');
const isLinux = (process.platform === 'linux');
function terminate(process, cwd) {
    if (isWindows) {
        try {
            // This we run in Atom execFileSync is available.
            // Ignore stderr since this is otherwise piped to parent.stderr
            // which might be already closed.
            let options = {
                stdio: ['pipe', 'pipe', 'ignore']
            };
            if (cwd) {
                options.cwd = cwd;
            }
            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    else if (isLinux || isMacintosh) {
        try {
            var cmd = path_1.join(__dirname, 'terminateProcess.sh');
            var result = cp.spawnSync(cmd, [process.pid.toString()]);
            return result.error ? false : true;
        }
        catch (err) {
            return false;
        }
    }
    else {
        process.kill('SIGKILL');
        return true;
    }
}
exports.terminate = terminate;
//# sourceMappingURL=processes.js.map

/***/ }),

/***/ 2847:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(2850);

/***/ }),

/***/ 1661:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(4389), exports);
__exportStar(__webpack_require__(1674), exports);
__exportStar(__webpack_require__(6140), exports);
__exportStar(__webpack_require__(542), exports);
var connection_1 = __webpack_require__(3767);
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    LSPErrorCodes.ContentModified = -32801;
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 3767:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(4389);
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ 6140:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = void 0;
const vscode_jsonrpc_1 = __webpack_require__(4389);
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
// let x: ProtocolNotificationType<number, { value: number}>;
// let y: ProtocolNotificationType<string, { value: number}>;
// x = y;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ 2918:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to a incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
//# sourceMappingURL=protocol.callHierarchy.js.map

/***/ }),

/***/ 9891:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
//# sourceMappingURL=protocol.colorProvider.js.map

/***/ }),

/***/ 5934:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
//# sourceMappingURL=protocol.configuration.js.map

/***/ }),

/***/ 764:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(6140);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
//# sourceMappingURL=protocol.declaration.js.map

/***/ }),

/***/ 7846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
//# sourceMappingURL=protocol.fileOperations.js.map

/***/ }),

/***/ 3394:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRequest = exports.FoldingRangeKind = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
//# sourceMappingURL=protocol.foldingRange.js.map

/***/ }),

/***/ 2122:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(6140);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
//# sourceMappingURL=protocol.implementation.js.map

/***/ }),

/***/ 542:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeError = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.DocumentFilter = void 0;
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = void 0;
const Is = __webpack_require__(9533);
const messages_1 = __webpack_require__(6140);
const protocol_implementation_1 = __webpack_require__(2122);
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(1589);
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolders_1 = __webpack_require__(3589);
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(5934);
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(9891);
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(3394);
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
const protocol_declaration_1 = __webpack_require__(764);
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(5206);
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(1862);
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(2918);
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(9434);
Object.defineProperty(exports, "SemanticTokenTypes", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokenTypes; } }));
Object.defineProperty(exports, "SemanticTokenModifiers", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokenModifiers; } }));
Object.defineProperty(exports, "SemanticTokens", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokens; } }));
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(5726);
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(6305);
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(7846);
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(3443);
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The DocumentFilter namespace provides helper functions to work with
 * [DocumentFilter](#DocumentFilter) literals.
 */
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !DocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type [CodeAction](#CodeAction) the response
 * is of type [CodeAction](#CodeAction) or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ 6305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
//# sourceMappingURL=protocol.linkedEditingRange.js.map

/***/ }),

/***/ 3443:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel["document"] = "document";
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel["project"] = "project";
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel["group"] = "group";
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel["scheme"] = "scheme";
    /**
     * The moniker is globally unique
     */
    UniquenessLevel["global"] = "global";
})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind["import"] = "import";
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind["export"] = "export";
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind["local"] = "local";
})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type [TextDocumentPositionParams](#TextDocumentPositionParams).
 * The response is of type [Moniker[]](#Moniker[]) or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
//# sourceMappingURL=protocol.moniker.js.map

/***/ }),

/***/ 1862:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(4389);
const messages_1 = __webpack_require__(6140);
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
//# sourceMappingURL=protocol.progress.js.map

/***/ }),

/***/ 5206:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
//# sourceMappingURL=protocol.selectionRange.js.map

/***/ }),

/***/ 9434:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
})(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
//# sourceMappingURL=protocol.semanticTokens.js.map

/***/ }),

/***/ 5726:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
//# sourceMappingURL=protocol.showDocument.js.map

/***/ }),

/***/ 1589:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(6140);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
//# sourceMappingURL=protocol.typeDefinition.js.map

/***/ }),

/***/ 3589:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
//# sourceMappingURL=protocol.workspaceFolders.js.map

/***/ }),

/***/ 9533:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ 273:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(5028);
__exportStar(__webpack_require__(5028), exports);
__exportStar(__webpack_require__(1661), exports);
function createProtocolConnection(input, output, logger, options) {
    return node_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 6560:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(273);

/***/ }),

/***/ 1674:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "integer": () => (/* binding */ integer),
/* harmony export */   "uinteger": () => (/* binding */ uinteger),
/* harmony export */   "Position": () => (/* binding */ Position),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "Location": () => (/* binding */ Location),
/* harmony export */   "LocationLink": () => (/* binding */ LocationLink),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorInformation": () => (/* binding */ ColorInformation),
/* harmony export */   "ColorPresentation": () => (/* binding */ ColorPresentation),
/* harmony export */   "FoldingRangeKind": () => (/* binding */ FoldingRangeKind),
/* harmony export */   "FoldingRange": () => (/* binding */ FoldingRange),
/* harmony export */   "DiagnosticRelatedInformation": () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   "DiagnosticSeverity": () => (/* binding */ DiagnosticSeverity),
/* harmony export */   "DiagnosticTag": () => (/* binding */ DiagnosticTag),
/* harmony export */   "CodeDescription": () => (/* binding */ CodeDescription),
/* harmony export */   "Diagnostic": () => (/* binding */ Diagnostic),
/* harmony export */   "Command": () => (/* binding */ Command),
/* harmony export */   "TextEdit": () => (/* binding */ TextEdit),
/* harmony export */   "ChangeAnnotation": () => (/* binding */ ChangeAnnotation),
/* harmony export */   "ChangeAnnotationIdentifier": () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   "AnnotatedTextEdit": () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   "TextDocumentEdit": () => (/* binding */ TextDocumentEdit),
/* harmony export */   "CreateFile": () => (/* binding */ CreateFile),
/* harmony export */   "RenameFile": () => (/* binding */ RenameFile),
/* harmony export */   "DeleteFile": () => (/* binding */ DeleteFile),
/* harmony export */   "WorkspaceEdit": () => (/* binding */ WorkspaceEdit),
/* harmony export */   "WorkspaceChange": () => (/* binding */ WorkspaceChange),
/* harmony export */   "TextDocumentIdentifier": () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   "VersionedTextDocumentIdentifier": () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   "OptionalVersionedTextDocumentIdentifier": () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   "TextDocumentItem": () => (/* binding */ TextDocumentItem),
/* harmony export */   "MarkupKind": () => (/* binding */ MarkupKind),
/* harmony export */   "MarkupContent": () => (/* binding */ MarkupContent),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "InsertTextFormat": () => (/* binding */ InsertTextFormat),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "InsertReplaceEdit": () => (/* binding */ InsertReplaceEdit),
/* harmony export */   "InsertTextMode": () => (/* binding */ InsertTextMode),
/* harmony export */   "CompletionItem": () => (/* binding */ CompletionItem),
/* harmony export */   "CompletionList": () => (/* binding */ CompletionList),
/* harmony export */   "MarkedString": () => (/* binding */ MarkedString),
/* harmony export */   "Hover": () => (/* binding */ Hover),
/* harmony export */   "ParameterInformation": () => (/* binding */ ParameterInformation),
/* harmony export */   "SignatureInformation": () => (/* binding */ SignatureInformation),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "DocumentHighlight": () => (/* binding */ DocumentHighlight),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "SymbolInformation": () => (/* binding */ SymbolInformation),
/* harmony export */   "DocumentSymbol": () => (/* binding */ DocumentSymbol),
/* harmony export */   "CodeActionKind": () => (/* binding */ CodeActionKind),
/* harmony export */   "CodeActionContext": () => (/* binding */ CodeActionContext),
/* harmony export */   "CodeAction": () => (/* binding */ CodeAction),
/* harmony export */   "CodeLens": () => (/* binding */ CodeLens),
/* harmony export */   "FormattingOptions": () => (/* binding */ FormattingOptions),
/* harmony export */   "DocumentLink": () => (/* binding */ DocumentLink),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "EOL": () => (/* binding */ EOL),
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return typeof candidate === 'string';
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ 9496:
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ 2081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 3477:
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 9796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(1892);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=extension.js.map